<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"resphoer.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. 图的基本应用1.1 找到小镇的法官小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。 如果小镇法官真的存在，那么：  小镇法官不会信任任何人。 每个人（除了小镇法官）都信任这位小镇法官。 只有一个人同时满足属性 1 和属性 2 。  给你一个数组 trust ，其中 trust[i] &#x3D; [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。">
<meta property="og:type" content="article">
<meta property="og:title" content="图">
<meta property="og:url" content="https://resphoer.github.io/%E5%9B%BE/">
<meta property="og:site_name" content="Resphoer&#39;s Space">
<meta property="og:description" content="1. 图的基本应用1.1 找到小镇的法官小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。 如果小镇法官真的存在，那么：  小镇法官不会信任任何人。 每个人（除了小镇法官）都信任这位小镇法官。 只有一个人同时满足属性 1 和属性 2 。  给你一个数组 trust ，其中 trust[i] &#x3D; [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-18T13:24:01.004Z">
<meta property="article:modified_time" content="2023-04-23T08:11:41.591Z">
<meta property="article:author" content="Resphoer">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://resphoer.github.io/%E5%9B%BE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://resphoer.github.io/%E5%9B%BE/","path":"图/","title":"图"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>图 | Resphoer's Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Resphoer's Space</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Resphoer</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-h fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">1. 图的基本应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 找到小镇的法官</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%9C%80%E5%A4%A7%E7%BD%91%E7%BB%9C%E7%A7%A9"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 最大网络秩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9B%BE%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">2. 图遍历及其应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 岛屿数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 判断二分图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 被围绕的区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 二进制矩阵中的最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 腐烂的橘子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-01-%E7%9F%A9%E9%98%B5"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 01 矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 最短的桥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 所有可能的路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">3. 最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 连接所有点的最小费用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 冗余连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 最小体力消耗路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">4.</span> <span class="nav-text">4. 最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 网络延迟时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 阈值距离内邻居最少的城市</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">5. 拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 课程表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E8%AF%BE%E7%A8%8B%E8%A1%A8-II"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 课程表 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E8%AF%BE%E7%A8%8B%E8%A1%A8-IV"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 课程表 IV</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Resphoer"
      src="/images/logo_1.png">
  <p class="site-author-name" itemprop="name">Resphoer</p>
  <div class="site-description" itemprop="description">Just Coding For Love</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/resphoer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;resphoer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://resphoer.github.io/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo_1.png">
      <meta itemprop="name" content="Resphoer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Resphoer's Space">
      <meta itemprop="description" content="Just Coding For Love">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="图 | Resphoer's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-18 21:24:01" itemprop="dateCreated datePublished" datetime="2024-03-18T21:24:01+08:00">2024-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-23 16:11:41" itemprop="dateModified" datetime="2023-04-23T16:11:41+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="1-图的基本应用"><a href="#1-图的基本应用" class="headerlink" title="1. 图的基本应用"></a>1. 图的基本应用</h2><h3 id="1-1-找到小镇的法官"><a href="#1-1-找到小镇的法官" class="headerlink" title="1.1 找到小镇的法官"></a>1.1 找到小镇的法官</h3><p>小镇里有 <code>n</code> 个人，按从 <code>1</code> 到 <code>n</code> 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。</p>
<p>如果小镇法官真的存在，那么：</p>
<ol>
<li>小镇法官不会信任任何人。</li>
<li>每个人（除了小镇法官）都信任这位小镇法官。</li>
<li>只有一个人同时满足属性 <strong>1</strong> 和属性 <strong>2</strong> 。</li>
</ol>
<p>给你一个数组 <code>trust</code> ，其中 <code>trust[i] = [ai, bi]</code> 表示编号为 <code>ai</code> 的人信任编号为 <code>bi</code> 的人。</p>
<p>如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 <code>-1</code> 。</p>
<p><strong>思路</strong></p>
<blockquote>
<p>在有向图中，一个节点的入度是指向该节点的边的数量；而一个节点的出度是从该节点出发的边的数量。</p>
</blockquote>
<p><code>ai-&gt;bi</code>相当于一条边，从<code>ai</code>指向<code>bi</code>，那么<code>ai</code>的出度加一，<code>bi</code>的入度加一，那么小镇法官应满足：</p>
<ul>
<li>入度为<code>n-1</code>(即所有人都信任法官)</li>
<li>出度为<code>0</code>(即法官不信任任何人)</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findJudge</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] trust)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] indegree=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] outdegree=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 出度、入度统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:trust)&#123;</span><br><span class="line">            ++outdegree[edge[<span class="number">0</span>]];</span><br><span class="line">            ++indegree[edge[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">// 判断是否为法官</span></span><br><span class="line">            <span class="keyword">if</span>(outdegree[i]==<span class="number">0</span>&amp;&amp;indegree[i]==n-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-最大网络秩"><a href="#1-2-最大网络秩" class="headerlink" title="1.2 最大网络秩"></a>1.2 最大网络秩</h3><p><code>n</code> 座城市和一些连接这些城市的道路 <code>roads</code> 共同组成一个基础设施网络。每个 <code>roads[i] = [ai, bi]</code> 都表示在城市 <code>ai</code> 和 <code>bi</code> 之间有一条双向道路。</p>
<p>两座不同城市构成的 <strong>城市对</strong> 的 <strong>网络秩</strong> 定义为：与这两座城市 <strong>直接</strong> 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 <strong>一次</strong> 。</p>
<p>整个基础设施网络的 <strong>最大网络秩</strong> 是所有不同城市对中的 <strong>最大网络秩</strong> 。</p>
<p>给你整数 <code>n</code> 和数组 <code>roads</code>，返回整个基础设施网络的 <strong>最大网络秩</strong> 。</p>
<p><strong>思路</strong></p>
<blockquote>
<p>在有向图中，每个点的度数等于其入度与出度之和；在无向图中，每个点的度数等于与其相连的边的数量。</p>
</blockquote>
<p>直观思路：暴力枚举每个城市的度数，然后依次选取两个城市进行比较得出最大网络秩，满足条件为：</p>
<ul>
<li>若两个城市之间有道路相连，那么它们的网络秩为<code>degree[i]+degree[j]-1</code></li>
<li>若两个城市之间没有道路相连，那么它们的网络秩为<code>degree[i]+degree[j]</code></li>
</ul>
<p>依次比较得出最大值即可。</p>
<p>贪心思路：要求最大网络秩，只需要考虑度数最大以及度数次大的城市即可。</p>
<p>不妨设度数最大值为<code>first</code>，度数次大值为<code>second</code>，图中可能存在多个城市度数值等于<code>first</code>或<code>second</code>，那么我们设所有度数值等于最大值的城市构成一个集合<code>firstAttr</code>，所有度数值等于次大值的城市构成一个集合<code>secondAttr</code>，接下来求最大网络秩，我们只需在这两个集合内考虑即可，分为以下几种情况讨论：</p>
<ul>
<li>若<code>firstAttr.size()==1</code>，考虑到<code>first&gt;=second+1 -&gt; first+second-1&gt;=second+second</code>，即在<code>secondAttr</code>中选取两个城市组成的网络秩大小不可能超过在这两个集合中分别选取一个，那么我们必须选取<code>firstAttr</code>中的唯一城市，然后在<code>secondAttr</code>中依次枚举，寻找是否有不与该城市直接相连的城市，若有，则返回<code>first+second</code>；否则返回<code>first+second-1</code>；</li>
<li>若<code>firstAttr.size()&gt;1</code>，考虑到<code>first&gt;=second+1 -&gt; first+first-1&gt;=first+second&gt;second+second</code>，即在<code>firstAttr</code>集合中选择两个城市组成的网络秩最大，设<code>m</code>为城市道路总数，考虑；<ul>
<li>若<code>firstAttr.size()*(firstAttr.size()-1)/2&gt;m</code>，即任意选择两个城市组成的道路总数大于现有道路总数，说明此时一定存在两个城市，它们之间没有道路相连，最大网络秩为<code>first+first</code>；</li>
<li>反之，则枚举集合中的城市，依次选择两个城市，判断是否有道路相连，若无，则返回<code>first+first</code>；否则返回<code>first+first-1</code>。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalNetworkRank</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] roads)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] connect=<span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">int</span>[] degree=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] road:roads)&#123;</span><br><span class="line">            <span class="type">int</span> x=road[<span class="number">0</span>],y=road[<span class="number">1</span>];</span><br><span class="line">            degree[x]++;</span><br><span class="line">            degree[y]++;</span><br><span class="line">            connect[x][y]=<span class="literal">true</span>;</span><br><span class="line">            connect[y][x]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> first=-<span class="number">1</span>,second=-<span class="number">2</span>;</span><br><span class="line">        List&lt;Integer&gt; firstAttr=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; secondAttr=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i]&gt;first)&#123;<span class="comment">// 若度数大于first，更新first</span></span><br><span class="line">                second=first;<span class="comment">// first自然变为了second</span></span><br><span class="line">                secondAttr=<span class="keyword">new</span> <span class="title class_">ArrayList</span>(firstAttr);<span class="comment">// 更新secondAttr</span></span><br><span class="line">                firstAttr.clear();</span><br><span class="line">                firstAttr.add(i);</span><br><span class="line">                first=degree[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(degree[i]==first)&#123;</span><br><span class="line">                firstAttr.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(degree[i]&gt;second)&#123;<span class="comment">// 更新second</span></span><br><span class="line">                secondAttr.clear();</span><br><span class="line">                secondAttr.add(i);</span><br><span class="line">                second=degree[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(degree[i]==second)&#123;</span><br><span class="line">                secondAttr.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(firstAttr.size()==<span class="number">1</span>)&#123;<span class="comment">// firstAttr仅有一个城市，必须选择</span></span><br><span class="line">            <span class="type">int</span> u=firstAttr.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 枚举</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:secondAttr)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!connect[u][v])&#123;</span><br><span class="line">                    <span class="keyword">return</span> first+second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> first+second-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> m=roads.length;</span><br><span class="line">            <span class="keyword">if</span>(firstAttr.size()*(firstAttr.size()-<span class="number">1</span>)/<span class="number">2</span>&gt;m)&#123;<span class="comment">// 判断是否一定存在两个城市不相连</span></span><br><span class="line">                <span class="keyword">return</span> first*<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 枚举</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> u:firstAttr)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> v:firstAttr)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(u!=v&amp;&amp;!connect[u][v])&#123;</span><br><span class="line">                            <span class="keyword">return</span> first*<span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> first*<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-图遍历及其应用"><a href="#2-图遍历及其应用" class="headerlink" title="2. 图遍历及其应用"></a>2. 图遍历及其应用</h2><h3 id="2-1-岛屿数量"><a href="#2-1-岛屿数量" class="headerlink" title="2.1 岛屿数量"></a>2.1 岛屿数量</h3><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索或广度优先搜索，每次遇到<code>&#39;1&#39;</code>则从该点出发遍历图，将<code>&#39;1&#39;</code>置为<code>&#39;0&#39;</code>，岛屿个数加一。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=grid.length,m=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    num+=dfs(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> cur_x,<span class="type">int</span> cur_y)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(cur_x&lt;<span class="number">0</span>||cur_y&lt;<span class="number">0</span>||cur_x&gt;=grid.length||cur_y&gt;=grid[<span class="number">0</span>].length||grid[cur_x][cur_y]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[cur_x][cur_y]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 四个方向遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=cur_x+dx[i],y=cur_y+dy[i];</span><br><span class="line">            dfs(grid,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-判断二分图"><a href="#2-2-判断二分图" class="headerlink" title="2.2 判断二分图"></a>2.2 判断二分图</h3><p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p>
<ul>
<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>
<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>
<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>
<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>
</ul>
<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>
<p>如果图是二分图，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>思路</strong></p>
<p>采用三色标记法，对当前节点进行颜色标记，然后以从该节点开始遍历图，若相邻节点未被标记，那么将其标记上不同的颜色；若相邻节点已被标记，判断其颜色是否和当前节点颜色相同，若相同，返回<code>false</code>；若不同，则继续遍历。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=graph.length;</span><br><span class="line">        <span class="type">int</span>[] color=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 判断当前节点是否被标记及合理性</span></span><br><span class="line">            <span class="keyword">if</span>(color[i]==<span class="number">0</span>&amp;&amp;!dfs(graph,i,<span class="number">1</span>,color))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph,<span class="type">int</span> u,<span class="type">int</span> c_color,<span class="type">int</span>[] color)</span>&#123;</span><br><span class="line">        color[u]=c_color;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ed:graph[u])&#123;</span><br><span class="line">            <span class="comment">// 相邻节点颜色相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(color[ed]==color[u])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 未被标记，递归遍历</span></span><br><span class="line">            <span class="keyword">if</span>(color[ed]==<span class="number">0</span>&amp;&amp;!dfs(graph,ed,<span class="number">3</span>^c_color,color))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-被围绕的区域"><a href="#2-3-被围绕的区域" class="headerlink" title="2.3 被围绕的区域"></a>2.3 被围绕的区域</h3><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p><strong>思路</strong></p>
<p>从边界开始遍历，若遇到<code>&#39;O&#39;</code>则将其置为<code>&#39;1&#39;</code>，并从该节点开始遍历图。</p>
<p>这样处理后，所有与边界相接的<code>&#39;O&#39;</code>均变为了<code>&#39;1&#39;</code>，而对于图中的其它<code>&#39;O&#39;</code>，由于其未与边界相接，即都被<code>&#39;X&#39;</code>包围，将其置为<code>&#39;X&#39;</code>即可，对于<code>&#39;1&#39;</code>，则将其还原为<code>&#39;O&#39;</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=board.length,m=board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 边界处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dfs(board,i,<span class="number">0</span>);</span><br><span class="line">            dfs(board,i,m-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            dfs(board,<span class="number">0</span>,j);</span><br><span class="line">            dfs(board,n-<span class="number">1</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="comment">// 还原变换</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j]=<span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=board.length||y&gt;=board[<span class="number">0</span>].length||board[x][y]!=<span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        dfs(board,x+<span class="number">1</span>,y);</span><br><span class="line">        dfs(board,x,y+<span class="number">1</span>);</span><br><span class="line">        dfs(board,x-<span class="number">1</span>,y);</span><br><span class="line">        dfs(board,x,y-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-二进制矩阵中的最短路径"><a href="#2-4-二进制矩阵中的最短路径" class="headerlink" title="2.4 二进制矩阵中的最短路径"></a>2.4 二进制矩阵中的最短路径</h3><p>给你一个 <code>n x n</code> 的二进制矩阵 <code>grid</code> 中，返回矩阵中最短 <strong>畅通路径</strong> 的长度。如果不存在这样的路径，返回 <code>-1</code> 。</p>
<p>二进制矩阵中的 畅通路径 是一条从 <strong>左上角</strong> 单元格（即，<code>(0, 0)</code>）到 右下角 单元格（即，<code>(n - 1, n - 1)</code>）的路径，该路径同时满足下述要求：</p>
<ul>
<li>路径途经的所有单元格都的值都是 <code>0</code> 。</li>
<li>路径中所有相邻的单元格应当在 <strong>8 个方向之一</strong> 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li>
</ul>
<p><strong>畅通路径的长度</strong> 是该路径途经的单元格总数。</p>
<p> <strong>思路</strong></p>
<p>广度优先搜索，每次遍历一层，直到到达右下角。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathBinaryMatrix</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// 8个方向</span></span><br><span class="line">        <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n=grid.length;</span><br><span class="line">        <span class="comment">// 判断左上角与右下角是否为1</span></span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>||grid[n-<span class="number">1</span>][n-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; hep=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        hep.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> s=hep.size();</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="type">int</span>[] p=hep.poll();</span><br><span class="line">                <span class="comment">// 若到达右下角，返回路径长度</span></span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">0</span>]==n-<span class="number">1</span>&amp;&amp;p[<span class="number">1</span>]==n-<span class="number">1</span>) <span class="keyword">return</span> step;</span><br><span class="line">                <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">                    <span class="type">int</span> x=dx[j]+p[<span class="number">0</span>],y=dy[j]+p[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=n||y&gt;=n||grid[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    grid[x][y]=<span class="number">1</span>;</span><br><span class="line">                    hep.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-腐烂的橘子"><a href="#2-5-腐烂的橘子" class="headerlink" title="2.5 腐烂的橘子"></a>2.5 腐烂的橘子</h3><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>
<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
<p> <strong>思路</strong></p>
<p>广度优先搜索，首先将所有腐烂的橘子入队，然后进行广度优先搜索，最后判断新鲜橘子个数是否为<code>0</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// 四个方向</span></span><br><span class="line">        <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n=grid.length,m=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 新鲜橘子个数</span></span><br><span class="line">        <span class="type">int</span> fr=<span class="number">0</span>;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; hep=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;<span class="comment">// 腐烂橘子入队</span></span><br><span class="line">                    hep.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;<span class="comment">// 新鲜橘子个数加一</span></span><br><span class="line">                    fr++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无新鲜橘子，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(fr==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩散时间</span></span><br><span class="line">        <span class="type">int</span> minutes=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> s=hep.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="type">int</span>[] p=hep.poll();</span><br><span class="line">                <span class="comment">// 广度优先搜索</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                    <span class="type">int</span> x=p[<span class="number">0</span>]+dx[j],y=p[<span class="number">1</span>]+dy[j];</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=n||y&gt;=m||grid[x][y]!=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 新鲜橘子腐烂，个数减一</span></span><br><span class="line">                    fr--;</span><br><span class="line">                    grid[x][y]=<span class="number">2</span>;</span><br><span class="line">                    hep.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minutes++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否还有剩余的新鲜橘子</span></span><br><span class="line">        <span class="comment">// 若有，返回-1；反之返回minutes</span></span><br><span class="line">        <span class="keyword">return</span> fr==<span class="number">0</span>?minutes:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-6-01-矩阵"><a href="#2-6-01-矩阵" class="headerlink" title="2.6 01 矩阵"></a>2.6 01 矩阵</h3><p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code> ，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>
<p>两个相邻元素间的距离为 <code>1</code> 。</p>
<p><strong>思路</strong></p>
<p>动态规划，当前位置到最近<code>0</code>的距离即为从左、上或右、下位置到最近<code>0</code>的距离加一，状态转移方程：</p>
<blockquote>
<p> <code>dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i+1][j],dp[i][j+1])</code></p>
</blockquote>
<p>初始化，若当前位置为<code>0</code>，那么其距离即为<code>0</code>，若当前位置为<code>1</code>，则将其初始化为一个较大的数。</p>
<p>求解时，注意边界范围。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] mat) &#123;</span><br><span class="line">        <span class="type">int</span> n=mat.length,m=mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="comment">// 初始化较大数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i],INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若为0，则置0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左、上方进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i-<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右、下方进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i+<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i][j+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-7-最短的桥"><a href="#2-7-最短的桥" class="headerlink" title="2.7 最短的桥"></a>2.7 最短的桥</h3><p>给你一个大小为 <code>n x n</code> 的二元矩阵 <code>grid</code> ，其中 <code>1</code> 表示陆地，<code>0</code> 表示水域。</p>
<p><strong>岛</strong> 是由四面相连的 <code>1</code> 形成的一个最大组，即不会与非组内的任何其他 <code>1</code> 相连。<code>grid</code> 中 <strong>恰好存在两座岛</strong> 。</p>
<p>你可以将任意数量的 <code>0</code> 变为 <code>1</code> ，以使两座岛连接起来，变成 <strong>一座岛</strong> 。</p>
<p>返回必须翻转的 <code>0</code> 的最小数目。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索+广度优先搜索，首先找到其中一座岛，并通过深度优先搜索将其坐标位置加入队列中，遍历完后，进行广度优先搜索，若找到了陆地，则说明到达了另一座岛，返回翻转<code>0</code>的数目。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;<span class="type">int</span>[]&gt; cnt=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=grid.length;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    <span class="comment">// 广度优先搜索</span></span><br><span class="line">                    <span class="keyword">while</span>(!cnt.isEmpty())&#123;</span><br><span class="line">                        <span class="type">int</span> sz=cnt.size();</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;sz;k++)&#123;</span><br><span class="line">                            <span class="type">int</span>[] p=cnt.poll();</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">0</span>;h&lt;<span class="number">4</span>;h++)&#123;</span><br><span class="line">                                <span class="type">int</span> x=p[<span class="number">0</span>]+dx[h],y=p[<span class="number">1</span>]+dy[h];</span><br><span class="line">                                <span class="comment">// 判断是否越界</span></span><br><span class="line">                                <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=n||y&gt;=n)&#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(grid[x][y]==<span class="number">0</span>)&#123;<span class="comment">// 为0则加入队列</span></span><br><span class="line">                                    cnt.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                                    grid[x][y]=-<span class="number">1</span>;</span><br><span class="line">                                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[x][y]==<span class="number">1</span>)&#123;<span class="comment">// 为1说明已经找到了另一座岛，返回num</span></span><br><span class="line">                                    <span class="keyword">return</span> num;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 翻转0的数目加一</span></span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深度优先搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=grid.length||y&gt;=grid[<span class="number">0</span>].length||grid[x][y]!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y]=<span class="number">0</span>;</span><br><span class="line">        cnt.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">        dfs(grid,x+<span class="number">1</span>,y);</span><br><span class="line">        dfs(grid,x,y+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,x-<span class="number">1</span>,y);</span><br><span class="line">        dfs(grid,x,y-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-8-所有可能的路径"><a href="#2-8-所有可能的路径" class="headerlink" title="2.8 所有可能的路径"></a>2.8 所有可能的路径</h3><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索+回溯，考虑当前节点，将其加入后，进行深度优先搜索继续遍历，若最终未到达节点<code>n-1</code>，则回溯，选取下一个节点继续遍历。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="comment">// 先将0加入数组tmp中</span></span><br><span class="line">        tmp.add(<span class="number">0</span>);</span><br><span class="line">        dfs(graph,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">// 若v==graph.length-1，则将tmp加入目标数组中</span></span><br><span class="line">        <span class="keyword">if</span>(v==graph.length-<span class="number">1</span>)&#123;</span><br><span class="line">            cnt.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u:graph[v])&#123;</span><br><span class="line">            <span class="comment">// 加入节点</span></span><br><span class="line">            tmp.add(u);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            dfs(graph,u);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-最小生成树"><a href="#3-最小生成树" class="headerlink" title="3. 最小生成树"></a>3. 最小生成树</h2><h3 id="3-1-连接所有点的最小费用"><a href="#3-1-连接所有点的最小费用" class="headerlink" title="3.1 连接所有点的最小费用"></a>3.1 连接所有点的最小费用</h3><p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi]</code> 。</p>
<p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>|xi - xj| + |yi - yj|</code>  ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p>
<p><strong>思路</strong></p>
<p>Prim 算法或 Kruskal 算法。</p>
<p>算法：<a target="_blank" rel="noopener" href="https://oi-wiki.org/graph/mst/">https://oi-wiki.org/graph/mst/</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=points.length;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出所有边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> x1=points[i][<span class="number">0</span>],y1=points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> x2=points[j][<span class="number">0</span>],y2=points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> weight=Math.abs(x1-x2)+Math.abs(y1-y2);</span><br><span class="line">                graph[i].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j,weight&#125;);</span><br><span class="line">                graph[j].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;j,i,weight&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; cnt=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; (a[<span class="number">2</span>]-b[<span class="number">2</span>]));</span><br><span class="line">        <span class="type">boolean</span>[] vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="comment">// 将第0个点的边加入优先队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] ed:graph[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">// 若节点已经添加过，则continue</span></span><br><span class="line">            <span class="keyword">if</span>(vis[ed[<span class="number">1</span>]])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.add(ed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记节点已被添加</span></span><br><span class="line">        vis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!cnt.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] p=cnt.poll();</span><br><span class="line">            <span class="type">int</span> to=p[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> weight=p[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 若节点被添加过，continue</span></span><br><span class="line">            <span class="keyword">if</span>(vis[to])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加当前节点，并更新最小代价</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] ed:graph[to])&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[ed[<span class="number">1</span>]])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt.add(ed);</span><br><span class="line">            &#125;</span><br><span class="line">            vis[to]=<span class="literal">true</span>;</span><br><span class="line">            ans+=weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-冗余连接"><a href="#3-2-冗余连接" class="headerlink" title="3.2 冗余连接"></a>3.2 冗余连接</h3><p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong> 图。</p>
<p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code> 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code> ，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组 <code>edges</code> 中最后出现的边。</p>
<p><strong>思路</strong></p>
<p>并查集，初始时，每个节点都属于不同的集合，依次遍历边集，更新节点所属集合，若发现两个节点属于同一集合，则说明改边是多余边。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> n=edges.length;</span><br><span class="line">        <span class="type">int</span>[] parent=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 并查集初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历边集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:edges)&#123;</span><br><span class="line">            <span class="type">int</span> x=edge[<span class="number">0</span>],y=edge[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 若两者属于不同集合，合并</span></span><br><span class="line">            <span class="keyword">if</span>(find(parent,x)!=find(parent,y))&#123;</span><br><span class="line">                union(parent,x,y);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 若两者属于同一集合，说明该边多余</span></span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找根节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=parent[x]) parent[x]=find(parent,parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        parent[find(parent,y)]=parent[find(parent,x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-最小体力消耗路径"><a href="#3-3-最小体力消耗路径" class="headerlink" title="3.3 最小体力消耗路径"></a>3.3 最小体力消耗路径</h3><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>
<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>
<p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p>
<p><strong>思路</strong></p>
<p>Dijkstra 算法。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=heights.length;</span><br><span class="line">        <span class="type">int</span> m=heights[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; cnt=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; (a[<span class="number">2</span>]-b[<span class="number">2</span>]));</span><br><span class="line">        <span class="type">boolean</span>[] vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n*m];</span><br><span class="line">        <span class="type">int</span>[] dist=<span class="keyword">new</span> <span class="title class_">int</span>[n*m];</span><br><span class="line">        cnt.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        Arrays.fill(dist,Integer.MAX_VALUE);</span><br><span class="line">        dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!cnt.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] p=cnt.poll();</span><br><span class="line">            <span class="type">int</span> x=p[<span class="number">0</span>],y=p[<span class="number">1</span>],w=p[<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> pos=x*m+y;</span><br><span class="line">            <span class="keyword">if</span>(vis[pos])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x==n-<span class="number">1</span>&amp;&amp;y==m-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[pos]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> nx=x+dx[i],ny=y+dy[i];</span><br><span class="line">                <span class="comment">// 更新路径长度</span></span><br><span class="line">                <span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;ny&lt;m&amp;&amp;Math.max(w,Math.abs(heights[nx][ny]-heights[x][y]))&lt;dist[nx*m+ny])&#123;</span><br><span class="line">                    dist[nx*m+ny]=Math.max(w,Math.abs(heights[nx][ny]-heights[x][y]));</span><br><span class="line">                    cnt.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx,ny,dist[nx*m+ny]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[n*m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-最短路径"><a href="#4-最短路径" class="headerlink" title="4. 最短路径"></a>4. 最短路径</h2><h3 id="4-1-网络延迟时间"><a href="#4-1-网络延迟时间" class="headerlink" title="4.1 网络延迟时间"></a>4.1 网络延迟时间</h3><p>有 <code>n</code> 个网络节点，标记为 <code>1</code> 到 <code>n</code>。</p>
<p>给你一个列表 <code>times</code>，表示信号经过 <strong>有向</strong> 边的传递时间。 <code>times[i] = (ui, vi, wi)</code>，其中 <code>ui</code> 是源节点，<code>vi</code> 是目标节点， <code>wi</code> 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 <code>K</code> 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 <code>-1</code> 。</p>
<p> <strong>思路</strong></p>
<p>Dijkstra 算法求出到达所有节点的最短路径，最后比较各个节点的路径长度取最大值得出时间。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">        <span class="comment">// dist初始化</span></span><br><span class="line">        Arrays.fill(dist,INF);</span><br><span class="line">        dist[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; hep=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// 存储图消息</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] time:times)&#123;</span><br><span class="line">            graph[time[<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;time[<span class="number">1</span>],time[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        hep.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,k,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] p=hep.poll();</span><br><span class="line">            <span class="type">int</span> v=p[<span class="number">1</span>],w=p[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] edge:graph[v])&#123;</span><br><span class="line">                <span class="comment">// 更新路径长度</span></span><br><span class="line">                <span class="keyword">if</span>(w+edge[<span class="number">1</span>]&lt;dist[edge[<span class="number">0</span>]])&#123;</span><br><span class="line">                    dist[edge[<span class="number">0</span>]]=w+edge[<span class="number">1</span>];</span><br><span class="line">                    hep.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v,edge[<span class="number">0</span>],dist[edge[<span class="number">0</span>]]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[i]==INF) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            ans=Math.max(ans,dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-阈值距离内邻居最少的城市"><a href="#4-2-阈值距离内邻居最少的城市" class="headerlink" title="4.2 阈值距离内邻居最少的城市"></a>4.2 阈值距离内邻居最少的城市</h3><p>有 <code>n</code> 个城市，按从 <code>0</code> 到 <code>n-1</code> 编号。给你一个边数组 <code>edges</code>，其中 <code>edges[i] = [fromi, toi, weighti]</code> 代表 <code>fromi</code> 和 <code>toi</code> 两个城市之间的双向加权边，距离阈值是一个整数 <code>distanceThreshold</code>。</p>
<p>返回能通过某些路径到达其他城市数目最少、且路径距离 <strong>最大</strong> 为 <code>distanceThreshold</code> 的城市。如果有多个这样的城市，则返回编号最大的城市。</p>
<p>注意，连接城市 <em><strong>i</strong></em> 和 <em><strong>j</strong></em> 的路径的距离等于沿该路径的所有边的权重之和。</p>
<p><strong>思路</strong></p>
<p>Floyd 算法。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTheCity</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> distanceThreshold)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 初始化dp为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i],Integer.MAX_VALUE);</span><br><span class="line">            <span class="comment">// 自身距离为0</span></span><br><span class="line">            dp[i][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据边初始化dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:edges)&#123;</span><br><span class="line">            dp[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]]=edge[<span class="number">2</span>];</span><br><span class="line">            dp[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]]=edge[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Floyd算法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][k]!=Integer.MAX_VALUE&amp;&amp;dp[k][j]!=Integer.MAX_VALUE)</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求阈值距离内邻居最少的城市</span></span><br><span class="line">        <span class="type">int</span> index=-<span class="number">1</span>,count=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&lt;=distanceThreshold)&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=count)&#123;</span><br><span class="line">                count=num;</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-拓扑排序"><a href="#5-拓扑排序" class="headerlink" title="5. 拓扑排序"></a>5. 拓扑排序</h2><h3 id="5-1-课程表"><a href="#5-1-课程表" class="headerlink" title="5.1 课程表"></a>5.1 课程表</h3><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>思路</strong></p>
<p>题意即判断所给是否为有向无环图，通过深度优先搜索判断图中是否有环即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line">        <span class="comment">// 构建图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] prerequisity:prerequisites)&#123;</span><br><span class="line">            graph[prerequisity[<span class="number">1</span>]].add(prerequisity[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] vis=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="comment">// 判断是否有环</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>&amp;&amp;!dfs(graph,i,vis))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt;[] graph,<span class="type">int</span> u,<span class="type">int</span>[] vis)</span>&#123;</span><br><span class="line">        <span class="comment">// 1表示搜索中</span></span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:graph[u])&#123;</span><br><span class="line">            <span class="comment">// 若未被搜索，则搜索该节点</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=dfs(graph,v,vis);</span><br><span class="line">                <span class="comment">// 若出现环，返回false</span></span><br><span class="line">                <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[v]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2表示搜索结束</span></span><br><span class="line">        vis[u]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-课程表-II"><a href="#5-2-课程表-II" class="headerlink" title="5.2 课程表 II"></a>5.2 课程表 II</h3><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p>
<ul>
<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li>
</ul>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>
<p><strong>思路</strong></p>
<p>广度优先搜索+拓扑排序，首先构造图，将入度为 0 的节点加入队列中（入度为 0 即无先修课程），然后依次加入目标数组中，更新图中节点的入度，若入度不为 0 ，不做处理；反之将其加入队列，这样能够保证拓扑排序。</p>
<p>最终比较目标数组大小是否等于课程数，若相等，即所有课程都能够学习；若不等，说明无法满足所有先修课程条件，无法全部学习。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; dq=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="type">int</span>[] indegree=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        List&lt;Integer&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line">        <span class="comment">// 构造图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] pq:prerequisites)&#123;</span><br><span class="line">            graph[pq[<span class="number">1</span>]].add(pq[<span class="number">0</span>]);</span><br><span class="line">            indegree[pq[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="comment">// 入度为0，入队</span></span><br><span class="line">            <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dq.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> u=dq.poll();</span><br><span class="line">            result[index++]=u;</span><br><span class="line">            <span class="comment">// 更新节点入度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:graph[u])&#123;</span><br><span class="line">                --indegree[v];</span><br><span class="line">                <span class="comment">// 入度为0，入队</span></span><br><span class="line">                <span class="keyword">if</span>(indegree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dq.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断index?=numCourses</span></span><br><span class="line">        <span class="comment">// 不等返回空数组</span></span><br><span class="line">        <span class="comment">// 相等返回result</span></span><br><span class="line">        <span class="keyword">return</span> index==numCourses?result:<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3-课程表-IV"><a href="#5-3-课程表-IV" class="headerlink" title="5.3 课程表 IV"></a>5.3 课程表 IV</h3><p>你总共需要上 <code>numCourses</code> 门课，课程编号依次为 <code>0</code> 到 <code>numCourses-1</code> 。你会得到一个数组 <code>prerequisite</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> 你 <strong>必须</strong> 先选 <code>ai</code> 课程。</p>
<ul>
<li>有的课会有直接的先修课程，比如如果想上课程 <code>1</code> ，你必须先上课程 <code>0</code> ，那么会以 <code>[0,1]</code> 数对的形式给出先修课程数对。</li>
</ul>
<p>先决条件也可以是 <strong>间接</strong> 的。如果课程 <code>a</code> 是课程 <code>b</code> 的先决条件，课程 <code>b</code> 是课程 <code>c</code> 的先决条件，那么课程 <code>a</code> 就是课程 <code>c</code> 的先决条件。</p>
<p>你也得到一个数组 <code>queries</code> ，其中 <code>queries[j] = [uj, vj]</code>。对于第 <code>j</code> 个查询，您应该回答课程 <code>uj</code> 是否是课程 <code>vj</code> 的先决条件。</p>
<p>返回一个布尔数组 <code>answer</code> ，其中 <code>answer[j]</code> 是第 <code>j</code> 个查询的答案。</p>
<p><strong>思路</strong></p>
<p>拓扑排序，同题解二，每次更新节点入度时，同时更新节点的先决条件。</p>
<p>先决条件用<code>Set</code>存储可以保证去重。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites, <span class="type">int</span>[][] queries)</span> &#123;</span><br><span class="line">        <span class="comment">// 图</span></span><br><span class="line">        List&lt;Integer&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line">        <span class="comment">// 先决条件</span></span><br><span class="line">        Set&lt;Integer&gt;[] pre=<span class="keyword">new</span> <span class="title class_">Set</span>[numCourses];</span><br><span class="line">        <span class="comment">// 入度</span></span><br><span class="line">        <span class="type">int</span>[] degree=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            pre[i]=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] pq:prerequisites)&#123;</span><br><span class="line">            graph[pq[<span class="number">0</span>]].add(pq[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 入度加一</span></span><br><span class="line">            degree[pq[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; dq=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dq.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> u=dq.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:graph[u])&#123;</span><br><span class="line">                <span class="comment">// 入度减一</span></span><br><span class="line">                degree[v]--;</span><br><span class="line">                <span class="comment">// v节点的直接先决条件是u，加入u</span></span><br><span class="line">                pre[v].add(u);</span><br><span class="line">                <span class="comment">// v节点的间接先决条件是u的先决条件</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> e:pre[u])&#123;</span><br><span class="line">                    pre[v].add(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(degree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dq.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询query</span></span><br><span class="line">        List&lt;Boolean&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] query:queries)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[query[<span class="number">1</span>]].contains(query[<span class="number">0</span>]))&#123;</span><br><span class="line">                cnt.add(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt.add(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" rel="prev" title="栈与队列">
                  <i class="fa fa-angle-left"></i> 栈与队列
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5/" rel="next" title="数组和矩阵">
                  数组和矩阵 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Resphoer</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">104k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
