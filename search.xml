<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA 虚拟机</title>
    <url>/JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="深入理解JAVA虚拟机"><a href="#深入理解JAVA虚拟机" class="headerlink" title="深入理解JAVA虚拟机"></a>深入理解JAVA虚拟机</h1><h2 id="一-自动内存管理"><a href="#一-自动内存管理" class="headerlink" title="一. 自动内存管理"></a>一. 自动内存管理</h2><h3 id="1-Java-内存区域与内存溢出异常"><a href="#1-Java-内存区域与内存溢出异常" class="headerlink" title="1. Java 内存区域与内存溢出异常"></a>1. Java 内存区域与内存溢出异常</h3><h4 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h4><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存空间划分为几个不同的数据区域，这些区域有各自的用途，它们的创建和销毁时间各有不同。</p>
<p>运行时数据区域划分：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230613101519913.png" alt="image-20230613101519913"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，即当前正在执行的字节码指令。</p>
<p>为了保证多个线程之间独立不受其他线程影响，每个线程都具有一个独立的程序计数器，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<ul>
<li>线程执行 Java 方法：程序计数器指向正在执行的虚拟机字节码指令的地址</li>
<li>线程执行本地（native）方法：程序计数器值为空，这是唯一一个在《Java 虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域</li>
</ul>
<h5 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h5><p>线程私有，生命周期与线程相同。</p>
<p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，对应着一个栈帧从入栈到出栈的过程。</p>
<p>局部变量表中的存储空间以局部变量槽来表示，其中64位的 long 和 double 类型占用两个变量槽，其它数据类型只占用1个。局部变量表所需内存空间在编译期间完成分配，方法所需的局部变量空间大小是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<ul>
<li>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度时抛出异常</li>
<li>OutOfMemoryError：Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存空间时抛出异常</li>
</ul>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>类似Java 虚拟机栈，只不过是为本地方法（native）服务。</p>
<h5 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h5><p>虚拟机所管理内存中最大的一块。</p>
<p>堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例。</p>
<p>堆是垃圾收集器管理的内存区域，因而也被称为“GC堆”。它可以处于物理上不连续的内存空间中，但在逻辑上应该被视为连续的，其实现可以是固定大小的，也可以是可扩展的。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>线程共享，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>方法区常被称作“永久代”，其实“永久代”只是实现方法区的一种方式，有许多类型的虚拟机就不使用“永久代”的方式实现方法区，因此二者不能等同。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>方法区的一部分，存放 Class 文件中的常量池表中的信息，具备动态性，即运行期间也可以添加新的常量进入常量池中，如 String 类的 intern 方法。</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>不属于虚拟机运行时数据区，也不是《Java 虚拟机规范》中定义的内存区域。</p>
<p>可以作为 Java 虚拟机运行时对数据交换的补充，即利用这部分空间进行异步操作，提高性能。</p>
<hr>
<h4 id="1-2-HotSpot-虚拟机对象探秘"><a href="#1-2-HotSpot-虚拟机对象探秘" class="headerlink" title="1.2 HotSpot 虚拟机对象探秘"></a>1.2 HotSpot 虚拟机对象探秘</h4><h5 id="1-2-1-对象的创建"><a href="#1-2-1-对象的创建" class="headerlink" title="1.2.1 对象的创建"></a>1.2.1 对象的创建</h5><p>在语言层面上，创建对象通常仅仅是一个 new 关键字而已，但虚拟机是如何处理创建对象的过程呢？</p>
<p>当 JVM 遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则必须先执行相应的类加载过程。类加载检查通过后，便是类加载，待其完成后其所需内存空间大小便可完全确定，并在堆中为其分配内存。</p>
<p>内存分配是一个很很频繁的操作，在并发情况下不是线程安全的，可能会出现多个线程争用同一部分内存空间。</p>
<p>解决方法：一种是对分配内存空间的操作进行同步操作–采用 CAS 配上失败重试的方式保证操作的原子性；一种是为每个线程预先分配一小块内存，称为本地线程分配缓冲（TLAB），然后线程在缓存区内分配内存，只有当本地缓存区用完了，分配新的缓冲区时才需要同步锁定。</p>
<p>上述步骤完成后，JVM 还需要对对象进行必要的设置，比如类的元信息、对象的哈希码等，这些存储在对象的对象头中。</p>
<p>最后，一个新的对象便产生了，但其时还未进行初始化操作（init）。只有执行完初始化操作后，一个真正可用的对象才算被完全构造出来。</p>
<h5 id="1-2-2-对象的内存布局"><a href="#1-2-2-对象的内存布局" class="headerlink" title="1.2.2 对象的内存布局"></a>1.2.2 对象的内存布局</h5><p>存储布局：</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<h6 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h6><p>对象头部分包括两类信息。</p>
<p>“Mark Word”：存储对象自身的运行时数据。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230615150711.png"></p>
<p>另一部分是类型指针，即对象指向它的类型元数据的指针，通过该指针来确定该对象是哪个类的实例。</p>
<h6 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h6><p>对象真正存储的有效信息，即在程序代码中定义的各种类型的字段内容。</p>
<h6 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h6><p>并非必然存在，仅起到占位符作用。</p>
<h5 id="1-2-3-对象的访问定位"><a href="#1-2-3-对象的访问定位" class="headerlink" title="1.2.3 对象的访问定位"></a>1.2.3 对象的访问定位</h5><p>Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。</p>
<p>对象访问的两种方式：</p>
<ul>
<li>句柄访问：堆中划分一块内存作为句柄池，reference存储的就是对象的句柄地址。</li>
<li>直接指针访问：reference存储的就是对象地址</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230615151729.png"></p>
<p>句柄访问的优点是在对象被移动是只需要改变句柄指针，而无需改变reference；直接指针访问的优点是速度更快，节省了一次间接访问的开销。</p>
<hr>
<h3 id="2-垃圾收集器与内存分配策略"><a href="#2-垃圾收集器与内存分配策略" class="headerlink" title="2. 垃圾收集器与内存分配策略"></a>2. 垃圾收集器与内存分配策略</h3><h4 id="2-1-对象已死？"><a href="#2-1-对象已死？" class="headerlink" title="2.1 对象已死？"></a>2.1 对象已死？</h4><p>垃圾收集器在对对象实例进行回收前，需要判断对象是否“存活”。</p>
<h5 id="2-1-1-引用计数算法"><a href="#2-1-1-引用计数算法" class="headerlink" title="2.1.1 引用计数算法"></a>2.1.1 引用计数算法</h5><p>算法核心：对每个对象维护一个引用计数器，每当有一个地方引用它时，计数器值加一：当引用失效时，计数器值减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>Java 并不采用该算法来管理内存，因为它很难解决循环引用等问题。</p>
<h5 id="2-1-2-可达性分析算法"><a href="#2-1-2-可达性分析算法" class="headerlink" title="2.1.2 可达性分析算法"></a>2.1.2 可达性分析算法</h5><p>当前主流商用程序语言都是通过可达性分析算法来判定对象是否存活的。</p>
<p>算法核心：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索路径称为“引用链”，如果某个对象到GC Roots没有任何引用链相连，则证明此对象不可能再被使用。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230615153530.png"></p>
<h5 id="2-1-3-再谈引用"><a href="#2-1-3-再谈引用" class="headerlink" title="2.1.3 再谈引用"></a>2.1.3 再谈引用</h5><p>引用的分类：</p>
<ul>
<li>强引用：强引用关系若存在，垃圾收集器就永远不会回收被引用的对象。</li>
<li>软引用：描述一些还有用，但非必须的对象。在系统将要发生内存溢出前，会将软引用对象进行回收，若回收后，还没有足够内存，才会抛出异常。SoftReference 类可以实现软引用。</li>
<li>弱引用：与软引用类似，但强度更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，无论内存是否足够，都会被回收。WeakReference 类可实现弱引用。</li>
<li>虚引用：最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得对象实例。其唯一目的是在这个对象被回收时收到一个系统通知。PhantomReference 类可实现虚引用。</li>
</ul>
<h5 id="2-1-4-生存还是死亡？"><a href="#2-1-4-生存还是死亡？" class="headerlink" title="2.1.4 生存还是死亡？"></a>2.1.4 生存还是死亡？</h5><p>即使在算法中被判定为不可达，其仍有“存活”机会。</p>
<p>宣告一个对象死亡至少要经历两次标记过程，第一次即为算法判定。被标记后，会进行一次筛选，判断是否有必要执行对象的 finalize 方法，若该方法未被覆盖或已被执行过，则该对象即被宣告死亡；否则将其放入F-Queue队列中。</p>
<p>虚拟机会自动建立低调度优先级的Finalizer线程去执行F-Queue队列中对象的finalize方法，只要对象在finalize方法中能重新与引用链上的一个对象建立关联，它便会被移出“即将回收”的集合，即逃脱；否则基本就被宣告死亡了。</p>
<p>finalize方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序。官方已经不建议使用该方法了。</p>
<h5 id="2-1-5-回收方法区"><a href="#2-1-5-回收方法区" class="headerlink" title="2.1.5 回收方法区"></a>2.1.5 回收方法区</h5><p>方法区回收条件苛刻，其收集器实现难度很高。</p>
<p>主要回收两部分内容：</p>
<ul>
<li>废弃的常量：判断其是否还被引用即可</li>
<li>不再使用的类型：判断条件较为苛刻<ul>
<li>该类所有实例（即包括了其派生子类）已经被回收</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
</ul>
<h4 id="2-2-垃圾收集算法"><a href="#2-2-垃圾收集算法" class="headerlink" title="2.2 垃圾收集算法"></a>2.2 垃圾收集算法</h4><h5 id="2-2-1-分代收集理论"><a href="#2-2-1-分代收集理论" class="headerlink" title="2.2.1 分代收集理论"></a>2.2.1 分代收集理论</h5><p>分代假说：</p>
<ul>
<li>弱分代假说：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象越难以消亡</li>
</ul>
<p>这两个假说奠定了垃圾收集器的设计原则：收集器应将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储。</p>
<p>根据这两个假说，设计者将堆划分为了“新生代”和“老年代”两个部分。然而，这两个部分最终还是出现了问题–“跨代引用”，即新生代与老年代的相互引用，导致了垃圾收集时的性能负担。</p>
<ul>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数</li>
</ul>
<p>基于此假说，新生代上建立一个数据结构–“记忆集”，这个结构把老年代划分为若干小块，标识出老年代的哪一块会存在跨代引用，在Minor GC时，只有包含跨代引用的的对象才会在老年代中扫描判断是否回收，通过空间换取了时间开销。</p>
<p>GC分类：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230615162026.png"></p>
<h5 id="2-2-2-标记-清除算法"><a href="#2-2-2-标记-清除算法" class="headerlink" title="2.2.2 标记 - 清除算法"></a>2.2.2 标记 - 清除算法</h5><p>算法核心：标记所有需要回收&#x2F;存活的对象，标记完成后，统一回收被标记&#x2F;未被标记的对象。</p>
<p>两个缺点：</p>
<ul>
<li>执行效率不稳定</li>
<li>内存空间碎片化</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230615162406.png"></p>
<h5 id="2-2-3-标记-复制算法"><a href="#2-2-3-标记-复制算法" class="headerlink" title="2.2.3 标记 - 复制算法"></a>2.2.3 标记 - 复制算法</h5><p>算法核心：将内存容量划分为大小相等的两块，每次只使用其中一块，当本块使用完了，就将活着的对象复制到另一块上面，然后把本块一次清理掉。</p>
<p>优点：对于多数对象可回收的情况，无需标记大量对象，节省性能开销。</p>
<p>缺点：若多数对象存活，则需要复制大量对象，造成巨大开销；并且只能使用一半内存，造成空间浪费。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230615162936.png"></p>
<p>这种算法多用于回收新生代。</p>
<h5 id="2-2-4-标记-整理算法"><a href="#2-2-4-标记-整理算法" class="headerlink" title="2.2.4 标记 - 整理算法"></a>2.2.4 标记 - 整理算法</h5><p>针对老年代存活对象较多的情况，一般不采取“标记-复制算法”。</p>
<p>算法核心：标记过程通“标记-清除算法”，但后续步骤不是对可回收对象进行清理，而是将存活对象移到内存空间一端，然后直接清理掉边界以外的内存。</p>
<p>该算法是移动式的，而“标记-清除算法”是非移动式的。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230615163740.png"></p>
<h4 id="2-3-经典垃圾收集器"><a href="#2-3-经典垃圾收集器" class="headerlink" title="2.3 经典垃圾收集器"></a>2.3 经典垃圾收集器</h4><p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617093744.png"></p>
<h5 id="2-3-1-Serial-收集器"><a href="#2-3-1-Serial-收集器" class="headerlink" title="2.3.1 Serial 收集器"></a>2.3.1 Serial 收集器</h5><p>最基础、历史最悠久的垃圾收集器，曾经是新生代收集器的唯一选择。</p>
<p>特点：</p>
<ul>
<li>单线程：在使用一个处理器或一个线程进行垃圾收集</li>
<li>“Stop The World”：垃圾收集时，必须暂停其它所有工作线程，直到收集结束</li>
<li>额外内存消耗小</li>
<li>单线程收集效率高</li>
<li>多应用于客户端模式下的虚拟机</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617090849.png"></p>
<h5 id="2-3-2-ParNew-收集器"><a href="#2-3-2-ParNew-收集器" class="headerlink" title="2.3.2 ParNew 收集器"></a>2.3.2 ParNew 收集器</h5><p>实质上时Serial收集器的多线程并行版本，多应用于服务端模式下的虚拟机。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617091513.png"></p>
<h5 id="2-3-3-Parallel-Scavenge-收集器"><a href="#2-3-3-Parallel-Scavenge-收集器" class="headerlink" title="2.3.3 Parallel Scavenge 收集器"></a>2.3.3 Parallel Scavenge 收集器</h5><p>常被称作“吞吐量优先收集器”，其关注点是吞吐量，即用户代码时间与程序总时间的比值，CMS等收集器的关注点则是尽可能地缩短垃圾收集时用户线程的停顿时间。</p>
<p>与ParNew收集器的不同：</p>
<ul>
<li>关注吞吐量</li>
<li>自适应调节策略</li>
</ul>
<h5 id="2-3-4-Serial-Old-收集器"><a href="#2-3-4-Serial-Old-收集器" class="headerlink" title="2.3.4 Serial Old 收集器"></a>2.3.4 Serial Old 收集器</h5><p>Serial 收集器的老年代版本，特性同Serial收集器。</p>
<h5 id="2-3-5-Parallel-Old-收集器"><a href="#2-3-5-Parallel-Old-收集器" class="headerlink" title="2.3.5 Parallel Old 收集器"></a>2.3.5 Parallel Old 收集器</h5><p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617092246.png"></p>
<h5 id="2-3-6-CMS-收集器"><a href="#2-3-6-CMS-收集器" class="headerlink" title="2.3.6 CMS 收集器"></a>2.3.6 CMS 收集器</h5><p>CMS（Concurrent Mark Sweep）收集器，也被称作“并发低停顿收集器”，是一种以获取最短回收停顿时间为目标的收集器。</p>
<p>运作过程：</p>
<ul>
<li>初始标记：标记GC Roots能直接关联到的对象，速度快，需要“Stop The World”</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历对象图，耗时较长，但无需停顿用户线程，可以与垃圾收集线程并发运行</li>
<li>重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间长于初始标记，短于并发标记，需要“Stop The World”</li>
<li>并发清除：清理标记阶段判断已经死亡的对象，可以与用户线程同时并发</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617092246.png"></p>
<h5 id="2-3-7-Garbage-First-收集器"><a href="#2-3-7-Garbage-First-收集器" class="headerlink" title="2.3.7 Garbage First 收集器"></a>2.3.7 Garbage First 收集器</h5><p>简称G1，“全功能收集器”，面向局部收集的设计思路和基于Region的内存布局形式。</p>
<p>Mixed GC模式：目标范围不再是新生代、老生代或整堆，堆内存中的任何部分均可组成回收集（CSet）。</p>
<p>G1将Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或老年代空间。</p>
<p>Region中还有一类特殊的Humongous区域，用来存储大对象，G1认为只要对象大小超过了一个Region容量一半的对象即可判定为大对象。</p>
<p>G1以Region作为单次回收的最小单元，并跟踪各个Region里面的垃圾堆积的“价值”大小，维护一个优先队列，每次回收价值最大的那些Region。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617095145.png"></p>
<p>工作流程：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617095508.png"></p>
<h4 id="2-4-低延迟垃圾收集器"><a href="#2-4-低延迟垃圾收集器" class="headerlink" title="2.4 低延迟垃圾收集器"></a>2.4 低延迟垃圾收集器</h4><p>衡量垃圾收集器的三项重要指标：</p>
<ul>
<li>内存占用</li>
<li>吞吐量</li>
<li>延迟</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617100306.png"></p>
<h5 id="2-4-1-Shenandoah-收集器"><a href="#2-4-1-Shenandoah-收集器" class="headerlink" title="2.4.1 Shenandoah 收集器"></a>2.4.1 Shenandoah 收集器</h5><p>与G1的不同：</p>
<ul>
<li>G1的回收阶段可以多线程并行，却无法与用户线程并发，而Shenandoah可以做到两者兼顾</li>
<li>Shenandoah默认不采用分代收集</li>
<li>摒弃G1中的记忆集，使用连接矩阵来记录跨Region的引用关系</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617100908.png"></p>
<p>九个阶段：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>并发清理：用于清理一个存活对象都没有的Region</li>
<li>并发回收：将存活对象复制到其它未被使用的Region中</li>
<li>初始引用更新：将所有指向旧对象的引用修正到复制后的新地址，这个操作就是引用更新。初始化阶段其实就是设置一个线程集合点，时间很短。</li>
<li>并发引用更新：真正开始进行引用更新操作</li>
<li>最终引用更新：修正GC Roots中的引用</li>
<li>并发清理：回收集中所有Region都没有对象存活，再调用一次并发清理回收内存空间</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230617101930.png"></p>
<h5 id="2-4-2-ZGC-收集器"><a href="#2-4-2-ZGC-收集器" class="headerlink" title="2.4.2 ZGC 收集器"></a>2.4.2 ZGC 收集器</h5><p>与G1、Shenandoah的Region不同的是，ZGC的Region具有动态性–动态创建和销毁。x64平台下，可以支持大、中、小三类容量。</p>
<p>运作过程：</p>
<ul>
<li>并发标记</li>
<li>并发预备重分配</li>
<li>并发重分配</li>
<li>并发重映射</li>
</ul>
<hr>
<h3 id="3-虚拟机性能监控、故障处理工具"><a href="#3-虚拟机性能监控、故障处理工具" class="headerlink" title="3. 虚拟机性能监控、故障处理工具"></a>3. 虚拟机性能监控、故障处理工具</h3><h4 id="3-1-基础故障处理工具"><a href="#3-1-基础故障处理工具" class="headerlink" title="3.1 基础故障处理工具"></a>3.1 基础故障处理工具</h4><h5 id="3-1-1-jps：虚拟机进程状况工具"><a href="#3-1-1-jps：虚拟机进程状况工具" class="headerlink" title="3.1.1 jps：虚拟机进程状况工具"></a>3.1.1 jps：虚拟机进程状况工具</h5><p>列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure>

<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620090840.png"></p>
<h5 id="3-1-2-jstat：虚拟机统计信息监视工具"><a href="#3-1-2-jstat：虚拟机统计信息监视工具" class="headerlink" title="3.1.2 jstat：虚拟机统计信息监视工具"></a>3.1.2 jstat：虚拟机统计信息监视工具</h5><p>监视虚拟机各种运行状态信息的命令行工具。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstat [ option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure>

<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620091109.png"></p>
<h5 id="3-1-3-jinfo-Java-配置信息工具"><a href="#3-1-3-jinfo-Java-配置信息工具" class="headerlink" title="3.1.3 jinfo: Java 配置信息工具"></a>3.1.3 jinfo: Java 配置信息工具</h5><p>实时查看和调整虚拟机各项参数。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jinfo [ option ] pid</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-jmap：Java-内存映像工具"><a href="#3-1-4-jmap：Java-内存映像工具" class="headerlink" title="3.1.4 jmap：Java 内存映像工具"></a>3.1.4 jmap：Java 内存映像工具</h5><p>用于生成堆转储快照。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmap [ option ] vmid</span><br></pre></td></tr></table></figure>

<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620091403.png"></p>
<p><strong>jhat</strong>：虚拟机堆转储分析工具，配套jmap使用。</p>
<h5 id="3-1-5-jstack：Java-堆栈跟踪工具"><a href="#3-1-5-jstack：Java-堆栈跟踪工具" class="headerlink" title="3.1.5 jstack：Java 堆栈跟踪工具"></a>3.1.5 jstack：Java 堆栈跟踪工具</h5><p>生成虚拟机当前时刻的线程快照。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstack [ option ] vmid</span><br></pre></td></tr></table></figure>

<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620091659.png"></p>
<h4 id="3-2-可视化故障处理工具"><a href="#3-2-可视化故障处理工具" class="headerlink" title="3.2 可视化故障处理工具"></a>3.2 可视化故障处理工具</h4><h5 id="3-2-1-JHSDB-基于服务性代理的调试工具"><a href="#3-2-1-JHSDB-基于服务性代理的调试工具" class="headerlink" title="3.2.1 JHSDB: 基于服务性代理的调试工具"></a>3.2.1 JHSDB: 基于服务性代理的调试工具</h5><p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620091939.png"></p>
<h5 id="3-2-2-JConsole：Java-监视与管理控制台"><a href="#3-2-2-JConsole：Java-监视与管理控制台" class="headerlink" title="3.2.2 JConsole：Java 监视与管理控制台"></a>3.2.2 JConsole：Java 监视与管理控制台</h5><h5 id="3-2-3-VisualVM：多合-故障处理工具"><a href="#3-2-3-VisualVM：多合-故障处理工具" class="headerlink" title="3.2.3 VisualVM：多合 - 故障处理工具"></a>3.2.3 VisualVM：多合 - 故障处理工具</h5><h5 id="3-2-4-Java-Mission-Control：可持续在线的监控工具"><a href="#3-2-4-Java-Mission-Control：可持续在线的监控工具" class="headerlink" title="3.2.4 Java Mission Control：可持续在线的监控工具"></a>3.2.4 Java Mission Control：可持续在线的监控工具</h5><hr>
<h2 id="二-虚拟机执行子系统"><a href="#二-虚拟机执行子系统" class="headerlink" title="二. 虚拟机执行子系统"></a>二. 虚拟机执行子系统</h2><h3 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1. 类文件结构"></a>1. 类文件结构</h3><p>Java 虚拟机的语言无关性</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620093334.png"></p>
<h4 id="1-1-Class-类文件的结构"><a href="#1-1-Class-类文件的结构" class="headerlink" title="1.1 Class 类文件的结构"></a>1.1 Class 类文件的结构</h4><p>Class 文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构只包含两种数据类型：</p>
<ul>
<li>无符号数：基本数据类型</li>
<li>表：多个无符号数或其它表作为数据项构成的复合数据类型</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620093957.png"></p>
<h5 id="1-1-1-魔数与-Class-文件的版本"><a href="#1-1-1-魔数与-Class-文件的版本" class="headerlink" title="1.1.1 魔数与 Class 文件的版本"></a>1.1.1 魔数与 Class 文件的版本</h5><p>每个 Class 文件的头4个字节被称为魔数。它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。</p>
<p>魔数后的4个字节存储的是 Class ：5、6字节是次版本号，7、8是主版本号。</p>
<h5 id="1-1-2-常量池"><a href="#1-1-2-常量池" class="headerlink" title="1.1.2 常量池"></a>1.1.2 常量池</h5><p>主、次版本号后是常量池入口。</p>
<p>常量池是 Class 文件结构中与其他项目关联最多的数据，通常也是占用 Class 文件空间最大的数据项目之一，还是在 Class 文件中第一个出现的表类型数据项目。</p>
<p>常量池中常量的数量是不固定的，所以其入口处需要放置一项u2类型的数据，代表常量池容量计数值，其值从1开始。Class 文件中仅有常量池的容量计数从1开始。</p>
<p>主要存放两大类常量：</p>
<ul>
<li><p>字面量：如文本字符串、final修饰字段等</p>
</li>
<li><p>符号引用：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620095456.png"></p>
</li>
</ul>
<h5 id="1-1-3-访问标志"><a href="#1-1-3-访问标志" class="headerlink" title="1.1.3 访问标志"></a>1.1.3 访问标志</h5><p>常量池结束后紧接着的2个字节代表访问标志，用于识别一些类或接口层次的访问信息。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620095907.png"></p>
<h5 id="1-1-4-类索引、父类索引与接口索引集合"><a href="#1-1-4-类索引、父类索引与接口索引集合" class="headerlink" title="1.1.4 类索引、父类索引与接口索引集合"></a>1.1.4 类索引、父类索引与接口索引集合</h5><p>类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，由这三项数据来确定该类型的继承关系。</p>
<ul>
<li>类索引：确定该类的全限定名</li>
<li>父类索引：确定该类父类的全限定名</li>
<li>接口索引集合：实现的接口</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620100714.png"></p>
<h5 id="1-1-5-字段表集合"><a href="#1-1-5-字段表集合" class="headerlink" title="1.1.5 字段表集合"></a>1.1.5 字段表集合</h5><p>字段表用于描述接口或类中声明的变量。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620101057.png"></p>
<ul>
<li><p>access_flags:</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620102928.png"></p>
</li>
<li><p>name_index: 字段简单名称</p>
</li>
<li><p>descriptor_index: 字段和方法的描述符</p>
</li>
</ul>
<p>都是对常量池项的引用。</p>
<p><strong>描述符</strong></p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620101445.png"></p>
<p>对于数组类型，每一维度将使用一个前置的”[“，如一个定义为”java.lang.String[][]“类型的二维数组将被记录为”[[Ljava&#x2F;lang&#x2F;String;“，一个整型数组将被记录为”[I”。</p>
<p>描述方法时：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620102152.png"></p>
<p>字段表集合中不会列出从父类或者父接口中继承来的字段，但有可能出现代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。</p>
<h5 id="1-1-6-方法表集合"><a href="#1-1-6-方法表集合" class="headerlink" title="1.1.6 方法表集合"></a>1.1.6 方法表集合</h5><p>用于对方法的描述。</p>
<p>方法里的Java代码，经过javac编译器编译成字节码指令之后，存放在方法属性表中一个名为“Code”的属性里面。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620103010.png"></p>
<ul>
<li><p>access_flags:</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620103118.png"></p>
</li>
</ul>
<h5 id="1-1-7-属性表集合"><a href="#1-1-7-属性表集合" class="headerlink" title="1.1.7 属性表集合"></a>1.1.7 属性表集合</h5><p>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230620145041.png"></p>
<ol>
<li><p>Code 属性</p>
<p>存储 Java 程序方法体里面的代码经过编译后的字节码指令。</p>
<p>包含了异常表，负责处理try、finally等异常处理操作，非必须存在。</p>
</li>
<li><p>Exceptions 属性</p>
<p>与Code属性平级，与异常表不同。列举方法中可能抛出的受查异常，即throws关键字后面列举出的异常。</p>
</li>
<li><p>LineNumberTable 属性</p>
<p>描述 Java 源码行号和字节码行号之间的对应关系。</p>
<p>非运行时必需的属性，但默认会生成到Class文件中。若不生成，在进行调试时，无法按照源码行进行断点调试。</p>
</li>
<li><p>LocalVariable及LocalVariableTypeTable属性</p>
<p>LocalVariable属性用于描述栈帧中局部变量表的变量与 Java 源码中定义的变量之间的关系，非必需。</p>
</li>
<li><p>SourceFile及SourceDebugExtension</p>
<p>SourceFile属性用于记录生成这个Class文件的源码文件名称，可选。</p>
<p>SourceDebugExtension用于存储额外的代码调试信息。</p>
</li>
<li><p>ConstantValue属性</p>
<p>通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量才可以使用这项属性。</p>
</li>
<li><p>InnerClasses属性</p>
<p>记录内部类与宿主类之间的关联。</p>
</li>
<li><p>Deprecated及Synthetic属性</p>
<p>标志类型的布尔属性，只存在有和没有之分，没有属性值的概念。</p>
<p>Deprecated属性用于表示某个类、字段或者方法，已不再被推荐使用。</p>
<p>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。</p>
</li>
<li><p>StackMapTable属性</p>
<p>类型推导验证器。</p>
</li>
<li><p>Signature属性</p>
<p>若代码中包含了类型变量或参数化类型，则该属性会为它记录泛型签名信息。</p>
<p>Java 语言的泛型采用的是擦除法实现的伪泛型。</p>
</li>
<li><p>BootstrapMethods属性</p>
<p>保存invokedynamic指令引用的引导方法限定符。</p>
</li>
<li><p>MethodParameters属性</p>
<p>记录方法的各个形参名称和信息。</p>
</li>
<li><p>模块化属性</p>
<p>用于实现模块化功能。</p>
</li>
<li><p>运行时注解相关属性</p>
<p>RuntimeVisibleAnnotations变长属性记录类、字段或方法的声明上记录运行时可见注解，当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过该属性获取到的。</p>
</li>
</ol>
<hr>
<h3 id="2-虚拟机类加载机制"><a href="#2-虚拟机类加载机制" class="headerlink" title="2. 虚拟机类加载机制"></a>2. 虚拟机类加载机制</h3><p>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称为虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，为 Java 应用提供了极高的扩展性和灵活性。</p>
<h4 id="2-1-类加载的时机"><a href="#2-1-类加载的时机" class="headerlink" title="2.1 类加载的时机"></a>2.1 类加载的时机</h4><p>类的生命周期</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230621142052.png"></p>
<h4 id="2-2-类加载的过程"><a href="#2-2-类加载的过程" class="headerlink" title="2.2 类加载的过程"></a>2.2 类加载的过程</h4><h5 id="2-2-1-加载"><a href="#2-2-1-加载" class="headerlink" title="2.2.1 加载"></a>2.2.1 加载</h5><p>加载阶段需要完成的事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>非数组类的加载：</p>
<ul>
<li>可通过虚拟机里内置的引导类加载器</li>
<li>用户自定义的类加载器</li>
</ul>
<p>数组类的加载：</p>
<p>本身不通过类加载器创建，而是由虚拟机在内存中动态构造的。但数组类的元素类型（数组去掉所有维度的类型）还是需要类加载器完成加载。</p>
<p>一个数组类（C）的创建过程遵循的规则：</p>
<ul>
<li><p>如果数组的组件类型（数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。</p>
</li>
<li><p>如果数组的组件类型不是引用类型，虚拟机会把数组C标记为与引导类加载器关联。</p>
</li>
<li><p>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为 public，可被所有的类和接口访问到。</p>
</li>
</ul>
<p>加载阶段结束后，会在堆内存中实例化一个 java.lang.Class 类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>
<h5 id="2-2-2-验证"><a href="#2-2-2-验证" class="headerlink" title="2.2.2 验证"></a>2.2.2 验证</h5><p>这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证四阶段：</p>
<ol>
<li><p>文件格式验证</p>
<p>验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<p>该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。</p>
<p>只有通过该阶段，这段字节流才被允许进入方法区存储，后面的三个阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流。</p>
</li>
<li><p>元数据验证</p>
<p>对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 虚拟机规范》的要求。</p>
<p>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java 虚拟机规范》定义相悖的元数据信息。</p>
</li>
<li><p>字节码验证</p>
<p>最复杂的阶段，通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p>主要对类的方法体（即Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p>
<p>即使通过了字节码验证，也无法确认程序是否能在有限的时间内结束运行–“停机问题”。</p>
</li>
<li><p>符号引用验证</p>
<p>本阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段–解析阶段中发生。</p>
<p>失败抛出java.lang.IncompatibleClassChangeError。</p>
<p>主要校验该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p>主要目的是确保解析行为能正常执行。</p>
</li>
</ol>
<p>验证阶段并非必要执行的，若代码已经被反复使用和验证过没有问题，也可以关闭验证措施，缩短虚拟机类加载的时间。</p>
<h5 id="2-2-3-准备"><a href="#2-2-3-准备" class="headerlink" title="2.2.3 准备"></a>2.2.3 准备</h5><p>正式为类中定义的变量（静态变量，static修饰）分配内存并设置类变量初始值的阶段。</p>
<p>JDK7及之前，HotSpot使用永久代实现方法区时，这些变量所使用的内存即在方法区；JDK8 及以后，类变量则会随着 Class 对象一起存放在堆中。</p>
<p>本阶段进行内存分配的仅包括类变量，不包括实例变量。</p>
<p>通常情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>变量 value 在准备阶段过后的初始值为0而不是123，因为尚未执行初始化方法。</p>
<p>若类字段的字段属性表中存在ConstantValue属性，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>编译时将会为value生成ConstantValue属性，本阶段value即被赋值为123。</p>
<h5 id="2-2-4-解析"><a href="#2-2-4-解析" class="headerlink" title="2.2.4 解析"></a>2.2.4 解析</h5><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ol>
<li><p>类或接口的解析</p>
<p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，将会有以下三个规则：</p>
<ul>
<li>如果C不是一个数组类型，虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C，若有异常，则失败。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，那将会按照规则1加载数组元素类型，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li>
<li>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限，若无，则抛出IllegalAccessError。</li>
</ul>
</li>
<li><p>字段解析</p>
<p>首先对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用，若该步解析完成，假设所属的类或接口为C，遵循以下4个步骤：</p>
<ul>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，则会按照继承关系从下往上递归搜索各个接口和它的父接口如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object，则会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFieldError。</li>
</ul>
<p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，若失败，抛出IllegalAccessError。</p>
</li>
<li><p>方法解析</p>
<p>即类的方法解析，第一个步骤同字段解析，先解析方法表的class_index项中索引的方法所属的类或接口的符号引用，仍用C表示该类，后续步骤：</p>
<ul>
<li>Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果C是接口的话，抛出IncompatibleClassChangeError异常。</li>
<li>若通过第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，若有则返回直接引用，查找结束。</li>
<li>否则，在类C的父类中进行递归查找是否有简单名称和描述符都与目标相匹配的方法，若有则返回直接引用，查找结束。</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，若有，说明类C是一个抽象类，查找结束，抛出AbstractMethod异常。</li>
<li>否则，宣告失败，抛出NoSuchMethodError。</li>
</ul>
<p>最后，若成功查找到，还需要进行权限验证。</p>
</li>
<li><p>接口方法解析</p>
<p>步骤一同方法解析，设接口为C，后续步骤：</p>
<ul>
<li>如果C是类的话，抛出IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，若有则返回直接引用，查找结束。</li>
<li>否则，在接口C的父接口中查找，做到java.lang.Object类为止（包括Object），若有简单名称和描述符都与目标相匹配的方法，若有则返回直接引用，查找结束。</li>
<li>对于规则3，若C的不同父接口中存有多个匹配的方法，则返回其中一个并结束查找。</li>
<li>否则，宣告失败，抛出NoSuchMethodError。</li>
</ul>
</li>
</ol>
<h5 id="2-2-5-初始化"><a href="#2-2-5-初始化" class="headerlink" title="2.2.5 初始化"></a>2.2.5 初始化</h5><p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()方法并不是在代码中直接编写的代码，而是javac编译器的自动生成物：</p>
<ul>
<li>由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，收集顺序是由语句在源文件中出现的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</li>
<li>与类的构造函数不同，无需显示调用父类构造器虚拟机会保证在子类<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。</li>
<li>对于类或接口来说不是必需的，若一个类中没有静态语句块，也没有对变量的赋值操作，那么可以不生成该方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因而会生成该方法。但与类不同的是，它无需先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外接口的实现类在初始化时，也一样不会执行接口的<clinit>()方法。</li>
<li>虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<clinit>()方法，其它线程都需要阻塞等待，直到活动线程执行完<clinit>()方法。</li>
</ul>
<h4 id="2-3-类加载器"><a href="#2-3-类加载器" class="headerlink" title="2.3 类加载器"></a>2.3 类加载器</h4><p>通过一个类的全限定名来获取描述该类的二进制字节流时在虚拟机外部顺序的，实现这个动作的代码成为“类加载器”。</p>
<h5 id="2-3-1-类与类加载器"><a href="#2-3-1-类与类加载器" class="headerlink" title="2.3.1 类与类加载器"></a>2.3.1 类与类加载器</h5><p>对于任意一个类，都必须由加载它的类加载器和该类本身共同确立在虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。</p>
<p>比较两个类是否“相等”，即使两个类来源于同一个Class文件，若类加载器不同，这两个类也不相同。</p>
<h5 id="2-3-2-双亲委派模型"><a href="#2-3-2-双亲委派模型" class="headerlink" title="2.3.2 双亲委派模型"></a>2.3.2 双亲委派模型</h5><p>从虚拟机的角度看，存在两种不同的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：由C++&#x2F;Java实现，虚拟机的一部分</li>
<li>其他类的类加载器：Java实现，独立于虚拟机外部，全部继承抽象类java.lang.ClassLoader</li>
</ul>
<p>从Java开发人员的角度看，JDK 8 及之前版本的Java，三层类加载器：</p>
<ul>
<li><p>启动类加载器</p>
<p>加载<JAVA_HOME>\lib目录下能够被虚拟机识别的类库。</p>
<p>该加载器无法被Java程序直接引用，若需要使用该类加载器，只需在自定义类加载器时用null代替即可。</p>
</li>
<li><p>扩展类加载器</p>
<p>加载<JAVA_HOME>\lib\ext目录下的类库，是类库的扩展机制，可以直接在程序中使用。</p>
</li>
<li><p>应用程序类加载器</p>
<p>也被称为“系统类加载器”，ClassLoader.getSystemClassLoader()方法的默认返回值。</p>
<p>用于加载用户类路径上所有的类库，可以在程序中直接使用。</p>
</li>
</ul>
<p>双亲委派模型</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230622084732.png"></p>
<p>模型的工作过程：</p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把该请求委派给父类，以此类推，最终到达启动类加载器，只有当父类加载器反馈自己无法处理该请求时，子加载器才会尝试自己完成加载。</p>
<p>这能够保证如Object类最终都是由启动类加载器加载的，保证了Object的唯一性，否则每个类的Object都不同，程序将会一片混乱。</p>
<h5 id="2-3-3-破坏双亲委派模型"><a href="#2-3-3-破坏双亲委派模型" class="headerlink" title="2.3.3 破坏双亲委派模型"></a>2.3.3 破坏双亲委派模型</h5><p>三次破坏：</p>
<ul>
<li><p>JDK1.2 以前，模型尚未出现，而类加载器已经存在，增添了一个新的protected方法findClass()。</p>
</li>
<li><p>模型自身缺陷，越基础的类由越上层的类加载器加载，若基础类要调回下层类应用怎么办？</p>
<p>引入线程上下文类加载器（Thread Context ClassLoader），可以通过Thread.setContextClassLoader()方法设置，若创建线程时未设置，则从父线程继承一个，若全局范围内都没有设置，则默认是应用程序类加载器。</p>
<p>基础类可以通过该类加载器加载子类，解决上述问题。</p>
</li>
<li><p>对程序动态性的追求如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</p>
</li>
</ul>
<h4 id="2-4-Java-模块化系统"><a href="#2-4-Java-模块化系统" class="headerlink" title="2.4 Java 模块化系统"></a>2.4 Java 模块化系统</h4><p>模块化的关键目标–可配置的封装隔离机制。</p>
<h5 id="2-4-1-模块的兼容性"><a href="#2-4-1-模块的兼容性" class="headerlink" title="2.4.1 模块的兼容性"></a>2.4.1 模块的兼容性</h5><p>访问规则：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230622091301.png"></p>
<h5 id="2-4-2-模块化下的类加载器"><a href="#2-4-2-模块化下的类加载器" class="headerlink" title="2.4.2 模块化下的类加载器"></a>2.4.2 模块化下的类加载器</h5><p>扩展类加载器被平台类加载器取代。</p>
<p>类加载器结构变化</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230622092009.png"></p>
<hr>
<h3 id="3-虚拟机字节码执行引擎"><a href="#3-虚拟机字节码执行引擎" class="headerlink" title="3. 虚拟机字节码执行引擎"></a>3. 虚拟机字节码执行引擎</h3><h4 id="3-1-运行时栈帧结构"><a href="#3-1-运行时栈帧结构" class="headerlink" title="3.1 运行时栈帧结构"></a>3.1 运行时栈帧结构</h4><p>Java 虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）是用于支持虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<p>栈帧包括局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。</p>
<p>对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，被称为“当前栈帧”，该栈帧所关联的方法被称作“当前方法”，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<h5 id="3-1-1-局部变量表"><a href="#3-1-1-局部变量表" class="headerlink" title="3.1.1 局部变量表"></a>3.1.1 局部变量表</h5><p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件后，就在方法的Code属性中的max_locals数据项确定了该方法所需分配的局部变量表的最大容量。</p>
<p>局部变量表的容量以变量槽为最小单位，变量槽占用的内存空间因不同虚拟机的实现而异。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230622204547.png"></p>
<p>Java 虚拟机通过索引定位的方式使用局部变量表，索引从0开始。</p>
<p>当一个方法被调用时，虚拟机使用局部变量表来完成实参到形参的传递。如果执行的是实例方法，那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列。参数表分配完毕后，再按照方法体内部定义的变量顺序和作用域分配变量槽。</p>
<p>变量槽可重用。</p>
<h5 id="3-1-2-操作数栈"><a href="#3-1-2-操作数栈" class="headerlink" title="3.1.2 操作数栈"></a>3.1.2 操作数栈</h5><p>常被称作操作栈，其最大深度由Code属性中的max_stacks数据项确定。</p>
<p>32位数据类型所占用的栈容量为1，64位数据类型所占用的栈容量为2。</p>
<p>Java 虚拟机的解释执行引擎被称为“基于栈的执行引擎”，“栈”就是操作数栈。</p>
<p>栈帧之间的数据共享：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230622210921.png"></p>
<h5 id="3-1-3-动态连接"><a href="#3-1-3-动态连接" class="headerlink" title="3.1.3 动态连接"></a>3.1.3 动态连接</h5><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>
<p>静态解析：符号引用在类加载阶段或者第一次使用的时候就被转化为直接引用。</p>
<p>动态连接：符号引用在运行期才被转化为直接引用。</p>
<h5 id="3-1-4-方法返回地址"><a href="#3-1-4-方法返回地址" class="headerlink" title="3.1.4 方法返回地址"></a>3.1.4 方法返回地址</h5><p>当一个方法开始执行后，只有两种方式退出该方法：</p>
<ul>
<li><p>正常调用完成</p>
<p>执行引擎遇到方法返回的字节码指令，根据返回指令返回</p>
</li>
<li><p>异常调用完成</p>
<p>方法执行过程中遇到了异常，且该异常在方法体内没有得到妥善处理。</p>
<p>在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。</p>
</li>
</ul>
<h5 id="3-1-5-附加信息"><a href="#3-1-5-附加信息" class="headerlink" title="3.1.5 附加信息"></a>3.1.5 附加信息</h5><h4 id="3-2-方法调用"><a href="#3-2-方法调用" class="headerlink" title="3.2 方法调用"></a>3.2 方法调用</h4><p>方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还未涉及方法内部的具体运行过程。</p>
<p>两种形式：</p>
<ul>
<li>解析调用</li>
<li>分派调用</li>
</ul>
<h5 id="3-2-1-解析"><a href="#3-2-1-解析" class="headerlink" title="3.2.1 解析"></a>3.2.1 解析</h5><p>所有方法调用的目标方法在Class文件中都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，前提是：方法在程序真正运行前就有一个可确定的调用版本，且这个方法的调用版本在运行期是不可改变的。这类方法调用称为解析。</p>
<p>Java中符合“编译期可知，运行期不变”的方法主要有两类：</p>
<ul>
<li>静态方法：与类型直接关联</li>
<li>私有方法：在外部不可被访问</li>
</ul>
<p>这两类方法各自的特点决定了它们都不可能通过继承或别的方式重写出其它版本，因此适合在类加载阶段解析。</p>
<p>虚拟机支持的字节码指令：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230622213401.png"></p>
<p>只要能被invokestatic和invokespecial指令调用的方法，都可以在类加载阶段确定唯一的调用版本。在Java语言中符合这个条件的方法有静态方法、私有方法、实例构造器、父类方法，再加上final修饰的方法（使用invokevirtual指令）。这5种方法再类加载是就可以转化为直接引用，统称为“非虚方法”，其他方法被称为“虚方法”。</p>
<h5 id="3-2-2-分派"><a href="#3-2-2-分派" class="headerlink" title="3.2.2 分派"></a>3.2.2 分派</h5><h6 id="1-静态分派"><a href="#1-静态分派" class="headerlink" title="1. 静态分派"></a>1. 静态分派</h6><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br></pre></td></tr></table></figure>

<p>“Human”称为变量的“静态类型”，或者叫“外观类型”，后面的”Man“称为”实际类型“或者”运行时类型“。</p>
<p>静态类型的变化仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译时并不知道一个对象的实际类型是什么。</p>
<p>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。典型应用就是方法重载。</p>
<h6 id="2-动态分派"><a href="#2-动态分派" class="headerlink" title="2. 动态分派"></a>2. 动态分派</h6><p>典型应用：方法重写。</p>
<p>本质是invokevirtual指令：</p>
<ul>
<li>确定操作数栈顶的第一个元素所指向的对象的实际类型，记作C</li>
<li>寻找C中相匹配的方法，并进行权限校验，通过则返回直接引用</li>
<li>否则，按照继承关系查找</li>
<li>若未找到，抛出AbstractMethodError。</li>
</ul>
<p>这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>
<p>字段不参与多态。</p>
<h6 id="3-单分派与多分派"><a href="#3-单分派与多分派" class="headerlink" title="3. 单分派与多分派"></a>3. 单分派与多分派</h6><p>方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。</p>
<p>Java 语言中的静态分派（接收者与方法参数共同决定）属于多分派，动态分派（仅由接收者决定）属于单分派。</p>
<h6 id="4-虚拟机动态分派的实现"><a href="#4-虚拟机动态分派的实现" class="headerlink" title="4. 虚拟机动态分派的实现"></a>4. 虚拟机动态分派的实现</h6><p>动态分派执行非常频繁，而且在其版本选择过程中需要搜索合适的目标方法，消耗性能。基于执行性能考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。</p>
<p>优化手段：为类型在方法区建立一个虚方法表，与此对应，在invokeinterface执行时也会用到接口方法表，使用虚方法表索引代替元数据查找以提高性能。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230623094940.png"></p>
<p>虚方法表一般在类加载的连接阶段进行初始化，在准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕。</p>
<h4 id="3-3-动态类型语言支持"><a href="#3-3-动态类型语言支持" class="headerlink" title="3.3 动态类型语言支持"></a>3.3 动态类型语言支持</h4><p>实现动态类型语言–invokedynamic。</p>
<h5 id="3-3-1-动态类型语言"><a href="#3-3-1-动态类型语言" class="headerlink" title="3.3.1 动态类型语言"></a>3.3.1 动态类型语言</h5><ul>
<li>动态类型语言：较为灵活，开发效率提高，类型检查的主体过程在运行期进行，如Python、JavaScript、Lua、PHP。</li>
<li>静态类型语言：编译器可以提供全面严谨的类型检查，这样与数据类型有关的潜在问题在编码时就能及时发现，利于稳定性及让项目达到更大规模，类型检查的主体过程在编译期进行，如C、C++、Java。</li>
</ul>
<h5 id="3-3-2-java-lang-invoke-包"><a href="#3-3-2-java-lang-invoke-包" class="headerlink" title="3.3.2 java.lang.invoke 包"></a>3.3.2 java.lang.invoke 包</h5><p>提供了一种新的动态确定目标方法的机制，称为”方法句柄“（Method Handle）。</p>
<p>方法句柄与反射的不同：</p>
<ul>
<li>本质都是模拟方法调用，但是Reflection模拟的是Java代码层次，而MethodHandle模拟的是字节码层次。</li>
<li>Reflection中的java.lang.reflect.Method包含的信息更多，Reflection重量级，MethdoHandle轻量级。</li>
<li>虚拟机对字节码指令做的优化，理论上对MethodHandle也可行，而反射则不行。</li>
<li>Reflection设计目标是为了Java服务的，而MethodHandle则设计为虚拟机上的语言服务。</li>
</ul>
<h5 id="3-3-3-invokedynamic-指令"><a href="#3-3-3-invokedynamic-指令" class="headerlink" title="3.3.3 invokedynamic 指令"></a>3.3.3 invokedynamic 指令</h5><p>每一处含有invokedynamic指令的位置都被称作”动态调用点“，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是CONSTANT_InvokeDynamic_info常量，从该常量可以得到3项信息：引导方法、方法类型和名称。</p>
<p>引导方法有固定参数，并且返回值是java.lang.invoke.CallSite对象，这个对象代表了真正要执行的目标方法调用。</p>
<h4 id="3-4-基于栈的字节码解释执行引擎"><a href="#3-4-基于栈的字节码解释执行引擎" class="headerlink" title="3.4 基于栈的字节码解释执行引擎"></a>3.4 基于栈的字节码解释执行引擎</h4><p>执行程序的两种方式：</p>
<ul>
<li>解释执行（通过解释器执行）</li>
<li>编译执行（通过即时编译器产生本地代码执行）</li>
</ul>
<h5 id="3-4-1-解释执行"><a href="#3-4-1-解释执行" class="headerlink" title="3.4.1 解释执行"></a>3.4.1 解释执行</h5><p>编译过程</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230624092103.png"></p>
<h5 id="3-4-2-指令集"><a href="#3-4-2-指令集" class="headerlink" title="3.4.2 指令集"></a>3.4.2 指令集</h5><ul>
<li>基于栈的指令集：可移植，编译器实现更加简单，执行速度相对稍慢。</li>
<li>基于寄存器的指令集</li>
</ul>
<hr>
<h2 id="三-程序编译与代码优化"><a href="#三-程序编译与代码优化" class="headerlink" title="三. 程序编译与代码优化"></a>三. 程序编译与代码优化</h2><h3 id="1-前端编译与优化"><a href="#1-前端编译与优化" class="headerlink" title="1. 前端编译与优化"></a>1. 前端编译与优化</h3><p>编译器：</p>
<ul>
<li><p>前端编译器：把*.java转化为*.class文件</p>
</li>
<li><p>即时编译器（JIT）：运行期执行，字节码转化为本地机器码</p>
</li>
<li><p>提前编译器（AOT）：直接把程序编译成与目标机器指令集相关的二进制代码的过程</p>
</li>
</ul>
<h4 id="1-1-Javac-编译器"><a href="#1-1-Javac-编译器" class="headerlink" title="1.1 Javac 编译器"></a>1.1 Javac 编译器</h4><h5 id="1-1-1-Javac-的源码与调试"><a href="#1-1-1-Javac-的源码与调试" class="headerlink" title="1.1.1 Javac 的源码与调试"></a>1.1.1 Javac 的源码与调试</h5><p>编译过程：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230624092103.png"></p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230624095623.png"></p>
<h5 id="1-1-2-解析与填充符号表"><a href="#1-1-2-解析与填充符号表" class="headerlink" title="1.1.2 解析与填充符号表"></a>1.1.2 解析与填充符号表</h5><h6 id="1-词法、语法分析"><a href="#1-词法、语法分析" class="headerlink" title="1. 词法、语法分析"></a>1. 词法、语法分析</h6><p>词法分析：将源代码的字符流转变为标记集合的过程，标记是编译时的最小元素。</p>
<p>语法分析：根据标记序列构造抽象语法树（AST）的过程。</p>
<p>生成语法树后，编译器就不会再对源码字符流进行操作，后续操作都建立在抽象语法树上。</p>
<h6 id="2-填充符号表"><a href="#2-填充符号表" class="headerlink" title="2. 填充符号表"></a>2. 填充符号表</h6><p>符号表是一组符号地址和符号信息构成的数据结构。</p>
<h5 id="1-1-3-注解处理器"><a href="#1-1-3-注解处理器" class="headerlink" title="1.1.3 注解处理器"></a>1.1.3 注解处理器</h5><p>通过注解处理器对抽象语法树进行进一步修改。</p>
<h5 id="1-1-4-语义分析与字节码生成"><a href="#1-1-4-语义分析与字节码生成" class="headerlink" title="1.1.4 语义分析与字节码生成"></a>1.1.4 语义分析与字节码生成</h5><h6 id="1-标注检查"><a href="#1-标注检查" class="headerlink" title="1. 标注检查"></a>1. 标注检查</h6><p>检查变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。</p>
<p>检查过程还会顺便进行常量折叠的代码优化，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>抽象语法树上仍能看到“1”、“2”和“+”，但会标注“3”，这样就减少了运行期的工作量。</p>
<h6 id="2-数据及控制流分析"><a href="#2-数据及控制流分析" class="headerlink" title="2. 数据及控制流分析"></a>2. 数据及控制流分析</h6><p>对程序上下文逻辑的进一步验证，检查局部变量在使用前是否有赋值、方法的每条路径是否有返回值等。</p>
<h6 id="3-解语法糖"><a href="#3-解语法糖" class="headerlink" title="3. 解语法糖"></a>3. 解语法糖</h6><p>将某些语法还原为原始的基础语法结构的过程称为解语法糖。</p>
<h6 id="4-字节码生成"><a href="#4-字节码生成" class="headerlink" title="4. 字节码生成"></a>4. 字节码生成</h6><p>将前面步骤生成的信息转化成字节码指令写到磁盘中，并进行少量的代码添加和转换工作，例如实例构造器<init>()方法和类构造器<clinit>()方法。</p>
<h4 id="1-2-语法糖"><a href="#1-2-语法糖" class="headerlink" title="1.2 语法糖"></a>1.2 语法糖</h4><h5 id="1-2-1-泛型"><a href="#1-2-1-泛型" class="headerlink" title="1.2.1 泛型"></a>1.2.1 泛型</h5><h6 id="1-Java-与-C-的泛型"><a href="#1-Java-与-C-的泛型" class="headerlink" title="1. Java 与 C# 的泛型"></a>1. Java 与 C# 的泛型</h6><p>Java 选择的泛型实现方式叫作“类型擦除式泛型”，即泛型只存在于源码中，在编译后生成的字节码文件中，全部泛型都被替换为原来的裸类型。</p>
<p>C#的泛型实现方式式“具现化式泛型”，即在任何时期都是切实存在的，有着独立的虚方法表和类型数据。</p>
<h6 id="2-泛型的历史背景"><a href="#2-泛型的历史背景" class="headerlink" title="2. 泛型的历史背景"></a>2. 泛型的历史背景</h6><p>两个选择：</p>
<ul>
<li>需要泛型化的类型，以前有的就保持不变，然后平行地加一套泛型化版本的新类型</li>
<li>直接把已有的类型泛型化，既让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版</li>
</ul>
<p>Java 起初尝试过第一个选择，但由于历史原因及流行程度等因素，最终确定第二个选择。</p>
<h6 id="3-类型擦除"><a href="#3-类型擦除" class="headerlink" title="3. 类型擦除"></a>3. 类型擦除</h6><p>裸类型：所有该类型泛型化实例的共同父类型。</p>
<p>实现裸类型的两种选择：</p>
<ul>
<li>由虚拟机自动地、真实地构造出ArrayList<Integer>这样的类型，并且自动实现从ArrayList<Integer>派生自ArrayList的继承关系来满足裸类型的定义。</li>
<li>直接在编译时把ArrayList<Integer>还原为ArrayList，只在元素访问、修改时自动插入一些强制类型转换和检查指令。</li>
</ul>
<p>显然，Java 采用了第二种方式。</p>
<p>擦除式泛型弊端：</p>
<ul>
<li>不支持原生类型，因为int、long等类型无法与Object强制转换</li>
<li>运行期无法获取到泛型类型信息，即无法得知参数化类型 T 究竟是什么类型</li>
</ul>
<p>擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息（Signature属性），这也是我们在编码时通过反射手段取得参数化类型的根本依据。</p>
<h5 id="1-2-2-自动装箱、拆箱与遍历循环"><a href="#1-2-2-自动装箱、拆箱与遍历循环" class="headerlink" title="1.2.2 自动装箱、拆箱与遍历循环"></a>1.2.2 自动装箱、拆箱与遍历循环</h5><p>常用语法糖编译后的变化：</p>
<ul>
<li><p>泛型：擦除</p>
</li>
<li><p>自动装箱：对应的包装方法，如Integer.valueOf()</p>
</li>
<li><p>自动拆箱：对应的还原方法，如Integer.intValue()</p>
</li>
<li><p>遍历循环（for-each）：还原成迭代器实现，因此要求被遍历的类实现Iterable接口</p>
</li>
<li><p>变长参数：封装成数组实现</p>
</li>
</ul>
<p>自动装箱的陷阱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">        System.out.println(e == f);</span><br><span class="line">        System.out.println(c == (a + b));</span><br><span class="line">        System.out.println(c.equals(a + b));</span><br><span class="line">        System.out.println(g == (a + b));</span><br><span class="line">        System.out.println(g.equals(a + b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Integer的缓存池[-128,127]。</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-3-条件编译"><a href="#1-2-3-条件编译" class="headerlink" title="1.2.3 条件编译"></a>1.2.3 条件编译</h5><p>C、C++使用预处理器指示符（#ifdef）完成条件编译。</p>
<p>Java 语言没有预处理器，进行条件编译的方法就是使用条件为常量的if或while语句。</p>
<p>这种条件编译方式必须遵循最基本的 Java 语法，只能写在方法体内部，因此它只能实现语句基本块（Block）级别的条件编译，而无法调整整个Java类的结构。</p>
<hr>
<h3 id="2-后端编译与优化"><a href="#2-后端编译与优化" class="headerlink" title="2. 后端编译与优化"></a>2. 后端编译与优化</h3><h4 id="2-1-即时编译器"><a href="#2-1-即时编译器" class="headerlink" title="2.1 即时编译器"></a>2.1 即时编译器</h4><p>Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”，为了提高其执行效率，在运行时，虚拟机会把这些代码编译成本地机器码，并尽可能地进行代码优化，运行时完成这个任务的后端编译器就称为即时编译器。</p>
<h5 id="2-1-1-解释器与编译器"><a href="#2-1-1-解释器与编译器" class="headerlink" title="2.1.1 解释器与编译器"></a>2.1.1 解释器与编译器</h5><p>解释器与编译器的交互：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230626092601.png"></p>
<p>分层编译模式：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230626093003.png"></p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230626093048.png"></p>
<h5 id="2-1-2-编译对象与触发条件"><a href="#2-1-2-编译对象与触发条件" class="headerlink" title="2.1.2 编译对象与触发条件"></a>2.1.2 编译对象与触发条件</h5><p>热点代码主要有两类：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<p>这两种情况编译的目标对象都是整个方法体，区别在于执行入口的不同，第二种情况在编译时会传入执行入口点字节码序号（BCI）。这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为“栈上替换”（OSR），即栈帧还在栈上，方法就被替换了。</p>
<p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“热点探测”。</p>
<p>两种判定方式：</p>
<ul>
<li><p>基于采样的热点探测</p>
<p>虚拟机周期性地检查各个线程的调用栈顶，若某个方法多次出现在栈顶，那么它即为“热点方法”。</p>
<ul>
<li>优点：实现简单高效，容易获取方法调用关系</li>
<li>缺点：精确度低，容易受到线程阻塞或别的外界因素影响</li>
</ul>
</li>
<li><p>基于计数器的热点探测</p>
<p>虚拟机为每个方法建立计数器，统计方法的执行次数，执行次数超过一定阈值就认为它是“热点方法”。</p>
<ul>
<li>优点：精确度高</li>
<li>缺点：实现较复杂，不能直接获取到方法的调用关系</li>
</ul>
</li>
</ul>
<p>HotSpot虚拟机使用第二种方式，为每个方法准备了两类计数器：方法调用计数器和回边计数器（在循环边界往回跳转），阈值一旦溢出，就触发即时编译。</p>
<h6 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h6><p>默认设置下，方法调用计数器统计的不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，若方法的调用次数仍然不足以即时编译，那么该方法的调用计数器就会减少一半，这个过程被称为方法调用计数器热度的衰减，而这段时间就被称为方法统计的半衰周期，进行热度衰减的动作是在虚拟机进行垃圾收集是顺带进行的。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230626095335.png"></p>
<h6 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h6><p>与方法调用计数器的区别：</p>
<ul>
<li>没有热度衰减过程，统计的是绝对次数</li>
<li>计数器溢出时，会将方法计数器的值也调整为溢出状态，这样下次再进入该方法时就会执行标准编译过程</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230626095921.png"></p>
<h5 id="2-1-3-编译过程"><a href="#2-1-3-编译过程" class="headerlink" title="2.1.3 编译过程"></a>2.1.3 编译过程</h5><h6 id="客户端编译器"><a href="#客户端编译器" class="headerlink" title="客户端编译器"></a>客户端编译器</h6><p>三段式：</p>
<ul>
<li><p>一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR）</p>
<p>HIR使用静态单分配（SSA）形式来表示代码值，在此之前，编译器已经会在字节码上完成一部分基础优化，如方法内联、常量传播等。</p>
</li>
<li><p>一个平台相关的后端从HIR中产生低级中间代码表示（LIR）</p>
<p>在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等。</p>
</li>
<li><p>平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔优化，然后产生机器代码</p>
</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230626100918.png"></p>
<h6 id="服务端编译器"><a href="#服务端编译器" class="headerlink" title="服务端编译器"></a>服务端编译器</h6><p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230626101130.png"></p>
<h4 id="2-2-提前编译器"><a href="#2-2-提前编译器" class="headerlink" title="2.2 提前编译器"></a>2.2 提前编译器</h4><h5 id="2-2-1-提前编译的优劣得失"><a href="#2-2-1-提前编译的优劣得失" class="headerlink" title="2.2.1 提前编译的优劣得失"></a>2.2.1 提前编译的优劣得失</h5><p>提前编译的两条分支：</p>
<ul>
<li>传统提前编译：类似于C、C++编译器，在程序运行前把程序代码编译成机器码</li>
<li>动态提前编译（即时编译缓存）：把原本即时编译器在运行时要做的编译工作提前做好保存下来，下次运行这些代码时直接加载使用</li>
</ul>
<p>提前编译的最大优势：没有执行时间和资源限制的压力。</p>
<p>即时编译的优势：</p>
<ul>
<li>性能分析制导优化</li>
<li>激进预测性优化</li>
<li>链接时优化</li>
</ul>
<h4 id="2-3-编译器优化技术"><a href="#2-3-编译器优化技术" class="headerlink" title="2.3 编译器优化技术"></a>2.3 编译器优化技术</h4><h5 id="2-3-1-优化技术概览"><a href="#2-3-1-优化技术概览" class="headerlink" title="2.3.1 优化技术概览"></a>2.3.1 优化技术概览</h5><p>方法内联在优化序列最靠前的位置，其好处：</p>
<ul>
<li>去除方法调用的成本（如查找方法版本、建立栈帧等）</li>
<li>为其他优化建立良好的基础</li>
</ul>
<p>冗余访问消除（共子表达式消除）</p>
<p>复写传播</p>
<p>无用代码消除（Dead Code）</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line">y = b.get();</span><br><span class="line">z = b.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法内联优化后</span></span><br><span class="line">y = b.value;</span><br><span class="line">z = b.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冗余访问优化后</span></span><br><span class="line">y = b.value;</span><br><span class="line">z = y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复写传播优化后</span></span><br><span class="line">y = b.value;</span><br><span class="line">y = y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无用代码消除</span></span><br><span class="line">y = b.value;</span><br></pre></td></tr></table></figure>

<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230627145217.png"></p>
<h5 id="2-3-2-方法内联"><a href="#2-3-2-方法内联" class="headerlink" title="2.3.2 方法内联"></a>2.3.2 方法内联</h5><p>将目标方法的代码原封不动地“复制”到发起调用的方法中，避免真实方法调用。</p>
<p>虚方法只有在运行时才知道具体类型，进而执行对应版本方法，因而方法内联有难度。</p>
<p>依托技术（CHA）：类型继承关系分析技术</p>
<p>对方法内联：</p>
<ul>
<li><p>非虚方法直接内联</p>
</li>
<li><p>虚方法使用CHA查询当前状态下是否有多个目标版本可选择，若当前状态下只有一个版本，就使用该版本，称为守护内联。这种内联属于激进预测性优化，必须预留“逃生门”</p>
</li>
<li><p>若CHA查询出来的结果确实有多个版本，那么即时编译器会使用内联缓存来缩减方法调用的开销。这种状态下方法调用是真正发生了的，但是比起直接查虚方法表更快。</p>
</li>
</ul>
<p>内联缓存的工作原理：</p>
<ul>
<li>未发生方法调用前，状态为空。</li>
<li>第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。</li>
<li>若以后每次调用的方法接收者版本都是一样的，那么它就是一种单态内联缓存，通过该缓存调用，比不用内联的非虚方法调用，仅多了一次类型判断的开销。</li>
<li>否则，退化为超多态内联缓存，开销相当于真正查找虚方法表来进行方法分派。</li>
</ul>
<p>方法内联是一种激进优化。</p>
<h5 id="2-3-3-逃逸分析"><a href="#2-3-3-逃逸分析" class="headerlink" title="2.3.3 逃逸分析"></a>2.3.3 逃逸分析</h5><p>基本原理：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230627151252.png"></p>
<p>根据逃逸程度进行优化：</p>
<ul>
<li><p>栈上分配</p>
<p>如果对象不会逃逸出线程，那么可以在栈上分配该对象的内存空间，这样就可以随栈帧出栈而销毁，无需经过GC收集处理，减少性能消耗。</p>
<p>支持方法逃逸，不支持线程逃逸。</p>
</li>
<li><p>标量替换</p>
<p>若一个数据已经无法再分解成更小的数据表示，如原始数据类型等，该数据就被称为标量。否则称为聚合量，如对象等。如果把一个 Java 对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。这样便无需创建整个对象，而只创建所需对象的成员变量，可以在栈上分配空间。</p>
<p>不允许对象逃逸出方法范围内。</p>
</li>
<li><p>同步消除</p>
<p>线程同步本身比较耗时，如果逃逸分析能够确定一个变量不会逃逸出线程，那么这个变量的读写肯定不会有竞争，也就无需对该变量进行同步处理。</p>
</li>
</ul>
<p>逃逸分析计算成本高，无法保证其性能收益会高于它的消耗。</p>
<h5 id="2-3-4-公共子表达式消除"><a href="#2-3-4-公共子表达式消除" class="headerlink" title="2.3.4 公共子表达式消除"></a>2.3.4 公共子表达式消除</h5><p>如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对于这种表达式，没必要对其进行二次计算，只需要使用前面已经计算过的值代替即可。</p>
<ul>
<li>局部公共子表达式消除：仅限于程序基本块内</li>
<li>全局公共子表达式消除：涵盖多个基本块</li>
</ul>
<h5 id="2-3-5-数组边界检查消除"><a href="#2-3-5-数组边界检查消除" class="headerlink" title="2.3.5 数组边界检查消除"></a>2.3.5 数组边界检查消除</h5><p>若确定了代码中访问数组不会越界，那么之后便无需再进行边界检查，减少性能开销。</p>
<hr>
<h2 id="四-高效并发"><a href="#四-高效并发" class="headerlink" title="四. 高效并发"></a>四. 高效并发</h2><h3 id="1-Java-内存模型与线程"><a href="#1-Java-内存模型与线程" class="headerlink" title="1. Java 内存模型与线程"></a>1. Java 内存模型与线程</h3><p>每秒事务处理数（TPS）：衡量服务性能的高低好坏，一秒内服务端平均能响应的请求总数。</p>
<h4 id="1-1-硬件的效率与一致性"><a href="#1-1-硬件的效率与一致性" class="headerlink" title="1.1 硬件的效率与一致性"></a>1.1 硬件的效率与一致性</h4><p>为了弥补计算机的存储设备与处理器的运算速度之间的差距，现代计算机系统引入了高速缓存来作为内存与处理器之间的缓冲。但随之产生了一个新问题：缓存一致性。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这种系统称为共享内存多核系统。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p>
<p>解决该问题的方法是让各个处理器都遵循一些协议，如MSI、MESI、MOSI等。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230628093517.png"></p>
<h4 id="1-2-Java-内存模型"><a href="#1-2-Java-内存模型" class="headerlink" title="1.2 Java 内存模型"></a>1.2 Java 内存模型</h4><p>作用：屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<h5 id="1-2-1-主内存与工作内存"><a href="#1-2-1-主内存与工作内存" class="headerlink" title="1.2.1 主内存与工作内存"></a>1.2.1 主内存与工作内存</h5><p>Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p>
<p>此处的变量指实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为后者是线程私有的。</p>
<p>Java 内存模型规定所有的变量都存放在主内存中（类比物理上的主内存），每条线程还有自己的工作内存（类比高速缓存）。</p>
<p>线程的工作内存中保存了该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而无法直接读写主内存的数据。不同线程间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需通过主内存来完成。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230628094836.png"></p>
<h5 id="1-2-2-内存间交互操作"><a href="#1-2-2-内存间交互操作" class="headerlink" title="1.2.2 内存间交互操作"></a>1.2.2 内存间交互操作</h5><p>Java 内存模型通过 8 种操作，这 8 种操作都是原子的、不可再分的，来实现主内存与工作内存的交互：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230628095056.png"></p>
<p>需要遵循的规则：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230628095632.png"></p>
<h5 id="1-2-3-对于-volatile-型变量的特殊性"><a href="#1-2-3-对于-volatile-型变量的特殊性" class="headerlink" title="1.2.3 对于 volatile 型变量的特殊性"></a>1.2.3 对于 volatile 型变量的特殊性</h5><p>volatile 是虚拟机提供的最轻量级的同步机制。</p>
<p>volatile 变量特性：</p>
<ul>
<li><p>保证此变量对所有线程的可见性，“可见性”是指当一条线程修改了该变量的值，新值对于其他线程来说是可以立即得知的。而普通变量在线程间的传递则需通过主内存来完成。</p>
<p>volatile 变量在各个工作线程下是不存在一致性问题的，但是其运算在并发下一样是不安全的。</p>
<p>若不符合以下两条规则，运算时仍然需要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
</li>
<li><p>禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p>
</li>
</ul>
<p>线程使用 volatile 的规则：</p>
<ul>
<li><p>load后必须是use，use前必须为load。</p>
<p>每次使用变量前必须先从主内存刷新最新的值，保证一致性。</p>
</li>
<li><p>assign后必须是store，store前必须为assign。</p>
<p>每次修改变量后都必须立刻同步会主内存，保证可见性。</p>
</li>
<li><p>若A表示线程T对变量V实施use或assign，F表示相关联的load或store，P是和F相应的对V的read或write；与此类似，B是线程T对变量W实施use或assign，G表示相关联的load或store，Q是和G相应的对W的read或write。如果A先于B，则P先于Q。</p>
<p>保证该变量不被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。</p>
</li>
</ul>
<h5 id="1-2-4-针对-long-和-double-型变量的特殊规则"><a href="#1-2-4-针对-long-和-double-型变量的特殊规则" class="headerlink" title="1.2.4 针对 long 和 double 型变量的特殊规则"></a>1.2.4 针对 long 和 double 型变量的特殊规则</h5><p>long 和 double 的非原子性协定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现自行选择是否要保证 64 位数据类型的load、store、read和write这四个操作的原子性。</p>
<h5 id="1-2-5-原子性、可见性与有序性"><a href="#1-2-5-原子性、可见性与有序性" class="headerlink" title="1.2.5 原子性、可见性与有序性"></a>1.2.5 原子性、可见性与有序性</h5><ol>
<li><p>原子性（Atomicity）</p>
<p>基本数据类型的访问、读写都具备原子性，如果需要一个更大范围的原子性保证，可以使用synchronized。</p>
</li>
<li><p>可见性（Visibility）</p>
<p>可见性是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</p>
<p>Java 内存模型是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile修饰的变量都是如此。区别在于volatile保证新值能够立即同步回主内存，以及每次使用前立即从主内存刷新，即保证了多线程操作时变量的可见性，而普通变量则无法保证这一点。</p>
<p>synchronized和final也能实现可见性。</p>
<ul>
<li>synchronized（同步块）：对一个变量执行unlock操作之前，必须先把该变量同步回主内存中。</li>
<li>final：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去，那么在其他线程中就能看见finial字段的值。</li>
</ul>
</li>
<li><p>有序性（Ordering）</p>
<p>volatile和synchronized可以保证有序性。</p>
<ul>
<li>volatile：本身禁止指令重排序。</li>
<li>synchronized：同一个时刻只允许一条线程对其进行lock操作。</li>
</ul>
</li>
</ol>
<h5 id="1-2-6-先行发生原则"><a href="#1-2-6-先行发生原则" class="headerlink" title="1.2.6 先行发生原则"></a>1.2.6 先行发生原则</h5><p>即操作发生的先后顺序。</p>
<p>“天然的”先行发生关系，有顺序性保障，无需任何同步器协助，可以直接使用：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230701154122.png"></p>
<p>时间先后顺序与先行发生原则之间基本没有因果关系，所以衡量并发安全问题的时候不要受时间顺序干扰，一切必须以先行发生原则为准。</p>
<h4 id="1-3-Java-与线程"><a href="#1-3-Java-与线程" class="headerlink" title="1.3 Java 与线程"></a>1.3 Java 与线程</h4><h5 id="1-3-1-线程的实现"><a href="#1-3-1-线程的实现" class="headerlink" title="1.3.1 线程的实现"></a>1.3.1 线程的实现</h5><p>实现线程的三种方式：</p>
<ul>
<li>内核线程（1:1）</li>
<li>用户线程（1:N）</li>
<li>用户线程+轻量级进程（N:M）</li>
</ul>
<h6 id="1-内核线程实现"><a href="#1-内核线程实现" class="headerlink" title="1. 内核线程实现"></a>1. 内核线程实现</h6><p>内核线程（KLI）就是直接由操作系统内核支持的线程，由内核完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。</p>
<p>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口–轻量级进程（LWP），就是我们通常意义上讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230701155624.png"></p>
<p>缺点：由于轻量级进程基于内核线程实现，所以各种线程操作都需要进行系统调用，而系统调用代价较高，需要在内核态与用户态来回切换，同时要占用一定的内核资源。</p>
<h6 id="2-用户线程实现"><a href="#2-用户线程实现" class="headerlink" title="2. 用户线程实现"></a>2. 用户线程实现</h6><p>广义上讲，一个线程只要不是内核线程，就是用户线程的一种。</p>
<p>狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230701160246.png"></p>
<p>优点：不需要切换到内核态，性能消耗低。</p>
<p>缺点：所有线程操作都需要由用户程序自己去处理，操作难度高且复杂。</p>
<p>因为使用用户线程实现的程序通常都比较复杂，除了有明确需求外，一般的应用程序都不倾向使用用户线程。</p>
<p>Java、Ruby等语言都曾使用过用户线程，最终都放弃使用。Golang、Erlang等语言支持用户线程。</p>
<h6 id="3-混合实现"><a href="#3-混合实现" class="headerlink" title="3. 混合实现"></a>3. 混合实现</h6><p>用户线程还是独立在用户空间中，轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230701161129.png"></p>
<h6 id="4-Java-线程的实现"><a href="#4-Java-线程的实现" class="headerlink" title="4. Java 线程的实现"></a>4. Java 线程的实现</h6><p>Java 线程如何实现并不受 Java 虚拟机规范的约束，有具体虚拟机实现。</p>
<p>“主流”平台上的”主流“商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1:1的线程模型。</p>
<h5 id="1-3-2-Java-线程调度"><a href="#1-3-2-Java-线程调度" class="headerlink" title="1.3.2 Java 线程调度"></a>1.3.2 Java 线程调度</h5><p>线程调度是指系统为线程分配处理器使用权的过程，调度方式主要有两种：</p>
<ul>
<li><p>协同式线程调度</p>
<p>优点：实现简单，一般没有线程同步的问题。</p>
<p>缺点：线程执行时间不可控制，可能由于一个线程导致整个进程阻塞。</p>
</li>
<li><p>抢占式线程调度</p>
<p>线程的执行时间是系统可控的，不会出现一个线程导致整个进程阻塞的问题。</p>
<p>Java 使用的线程调度方式就是抢占式调度，通过线程优先级进行调节。</p>
</li>
</ul>
<h5 id="1-3-3-状态转换"><a href="#1-3-3-状态转换" class="headerlink" title="1.3.3 状态转换"></a>1.3.3 状态转换</h5><p>Java 中的 6 种线程状态：</p>
<ul>
<li><p>新建（New）：创建后尚未启动的线程。</p>
</li>
<li><p>运行（Runnable）：包括操作系统线程状态中的Running和Ready。</p>
</li>
<li><p>无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒，以下方法会使线程进入Waiting状态：</p>
<ul>
<li>没有设置 Timeout 参数的 Object::wait() 方法</li>
<li>没有设置 Timeout 参数的 Thread::join() 方法</li>
<li>LockSupport::park() 方法</li>
</ul>
</li>
<li><p>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无需等待被其他线程显式唤醒，在一定时间后它们会由系统自动唤醒。以下方法会让线程进入该状态：</p>
<ul>
<li>Thread::sleep() 方法</li>
<li>设置了 Timeout 参数的 Object::wait() 方法</li>
<li>设置了 Timeout 参数的 Thread::join() 方法</li>
<li>LockSupport::parkNanos() 方法</li>
<li>LockSupport::parkUntil() 方法</li>
</ul>
</li>
<li><p>阻塞（Blocked）：线程被阻塞了。与等待状态的区别：</p>
<ul>
<li>阻塞：等待着获取一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生。</li>
<li>等待：等待一段时间，或者唤醒动作的发生。</li>
</ul>
<p>在程序等待进入同步区域的时候，线程将进入这种状态。</p>
</li>
<li><p>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</p>
</li>
</ul>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230701164301.png"></p>
<h4 id="1-4-Java-与协程"><a href="#1-4-Java-与协程" class="headerlink" title="1.4 Java 与协程"></a>1.4 Java 与协程</h4><p>最初多数的用户线程是被设计成协同式调度的，所以有了一个别名–”协程“。又由于这时候的协程会完整地做调用栈的保护、恢复工作，所以也被称为”有栈协程“。</p>
<p>协程的主要优势是轻量，但是需要在应用层面实现的内容很多。</p>
<hr>
<h3 id="2-线程安全与锁优化"><a href="#2-线程安全与锁优化" class="headerlink" title="2. 线程安全与锁优化"></a>2. 线程安全与锁优化</h3><h4 id="2-1-线程安全"><a href="#2-1-线程安全" class="headerlink" title="2.1 线程安全"></a>2.1 线程安全</h4><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得这个正确的结果，那就称这个对象是线程安全的。</p>
<h5 id="2-1-1-Java-语言中的线程安全"><a href="#2-1-1-Java-语言中的线程安全" class="headerlink" title="2.1.1 Java 语言中的线程安全"></a>2.1.1 Java 语言中的线程安全</h5><p>Java 语言中各种操作共享的数据分为五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<ol>
<li><p>不可变</p>
<p>不可变的对象一定是线程安全的，因为其无法被改变，因而线程访问时一定是可见的，无需任何线程安全保护措施。</p>
<p>final 修饰的对象即不可变。</p>
</li>
<li><p>绝对线程安全</p>
<p>绝对的线程安全能够完全满足线程安全的定义，但是其代价是十分高昂的。</p>
<p>Java API 中标注线程安全的类，大多数都不是绝对的线程安全。</p>
</li>
<li><p>相对线程安全</p>
<p>相对线程安全就是通常意义上的线程安全，它需要保证对这个对象单次的操作是线程安全的。</p>
<p>Java 中大部分声明线程安全的类都属于这种类型，如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。</p>
</li>
<li><p>线程兼容</p>
<p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。如ArrayList、HashMap等。</p>
<p>我们平常说一个类不是线程安全的，通常就是指这种情况。</p>
</li>
<li><p>线程对立</p>
<p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。</p>
<p>Java 语言天生支持多线程，线程对立代码很少出现，而且通常是有害的。</p>
</li>
</ol>
<h5 id="2-1-2-线程安全的实现方法"><a href="#2-1-2-线程安全的实现方法" class="headerlink" title="2.1.2 线程安全的实现方法"></a>2.1.2 线程安全的实现方法</h5><h6 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1. 互斥同步"></a>1. 互斥同步</h6><p>又称为阻塞同步，是一种悲观的并发策略。</p>
<p>同步：多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条（或者是一些）线程使用。</p>
<p>互斥是实现同步的一种手段，常见互斥实现方式：临界区、互斥量、信号量。</p>
<p>Java 中，最基本的互斥同步手段就是synchronized关键字。</p>
<p>synchronized关键字经过javac编译后，会在同步块前后形成monitorenter和monitorexit两个字节码指令，用来锁定和解锁。</p>
<p>执行monitorenter指令时，首先要获取对象的锁，若获取失败，当前线程被阻塞，直到请求锁定的对象被持有它的线程释放为止；否则，把该对象锁的计数器值加一，而在执行monitorexit指令时，计数器值减一，一旦计数器值等于0，锁即被释放。</p>
<p>注意两点：</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230703160955.png"></p>
<p>持有锁是一个重量级操作，需要耗费较多性能。</p>
<p>除了synchronized关键字外，Java类库还提供了java.util.concurrent包，其中的java.util.concurrent.locks.Lock接口便成了另一种全新的互斥同步手段。</p>
<p>基于Lock接口，用户能够以非块结构来实现互斥同步。</p>
<p>重入锁（ReentrantLock）是Lock最常见的一种实现，是可重入锁。基本用法与synchronized类似。</p>
<p>重入锁增加了一些高级功能：</p>
<ul>
<li><p>等待可中断：正在等待的线程可以放弃等待持有锁的线程释放锁，改为处理其他事情。</p>
</li>
<li><p>公平锁：多个线程在等待同一个锁时，必须按照锁的申请时间顺序来依次获得锁。</p>
<p>非公平锁无法保证这一点，当锁被释放时，任何一个等待锁的线程都有机会获得锁。</p>
<p>synchronized中的锁是非公平的，ReentrantLock默认也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁，但是性能会急剧下降。</p>
</li>
<li><p>锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象。</p>
<p>在synchronized中，锁对象的wait()和它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联，则需要额外添加一个锁；而ReentrantLock只需多次调用newCondition()方法即可。</p>
</li>
</ul>
<h6 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2. 非阻塞同步"></a>2. 非阻塞同步</h6><p>基于冲突检测的乐观并发策略，也就是不管风险，先进行操作，若没有其他线程争用共享数据，那么操作直接成功；若发生冲突，则采取其他补偿措施。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步，使用这种措施的代码也称为无锁编程。</p>
<p><strong>比较并交换（Compare-and-Swap，CAS）</strong>：CAS指令需要三个操作数，分别是内存位置（V）、旧的预期值（A）、新值（B）。当且仅当V符合A时，处理器才会用B更新V的值，否则不更新，该操作是原子的。</p>
<p>“ABA问题”：当一个对象值原本为A，后来被改为B，然后又被改为A，然后当前线程对其进行CAS操作，便会误认为该对象从来没有被更改过。</p>
<h6 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3. 无同步方案"></a>3. 无同步方案</h6><p>同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，则无需任何同步措施，因此有些代码天生就是线程安全的。</p>
<ul>
<li><p>可重入代码</p>
<p>又称为纯代码，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。</p>
<p>可重入代码是线程安全的，线程安全的代码不一定是可重入的。</p>
</li>
<li><p>线程本地存储</p>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>每一个线程的Thread对象中都有一个ThreadLocalMap对象，以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值，通过ThreadLocal就可以找到对应的本地线程变量。</p>
</li>
</ul>
<h4 id="2-2-锁优化"><a href="#2-2-锁优化" class="headerlink" title="2.2 锁优化"></a>2.2 锁优化</h4><h5 id="2-2-1-自旋锁与自适应自旋"><a href="#2-2-1-自旋锁与自适应自旋" class="headerlink" title="2.2.1 自旋锁与自适应自旋"></a>2.2.1 自旋锁与自适应自旋</h5><p>大多共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，只需让当前线程执行一个忙循环（自旋），等待持有锁的线程释放锁，这就是自旋锁。</p>
<p>自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，若锁被占用的时间很短，自旋等待的效果就很好；反之若锁被占用的时间很长，那么自旋线程只会白白消耗处理器资源，此时就应当使用传统的方式去挂起线程。</p>
<p>自适应自旋意味着自旋次数不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能成功，从而允许自旋等待更长时间。如果对于某个锁，自旋等待很少获取锁，那在以后要获取该锁时可能直接忽略自旋过程，避免浪费处理器资源。</p>
<h5 id="2-2-2-锁消除"><a href="#2-2-2-锁消除" class="headerlink" title="2.2.2 锁消除"></a>2.2.2 锁消除</h5><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。主要判定依据来源于逃逸分析的数据支持。</p>
<h5 id="2-2-3-锁粗化"><a href="#2-2-3-锁粗化" class="headerlink" title="2.2.3 锁粗化"></a>2.2.3 锁粗化</h5><p>原则上，在编写代码时，总是推荐将同步块的作用范围限制得尽量小。但是若一系列的连续操作都对同一对象进行反复加锁和解锁，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗。</p>
<h5 id="2-2-4-轻量级锁"><a href="#2-2-4-轻量级锁" class="headerlink" title="2.2.4 轻量级锁"></a>2.2.4 轻量级锁</h5><p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230705101344.png"></p>
<p>轻量级锁加锁过程：</p>
<ul>
<li><p>在代码即将进入同步块时，若该对象未被锁定，虚拟机将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储当前Mark Word的拷贝。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230705101758.png"></p>
</li>
<li><p>然后虚拟机使用CAS操作将对象的Mark Word更新为指向Lock Record的指针。若成功，即代表该线程拥有该对象的锁。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230705102200.png"></p>
</li>
<li><p>若失败，虚拟机实现检查对象的Mark Word是否指向当前线程的栈帧，若是，说明当前线程已经拥有该对象的锁，直接进入同步块继续执行即可，否则该锁对象已被其他线程占领。</p>
</li>
<li><p>如果出现两条以上的线程占用同一个锁，那么轻量级锁必须要膨胀为重量级锁，此时Mark Word中指向的就是重量级锁的指针，后面等待锁的线程也必须进入阻塞状态。</p>
</li>
</ul>
<h5 id="2-2-5-偏向锁"><a href="#2-2-5-偏向锁" class="headerlink" title="2.2.5 偏向锁"></a>2.2.5 偏向锁</h5><p>偏向锁的目的是消除数据在无竞争情况下的同步原语。</p>
<p>轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。</p>
<p>“偏”指的是偏心，该锁偏向第一个获得它的线程，若该锁在接下来的执行过程中，一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p><img src="/./JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230705103421.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JAVA</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 实战</title>
    <url>/Redis-%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="REDIS-实战"><a href="#REDIS-实战" class="headerlink" title="REDIS 实战"></a>REDIS 实战</h1><h2 id="一-初识-Redis"><a href="#一-初识-Redis" class="headerlink" title="一. 初识 Redis"></a>一. 初识 Redis</h2><p>一些数据库和缓存服务器的特性和功能</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721081941.png"></p>
<h3 id="1-Redis-数据结构简介"><a href="#1-Redis-数据结构简介" class="headerlink" title="1. Redis 数据结构简介"></a>1. Redis 数据结构简介</h3><p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721082251.png"></p>
<h4 id="1-1-Redis-中的字符串"><a href="#1-1-Redis-中的字符串" class="headerlink" title="1.1 Redis 中的字符串"></a>1.1 Redis 中的字符串</h4><p>字符串示例：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721082742.png"></p>
<p>字符串命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721082819.png"></p>
<h4 id="1-2-Redis-中的列表"><a href="#1-2-Redis-中的列表" class="headerlink" title="1.2 Redis 中的列表"></a>1.2 Redis 中的列表</h4><p>列表示例：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721083026.png"></p>
<p>列表命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721083153.png"></p>
<h4 id="1-3-Redis-的集合"><a href="#1-3-Redis-的集合" class="headerlink" title="1.3 Redis 的集合"></a>1.3 Redis 的集合</h4><p>集合示例：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721083604.png"></p>
<p>集合命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721083634.png"></p>
<h4 id="1-4-Redis-的散列"><a href="#1-4-Redis-的散列" class="headerlink" title="1.4 Redis 的散列"></a>1.4 Redis 的散列</h4><p>散列示例：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721083952.png"></p>
<p>散列命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721084038.png"></p>
<h4 id="1-5-Redis-的有序集合"><a href="#1-5-Redis-的有序集合" class="headerlink" title="1.5 Redis 的有序集合"></a>1.5 Redis 的有序集合</h4><p>有序集合示例：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721084422.png"></p>
<p>有序集合命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230721084457.png"></p>
<hr>
<h2 id="二-Redis-命令"><a href="#二-Redis-命令" class="headerlink" title="二. Redis 命令"></a>二. Redis 命令</h2><h3 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h3><p>字符串可以存储以下3种类型的值：</p>
<ul>
<li>字节串（byte string）</li>
<li>整数（取值范围为long integer）</li>
<li>浮点数</li>
</ul>
<p>自增和自减命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230722154620.png"></p>
<ul>
<li>若键原本不存在或键保存的是空串，那么redis在执行自增&#x2F;自减操作时会将其当为0值处理。</li>
<li>若键对应的值无法被转换为整数或浮点数，则会返回一个错误。</li>
</ul>
<p>处理子串和二进制位的命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230722155553.png"></p>
<ul>
<li>SETRANGE&#x2F;SETBIT命令对字符串进行写入时，若字符串长度不满足写入要求，那么redis会自动使用空字节扩展字符串长度，然后再执行写入或者更新操作。</li>
<li>GETRANGE读取字符串时，超出字符串末尾的数据会被视为空串。</li>
<li>GETBIT读取二进制位串时，超出字符串末尾的数据会被视为0.</li>
</ul>
<h3 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h3><p>常用列表命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230722161011.png"></p>
<p>列表间移动元素命令及阻塞式的弹出命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230722161430.png"></p>
<h3 id="3-集合"><a href="#3-集合" class="headerlink" title="3. 集合"></a>3. 集合</h3><p>常用集合命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723081322.png"></p>
<p>处理多个集合的命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723081627.png"></p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723081703.png"></p>
<h3 id="4-散列"><a href="#4-散列" class="headerlink" title="4. 散列"></a>4. 散列</h3><p>常用散列命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723082019.png"></p>
<p>散列高级特性：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723082210.png"></p>
<h3 id="5-有序集合"><a href="#5-有序集合" class="headerlink" title="5. 有序集合"></a>5. 有序集合</h3><p>常用有序集合命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723082618.png"></p>
<p>进阶命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723083031.png"></p>
<h3 id="6-发布与订阅"><a href="#6-发布与订阅" class="headerlink" title="6. 发布与订阅"></a>6. 发布与订阅</h3><p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723083717.png"></p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723083745.png"></p>
<h3 id="7-其他命令"><a href="#7-其他命令" class="headerlink" title="7. 其他命令"></a>7. 其他命令</h3><h4 id="7-1-排序"><a href="#7-1-排序" class="headerlink" title="7.1 排序"></a>7.1 排序</h4><p>sort命令：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723084305.png"></p>
<h4 id="7-2-基本的-Redis-事务"><a href="#7-2-基本的-Redis-事务" class="headerlink" title="7.2 基本的 Redis 事务"></a>7.2 基本的 Redis 事务</h4><p>五大命令：</p>
<ul>
<li>WATCH</li>
<li>MULTI</li>
<li>EXEC</li>
<li>UNWATCH</li>
<li>DISCARD</li>
</ul>
<h4 id="7-3-键的过期时间"><a href="#7-3-键的过期时间" class="headerlink" title="7.3 键的过期时间"></a>7.3 键的过期时间</h4><p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723151310.png"></p>
<hr>
<h2 id="三-数据安全与性能保障"><a href="#三-数据安全与性能保障" class="headerlink" title="三. 数据安全与性能保障"></a>三. 数据安全与性能保障</h2><h3 id="1-持久化选项"><a href="#1-持久化选项" class="headerlink" title="1. 持久化选项"></a>1. 持久化选项</h3><p>两种持久化方法：</p>
<ul>
<li>快照（snapshotting）：将存在于某一时刻的所有数据都写入硬盘。</li>
<li>只追加文件（append-only file，AOF）：在执行写命令式，将被执行的写命令复制到硬盘里面。</li>
</ul>
<h4 id="1-1-快照持久化"><a href="#1-1-快照持久化" class="headerlink" title="1.1 快照持久化"></a>1.1 快照持久化</h4><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。</p>
<p>创建快照的办法：</p>
<ul>
<li><p>BGSAVE命令（不支持Windows）</p>
<p>Redis 调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</p>
</li>
<li><p>SAVE命令</p>
<p>接到SAVE命令的redis服务器在快照创建完毕之前不再响应任何其他命令。不常用，通常只会在没有足够内存执行BGSAVE命令或不在意等待持久化操作执行完毕的情况下使用。</p>
</li>
<li><p>save配置选项</p>
<p>若用户设置了save配置选项，如save 60 10000，即在60秒内有10000次写入时触发BGSAVE命令。若设置了多个save配置选项，那么任意一个被满足时都会触发BGSAVE命令。</p>
</li>
<li><p>SHUTDOWN&#x2F;标准TERM命令</p>
<p>收到该命令时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在SAVE命令执行完毕后关闭服务器。</p>
</li>
<li><p>SYNC命令</p>
<p>当一个redis服务器连接另一个redis服务器，并向对方发送SYNC命令来开始一次复制操作时，如果主服务器没有执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器就会执行BGSAVE命令。</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>个人开发</li>
<li>对日志进行聚合计算</li>
<li>大数据</li>
</ul>
<h4 id="1-2-AOF-持久化"><a href="#1-2-AOF-持久化" class="headerlink" title="1.2 AOF 持久化"></a>1.2 AOF 持久化</h4><p>AOF 持久化会将被执行的写命令写到 AOF 文件的末尾，redis只要从头到尾重新执行一次 AOF 文件包含的所有写命令，就可以恢复 AOF 文件所记录的数据集。</p>
<p>appendfsync配置选项：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723154421.png"></p>
<h4 id="1-3-重写-压缩-AOF-文件"><a href="#1-3-重写-压缩-AOF-文件" class="headerlink" title="1.3 重写&#x2F;压缩 AOF 文件"></a>1.3 重写&#x2F;压缩 AOF 文件</h4><p>为了解决 AOF 文件体积不断增大的问题，用户可以向Redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件中的冗余命令来重写AOF文件，使AOF文件变得尽量小。其工作原理类似于BGSAVE，均需要创建一个子进程。</p>
<h3 id="2-复制"><a href="#2-复制" class="headerlink" title="2. 复制"></a>2. 复制</h3><p>redis通常使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有读请求。</p>
<p>在需要扩展读请求时，或在需要写入临时数据时，用户可以通过设置额外的redis从服务器来保存数据集的副本。</p>
<p>在接收到主服务器发送的数据初始副本之后，客户端每次向主服务器进行写入时，从服务器都会实时更新。</p>
<p>在部署好主从服务器后，客户端就可以向任意一个从服务器发送读请求了，即实现了负载均衡。</p>
<h4 id="2-1-相关选项配置"><a href="#2-1-相关选项配置" class="headerlink" title="2.1 相关选项配置"></a>2.1 相关选项配置</h4><p>slaveof host port配置选项：根据给定的IP地址和端口来连接主服务器。</p>
<p>SLAVEOF no one命令：终止复制操作，不再接受主服务器的数据更新。</p>
<p>SLAVEOF host port命令：开始复制一个新的主服务器。</p>
<h4 id="2-2-启动过程"><a href="#2-2-启动过程" class="headerlink" title="2.2 启动过程"></a>2.2 启动过程</h4><p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723160113.png"></p>
<p>Redis 不支持主主复制。</p>
<p>当多个从服务器尝试连接同一个主服务器时，会出现以下情况：</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723160605.png"></p>
<h4 id="2-3-主从链"><a href="#2-3-主从链" class="headerlink" title="2.3 主从链"></a>2.3 主从链</h4><p>从服务器也可以拥有自己的从服务器，从而形成主从链。</p>
<p>从从复制与主从复制的唯一区别在于，若从服务器X拥有从服务器Y，那么当X在执行复制的步骤4时，它将断开与Y的连接，导致Y需要重新连接并重新同步。</p>
<p><img src="/./Redis-%E5%AE%9E%E6%88%98/QQ%E6%88%AA%E5%9B%BE20230723161142.png"></p>
<h4 id="2-4-检验硬盘写入"><a href="#2-4-检验硬盘写入" class="headerlink" title="2.4 检验硬盘写入"></a>2.4 检验硬盘写入</h4><p>为了验证主服务器是否已经将数据发送至从服务器，用户需要主服务器写入真正的数据之后，再向主服务器写入一个唯一的虚构值，然后通过检查虚构值是否存在于从服务器来判断写数据是否已经到达从服务器。</p>
<p>判断数据是否已经被保存到硬盘里面的方法：检查INFO命令的输出结果中aof_pending_bio_fsync属性的值是否为0，若为0，则表示数据已经存入硬盘中。</p>
<h3 id="3-处理系统故障"><a href="#3-处理系统故障" class="headerlink" title="3. 处理系统故障"></a>3. 处理系统故障</h3><h4 id="3-1-验证快照文件和-AOF-文件"><a href="#3-1-验证快照文件和-AOF-文件" class="headerlink" title="3.1 验证快照文件和 AOF 文件"></a>3.1 验证快照文件和 AOF 文件</h4><p>修复 AOF 文件和快照文件的命令：</p>
<ul>
<li><p>redis-check-aof</p>
<p>–fix参数，修复AOF文件，扫描给定的AOF文件，寻找不正确或不完整的命令，并删除第一个出错的命令及其之后的所有命令。</p>
</li>
<li><p>redis-check-dump</p>
<p>目前并没有办法可以修复出错的快照文件，由于快照文件本身经过了压缩，其中出现的错误可能会导致整个文件都不可读，因而无法修复。</p>
</li>
</ul>
<h4 id="3-2-更换故障主服务器"><a href="#3-2-更换故障主服务器" class="headerlink" title="3.2 更换故障主服务器"></a>3.2 更换故障主服务器</h4><p>更换主服务器的方法：</p>
<ul>
<li>首先向从服务器B发送一个SAVE命令，让它创建一个新的快照文件。</li>
<li>将该快照文件发送给新的主服务器C，并在C上启动Redis。</li>
<li>最后让B成为C的从服务器。</li>
</ul>
<p>另一种创建新的主服务器方法：将从服务器升级为主服务器，并为升级后的主服务器创建从服务器。</p>
<h3 id="4-Redis-事务"><a href="#4-Redis-事务" class="headerlink" title="4. Redis 事务"></a>4. Redis 事务</h3><h3 id="5-非事务型流水线"><a href="#5-非事务型流水线" class="headerlink" title="5. 非事务型流水线"></a>5. 非事务型流水线</h3><hr>
<h2 id="四-使用-Redis-构建支持程序"><a href="#四-使用-Redis-构建支持程序" class="headerlink" title="四. 使用 Redis 构建支持程序"></a>四. 使用 Redis 构建支持程序</h2><h3 id="1-使用-Redis-来记录日志"><a href="#1-使用-Redis-来记录日志" class="headerlink" title="1. 使用 Redis 来记录日志"></a>1. 使用 Redis 来记录日志</h3><p>Linux和Unix两种常见的记录日志的方法：</p>
<ul>
<li><p>日志记录到文件中，然后不断添加日志行</p>
<p>缺点：不同服务会创建不同的日志，这些服务轮换（rolling）日志的机制各不相同，并且也缺少一种能够方便地聚合所有日志并对其进行处理的常用方法。</p>
</li>
<li><p>syslog 服务</p>
<p>运行在514号TCP端口和UDP端口上。</p>
<p>syslog接受其他程序发来的日志消息，并将这些信息路由至存储在硬盘上的各个日志文件里，还负责旧日志的轮换和删除工作。</p>
</li>
</ul>
<h3 id="2-计数器和统计数据"><a href="#2-计数器和统计数据" class="headerlink" title="2. 计数器和统计数据"></a>2. 计数器和统计数据</h3><h3 id="3-查找-IP-所属城市以及国家"><a href="#3-查找-IP-所属城市以及国家" class="headerlink" title="3. 查找 IP 所属城市以及国家"></a>3. 查找 IP 所属城市以及国家</h3><h3 id="4-服务的发现与配置"><a href="#4-服务的发现与配置" class="headerlink" title="4. 服务的发现与配置"></a>4. 服务的发现与配置</h3>]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件</title>
    <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker 是一个开源的应用容器引擎，基于 Go语言 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>三个基本概念：</p>
<ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p>常用命令：</p>
<p>Docker 镜像命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看Docker信息</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"># 查看Docker 镜像列表</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 搜索镜像</span><br><span class="line">docker search 镜像名</span><br><span class="line"></span><br><span class="line"># 拉取镜像</span><br><span class="line">docker pull 镜像名:tag</span><br><span class="line"></span><br><span class="line"># 运行镜像</span><br><span class="line">docker run 镜像名</span><br></pre></td></tr></table></figure>

<p>Docker 容器命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看正在运行的容器</span><br><span class="line">docker ps</span><br><span class="line"># 查看所有容器--包含正在运行和已停止的</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"># 运行容器</span><br><span class="line">docker run -it -d --name 别名 镜像名:Tag /bin/bash</span><br><span class="line"></span><br><span class="line"># 停止容器</span><br><span class="line">docker stop 容器名/容器ID</span><br><span class="line"># 启动容器</span><br><span class="line">docker start 容器名/容器ID</span><br><span class="line"># 重启容器</span><br><span class="line">docker restart 容器名/容器ID</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<table>
<thead>
<tr>
<th align="left">SQL术语&#x2F;概念</th>
<th align="left">MongoDB术语&#x2F;概念</th>
<th align="left">解释&#x2F;说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">database</td>
<td align="left">database</td>
<td align="left">数据库</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">collection</td>
<td align="left">数据库表&#x2F;集合</td>
</tr>
<tr>
<td align="left">row</td>
<td align="left">document</td>
<td align="left">数据记录行&#x2F;文档</td>
</tr>
<tr>
<td align="left">column</td>
<td align="left">field</td>
<td align="left">数据字段&#x2F;域</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">index</td>
<td align="left">索引</td>
</tr>
<tr>
<td align="left">table joins</td>
<td align="left"></td>
<td align="left">表连接,MongoDB不支持</td>
</tr>
<tr>
<td align="left">primary key</td>
<td align="left">primary key</td>
<td align="left">主键,MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody></table>
<p>优点：</p>
<ul>
<li><p>高效率存储访问（高并发、高性能、高可用）</p>
</li>
<li><p>面向文档的数据模型</p>
</li>
<li><p>强大的查询功能</p>
</li>
<li><p>负载均衡</p>
</li>
<li><p>高扩展性</p>
</li>
<li><p>兼顾 SQL 与 NoSQL</p>
</li>
</ul>
<p>常用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示数据库</span><br><span class="line">show dbs</span><br><span class="line"># 显示数据库中的集合</span><br><span class="line">show collections</span><br><span class="line"># 显示用户信息</span><br><span class="line">show users</span><br><span class="line"></span><br><span class="line"># 切换数据库</span><br><span class="line">use database</span><br><span class="line"># 删除数据库</span><br><span class="line">db.dropDatabase()</span><br><span class="line"></span><br><span class="line"># 数据增删改查</span><br><span class="line">db.col.insert()</span><br><span class="line">db.col.remove()</span><br><span class="line">db.col.update()</span><br><span class="line">db.col.find()</span><br><span class="line"></span><br><span class="line"># 索引增删</span><br><span class="line">db.col.ensureIndex()</span><br><span class="line">db.col.dropIndex()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ是一个开源的，基于AMQP（高级消息队列协议）的消息系统（消息中间件）。</p>
<p>优点：</p>
<ul>
<li><p>应用解耦</p>
</li>
<li><p>异步提速</p>
</li>
<li><p>流量削峰</p>
</li>
<li><p>可恢复性</p>
</li>
</ul>
<p>基础架构：</p>
<ul>
<li>生产者（Producer）</li>
<li>交换器（Exchange）</li>
<li>队列（Queue）</li>
<li>绑定（Binding）</li>
<li>消费者（Consumer）</li>
</ul>
<hr>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p>Elasticsearch是一个基于Lucene（全文搜索引擎）的搜索服务器，是一个分布式、高扩展、高实时的搜索与数据分析引擎。</p>
<p>应用场景：</p>
<ul>
<li>海量数据查询</li>
<li>搜索引擎</li>
<li>实时数据分析</li>
<li>日志和事件管理</li>
</ul>
<p>核心概念：</p>
<ul>
<li>索引（index）：存储数据，相当于数据库</li>
<li>映射（mapping）：定义字段类型、分词器等，相当于数据库中的表结构</li>
<li>文档（document）：最小数据单元，通常为json格式，相当于数据库中的一行数据</li>
<li>倒排索引：一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，对应一个包含它的文档id列表</li>
</ul>
<p>常用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 索引操作</span><br><span class="line"># 创建索引</span><br><span class="line">PUT http://ip:port/索引名称</span><br><span class="line"># 查询索引</span><br><span class="line">GET http://ip:port/索引1，索引2，...</span><br><span class="line">GET http://ip:port/_all </span><br><span class="line"># 删除索引</span><br><span class="line">DELETE http://ip:port/索引名称</span><br><span class="line"># 关闭、打开索引</span><br><span class="line">POST http://ip:port/索引名称/_close  </span><br><span class="line">POST http://ip:port/索引名称/_open </span><br><span class="line"></span><br><span class="line"># 操作映射</span><br><span class="line">PUT /index</span><br><span class="line">&#123;</span><br><span class="line">	&quot;mappings&quot;:&#123;</span><br><span class="line">		&quot;properties&quot;:&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">PUT /index/_mapping</span><br><span class="line">&#123;</span><br><span class="line">	&quot;properties&quot;:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 操作文档</span><br><span class="line"># 添加文档</span><br><span class="line">POST /index/_doc/id</span><br><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;:···</span><br><span class="line">&#125;</span><br><span class="line"># 查询文档</span><br><span class="line">GET /index/_doc/id</span><br><span class="line"># 删除文档</span><br><span class="line">DELETE /index/_doc/id</span><br><span class="line"># 清空文档</span><br><span class="line">POST person1/_delete_by_query</span><br><span class="line">&#123;  </span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>串</title>
    <url>/%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="1-基本串操作"><a href="#1-基本串操作" class="headerlink" title="1. 基本串操作"></a>1. 基本串操作</h2><h3 id="1-1-验证回文串"><a href="#1-1-验证回文串" class="headerlink" title="1.1 验证回文串"></a>1.1 验证回文串</h3><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> 。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>思路</strong></p>
<p>首先将所给字符串转换为只含有字母数字字符的字符串，然后通过双指针进行比较。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        StringBuilder cnt=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="comment">// 转换字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> p=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(p))&#123;</span><br><span class="line">                cnt.append(p);<span class="comment">// 数字直接加入字符串</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Character.isLetter(p))&#123;</span><br><span class="line">                cnt.append(Character.toLowerCase(p));<span class="comment">// 字母转成小写加入字符串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=cnt.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 比较字符串左右两侧字符是否相等</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.charAt(left)!=cnt.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-最长公共前缀"><a href="#1-2-最长公共前缀" class="headerlink" title="1.2 最长公共前缀"></a>1.2 最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>思路</strong></p>
<p>横向扫描，依次字符串遍历数组，每次更新当前的最长公共前缀。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=strs.length;</span><br><span class="line">        String ans=strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 更新最长公共前缀</span></span><br><span class="line">            ans=find(strs[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找两个字符串的最长公共前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">find</span><span class="params">(String str1,String str2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> len=Math.min(str1.length(),str2.length());</span><br><span class="line">        <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(id&lt;len&amp;&amp;str1.charAt(id)==str2.charAt(id))&#123;</span><br><span class="line">            id++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-压缩字符串"><a href="#1-3-压缩字符串" class="headerlink" title="1.3 压缩字符串"></a>1.3 压缩字符串</h3><p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p>
<p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong> ：</p>
<ul>
<li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li>
<li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li>
</ul>
<p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</p>
<p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p>
<p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p>
<p><strong>思路</strong></p>
<p>双指针，一个指针指向当前数组，一个指针指向压缩后的数组，依次判断。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compress</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=chars.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 判读字符是否重复</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;n-<span class="number">1</span>&amp;&amp;chars[i]==chars[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> pre=i;</span><br><span class="line">                <span class="comment">// 寻找第一个不重复的字符</span></span><br><span class="line">                <span class="keyword">while</span>(i&lt;n-<span class="number">1</span>&amp;&amp;chars[i]==chars[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 重复字符的长度</span></span><br><span class="line">                <span class="type">int</span> num=i-pre+<span class="number">1</span>;</span><br><span class="line">                String tot=String.valueOf(num);</span><br><span class="line">                <span class="comment">// 将该字符加入压缩数组中</span></span><br><span class="line">                chars[index++]=chars[pre];</span><br><span class="line">                <span class="comment">// 将字符长度加入压缩数组中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot.length();j++)&#123;</span><br><span class="line">                    chars[index++]=tot.charAt(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 若不重复，则直接加入压缩数组中</span></span><br><span class="line">                chars[index++]=chars[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-串模式匹配"><a href="#2-串模式匹配" class="headerlink" title="2. 串模式匹配"></a>2. 串模式匹配</h2><h3 id="2-1-找出字符串中第一个匹配项的下标"><a href="#2-1-找出字符串中第一个匹配项的下标" class="headerlink" title="2.1 找出字符串中第一个匹配项的下标"></a>2.1 找出字符串中第一个匹配项的下标</h3><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>
<p><strong>思路</strong></p>
<p>直观思路：暴力枚举，每次让<code>needle</code>与<code>haystack</code>进行匹配，直到找到匹配项。</p>
<p>进阶：<code>KMP</code>算法。(算法难度较高，证明较难)</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// KMP算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=haystack.length(),m=needle.length();</span><br><span class="line">        <span class="type">int</span>[] pre=<span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="comment">// 求needle的前缀函数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;needle.charAt(i)!=needle.charAt(j))&#123;</span><br><span class="line">                j=pre[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pre[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以needle为前缀，haysta为后缀求前缀函数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;needle.charAt(j)!=haystack.charAt(i))&#123;</span><br><span class="line">                j=pre[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(j)==haystack.charAt(i))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">                <span class="keyword">return</span> i-m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-重复的子字符串"><a href="#2-2-重复的子字符串" class="headerlink" title="2.2 重复的子字符串"></a>2.2 重复的子字符串</h3><p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p><strong>思路</strong></p>
<p>KMP算法寻找最小重复子串，然后判断该字符串是否由该最小重复子串组成。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="type">int</span>[] pi=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 求前缀函数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s.charAt(i)!=s.charAt(j))&#123;</span><br><span class="line">                j=pi[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j)==s.charAt(i))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若最长相等前后缀长度不为0，且n为最小重复子串的倍数，则为真</span></span><br><span class="line">        <span class="keyword">return</span> pi[n-<span class="number">1</span>]!=<span class="number">0</span>&amp;&amp;n%(n-pi[n-<span class="number">1</span>])==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-数组中的字符串匹配"><a href="#2-3-数组中的字符串匹配" class="headerlink" title="2.3 数组中的字符串匹配"></a>2.3 数组中的字符串匹配</h3><p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 <strong>任意</strong> 顺序返回 <code>words</code> 中是其他单词的子字符串的所有单词。</p>
<p>如果你可以删除 <code>words[j]</code> 最左侧和&#x2F;或最右侧的若干字符得到 <code>words[i]</code> ，那么字符串 <code>words[i]</code> 就是 <code>words[j]</code> 的一个子字符串。</p>
<p><strong>思路</strong></p>
<p>暴力枚举，二重循环依次判断。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">stringMatching</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        List&lt;String&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> n=words.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">// 判断words[j]是否包含words[i]</span></span><br><span class="line">                <span class="comment">// 若包含，加入数组，并中断当前循环，避免多次加入</span></span><br><span class="line">                <span class="keyword">if</span>(i!=j&amp;&amp;words[j].contains(words[i]))&#123;</span><br><span class="line">                    cnt.add(words[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><blockquote>
<p>参考来源：字节跳动青训营（后端）</p>
</blockquote>
<p>IDL：接口描述（定义）语言，用于描述接口</p>
<p>规则引擎：由推理引擎发展而来，是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策。接受数据输入，解释业务规则，并根据业务规则做出业务决策。</p>
<p>优点：</p>
<ul>
<li>分离商业决策逻辑与开发者的技术决策</li>
<li>提高实现复杂逻辑的代码的可维护性</li>
</ul>
<p>架构，又称软件架构：</p>
<ul>
<li>是有关软件整体结构与组件的抽象描述</li>
<li>用于指导软件系统各个方面的设计</li>
</ul>
<p>软件架构：</p>
<ul>
<li><p>单机（单一进程，单一机器）</p>
<p>优点：</p>
<ul>
<li>简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>运维需要停服，用户体验较差</li>
<li>承载能力有限。了解下 c10k 问题（服务器如何支持10k个并发连接）</li>
</ul>
</li>
<li><p>单体（单一进程，多个机器）</p>
<p>优点：</p>
<ul>
<li>具备水平扩容能力</li>
<li>运维不需要停服</li>
</ul>
<p>缺点：</p>
<ul>
<li>后端进程职责太多，越来越臃肿</li>
<li>爆炸半径较大，进程中一个很小的模块出现问题，都可能导致整个进程崩溃</li>
</ul>
</li>
<li><p>垂直应用（多个进程，多个机器）</p>
<p>优点：</p>
<ul>
<li>一定程度上减少了后端进程职责</li>
<li>一定程度上缩小爆炸半径</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有根本解决单体架构的问题</li>
</ul>
</li>
<li><p>SOA (Service Oriented Architecture)</p>
<p>SOA 架构中，服务为一等公民，将进程按照不同的功能单元进行抽象，拆分为『服务』。有了服务之后，SOA 还为服务之间的通信定义了标准，保证各个服务之间通讯体验的一致性。</p>
<p>优点：</p>
<ul>
<li>各服务的职责更清晰</li>
<li>运维粒度减小到服务，爆炸半径可控</li>
</ul>
<p>缺点：</p>
<ul>
<li>ESB (企业服务总线) 往往需要一整套解决方案</li>
</ul>
</li>
<li><p>微服务 (Microservice)</p>
<p>在 SOA 架构中，ESB 起到了至关重要的作用。但从架构拓扑来看，它更像是一个集中式的模块。有一个 SOA 分布式演进的分支，最终的形态便是微服务。</p>
<p>优点：</p>
<ul>
<li>兼具 SOA 解决的问题</li>
<li>服务间的通信更敏捷、灵活</li>
</ul>
<p>缺点：</p>
<ul>
<li>运维成本</li>
</ul>
</li>
</ul>
<p>架构演进的初衷：满足软件迭代诉求，提高迭代效率</p>
<p>架构演进的思路：垂直切分——分布式，水平切分——分层&#x2F;模块化</p>
<h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p>云计算基础：</p>
<ul>
<li>虚拟化技术<ul>
<li>硬件层面（VM 虚拟机）- KVM&#x2F;Xen&#x2F;VMware</li>
<li>操作系统层面（Container 容器）- LCX&#x2F;Docker&#x2F;Kata Container</li>
<li>网络层面 - Linux Bridge&#x2F;Open v Switch</li>
</ul>
</li>
<li>编排方案<ul>
<li>VM - OpenStack&#x2F;VMWare Workstation</li>
<li>Container - Kubernetes&#x2F;Docker Swarm</li>
</ul>
</li>
</ul>
<p>云计算架构：</p>
<ul>
<li>云服务<ul>
<li>IaaS（基础设施即服务） - 云基础设施，对底层硬件资源池的抽象</li>
<li>PaaS（平台即服务） - 基于资源池抽象，对上层提供的弹性资源平台</li>
<li>SaaS（软件即服务） - 基于弹性资源平台构建的云服务</li>
<li>FaaS（函数即服务） - 更轻量级的函数服务。好比 LeetCode 等 OJ，刷题时只需要实现函数，不需要关注输入输出流</li>
</ul>
</li>
<li>云部署模式<ul>
<li>私有云 - 企业自用</li>
<li>公有云 - AWS&#x2F;Azure&#x2F;Google Cloud&#x2F;Huawei</li>
<li>混合云</li>
</ul>
</li>
</ul>
<h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>云原生，实际是云原生（计算）的简称，它是云计算发展到现在的一种形态。</p>
<p>云原生技术为组织（公司）在公有云、自由云、混合云等新型的动态环境中，构建和运行可弹性拓展的应用提供了可能。 它的代表技术：</p>
<ul>
<li>弹性资源</li>
<li>微服务架构</li>
<li>DevOps</li>
<li>服务网格</li>
</ul>
<h3 id="弹性资源"><a href="#弹性资源" class="headerlink" title="弹性资源"></a>弹性资源</h3><p>基于虚拟化技术，提供的可以快速扩缩容的能力。可以分为弹性计算资源和弹性存储资源两个方面。</p>
<p>弹性计算资源：</p>
<ul>
<li>计算资源调度<ul>
<li>在线计算 - 互联网后端服务</li>
<li>离线计算 - 大数据分析（Map-Reduce&#x2F;Spark&#x2F;Flink）</li>
</ul>
</li>
<li>消息队列<ul>
<li>在线队列 - 削峰、解耦</li>
<li>离线队列 - 结合数据分析的一整套方案，如 ELK</li>
</ul>
</li>
</ul>
<p>弹性存储资源：</p>
<ul>
<li>经典存储<ul>
<li>对象存储 - 视频、图片等。结合 CDN 等技术，可以为应用提供丰富的多媒体能力</li>
<li>大数据存储 - 应用日志、用户数据等。结合数据挖掘、机器学习等技术，提高应用的体验</li>
</ul>
</li>
<li>关系型数据库</li>
<li>元数据<ul>
<li>服务发现</li>
</ul>
</li>
<li>NoSQL<ul>
<li>KV 存储 - Redis</li>
<li>文档存储 - Mongo</li>
</ul>
</li>
</ul>
<p>在云原生的大背景下，不论是计算资源还是存储资源，他们都像是服务一样供用户使用。</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构下，服务之间的通讯标准是基于协议而不是 ESB 的。</p>
<ul>
<li>HTTP - H1&#x2F;H2</li>
<li>RPC - Apache Thrift&#x2F;gRPC</li>
</ul>
<p>如何在 HTTP 和 RPC 之间选择？</p>
<ul>
<li>性能 - RPC 协议往往具备较好的压缩率，性能较高。如 Thrift, Protocol Buffers</li>
<li>服务治理 - RPC 中间件往往集成了丰富的服务治理能力。如 熔断、降级、超时等</li>
<li>可解释性 - HTTP 通信的协议往往首选 JSON，可解释性、可调试性更好</li>
</ul>
<h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><p>什么是服务网格？</p>
<ul>
<li>微服务之间通讯的中间层</li>
<li>一个高性能的 4 层网络代理</li>
<li>将流量层面的逻辑与业务进程解耦</li>
</ul>
<p>没有什么是加一层代理解决不了的问题，服务网格相比较于 RPC&#x2F;HTTP 框架：</p>
<ul>
<li>实现了异构系统治理体验的统一化</li>
<li>服务网格的数据平面代理与业务进程采取进程间通信的模式，使得流量相关的逻辑（包含治理）与业务进程解耦，生命周期也更容易管理</li>
</ul>
<h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><p>什么是分布式？</p>
<ul>
<li>分布式系统定义：跨多个节点的计算机程序的集合</li>
<li>使用分布式系统的五大优势：去中心化、低成本、弹性、资源共享、可靠性高</li>
<li>分布式系统的挑战：故障、网络、环境、安全</li>
</ul>
<p>常见的分布式系统：</p>
<ul>
<li>分布式存储：GFS、Ceph、HDFS、Zookeeper</li>
<li>分布式数据库：Spanner、TiDB、HBase、MangoDB</li>
<li>分布式计算：Hadoop、YARN、Spark</li>
</ul>
<h3 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h3><h4 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h4><p>六种故障模型，从处理的难易程度分类</p>
<ul>
<li>Byzantine failure：节点可以任意篡改发送给其他节点的数据，是最难处理的故障</li>
<li>Authentication detectable byzantine failure (ADB)：节点可以篡改数据，但不能伪造其他节点的数据</li>
<li>Performance failure：节点未在特定时间段内收到数据，即时间太早或太晚</li>
<li>Omission failure：节点收到数据的时间无限晚，即收不到数据</li>
<li>Crash failure：节点停止响应，持续性的故障</li>
<li>Fail-stop failure：错误可检测，是最容易处理的故障</li>
</ul>
<h4 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h4><p>两将军问题</p>
<ul>
<li>定义：<ul>
<li>两支军队的将军只能派信使穿越敌方领土互相通信，以此约定进攻时间。该问题希望求解如何在两名将军派出的任何信使都可能被俘虏的情况下，就进攻时间达成共识</li>
</ul>
</li>
<li>结论：<ul>
<li>两将军问题是被证实无解的电脑通信问题，两支军队理论上永远无法达成共识</li>
</ul>
</li>
<li>TCP是两将军问题的一个工程解</li>
</ul>
<p>三将军问题：</p>
<ul>
<li>两个“忠将”A和B，一个“叛徒”C，互相传递消息，消息可能丢失，也可能被篡改，当有一个将军是“叛徒”（即出现拜占庭故障）时，整个系统无法达成一致。</li>
<li>由于“叛徒”C的存在，将军A和将军B获得不同的信息。这样将军A获得2票进攻1票撤退的信息，将军B获得1票进攻2票撤退的信息，产生了不一致</li>
</ul>
<p>四将军问题：</p>
<ul>
<li>将军D作为消息分发中枢，约定如果没收到消息则执行撤退</li>
<li>步骤：<ul>
<li>如果D为“叛徒”，ABC无论收到任何消息，总能达成一致</li>
<li>D为“忠将”，ABC有2人将D的消息进行正确的传递，同样能保证最终决策符合大多数。</li>
</ul>
</li>
<li>进而能够证明，当有3m+1个将军，m个“叛徒”时，可以进行m轮协商，最终达成一致</li>
</ul>
<h4 id="共识和一致性"><a href="#共识和一致性" class="headerlink" title="共识和一致性"></a>共识和一致性</h4><ul>
<li>不同客户端A和B看到客户端C写入，因为时机的不同，产生数据读取的偏差。引导出最终一致性的详细说明</li>
<li>要保证所有客户端看到相同的值，需要多节点进行“协商”，达成共识，来保证线性一致性</li>
<li>一致性和可用性是对矛盾</li>
</ul>
<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h4><p>CAP的定义，分别代表一致性、可用性、分区容错性。三者无法同时达到</p>
<p>CAP诞生了三类系统：</p>
<ul>
<li>CA系统：传统数据库的代表</li>
<li>AP系统：放弃强一致性，保证高可用，不少nosql存储系统采用</li>
<li>CP系统：放弃可用性，保证数据一致性</li>
</ul>
<p>举例说明两个分布式进程之间同步数据，当出现故障的时候，如何选择不同的CAP系统，以及带来的影响：</p>
<ul>
<li>CP系统：故障发生时，为了避免读到不一致的数据，可能拒绝访问</li>
<li>AP系统：故障发生时，为了保证可用性，允许不同进程读到不同的数据</li>
</ul>
<p>针对故障场景，可以通过故障转移的方式，做一个相对较优的解决方式：</p>
<ul>
<li>允许一个进程作为Master，其他进程作为Backup，当故障时将请求转移给Backup进行处理</li>
</ul>
<h4 id="ACID理论"><a href="#ACID理论" class="headerlink" title="ACID理论"></a>ACID理论</h4><ul>
<li><p>ACID理论是针对CA系统而言的，通常在数据库中具有广泛意义</p>
</li>
<li><p>事务是数据库系统中非常重要的概念，它是数据库管理系统执行过程中的一个逻辑单元，它能够保证一个事务中的所有操作要么全部执行，要么全都不执行</p>
</li>
<li><p>数据库事务拥有四个特性ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）</p>
</li>
</ul>
<h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>BASE理论是针对AP系统而言的，其来源于对大型互联网分布式实践的总结</p>
<ul>
<li>Basically Available(基本可用)：假设系统，出现了不可预知的故障，但还是能用</li>
<li>Soft state（软状态）：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性</li>
<li>Eventually consistent（最终一致性）：数据最终一定能够达到一致的状态</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><p>定义：</p>
<ul>
<li>二阶段提交（Two-phase Commit）：为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种演算法。</li>
</ul>
<p>三个假设：</p>
<ul>
<li>协调者和参与者进行通信</li>
<li>预写式日志被保持在可靠的存储设备上</li>
<li>所有节点不会永久性损坏，即使损坏后仍然可以恢复</li>
</ul>
<p>正常流程：Prepare阶段和Commit阶段</p>
<p>异常流程：Prepare阶段失败 -&gt; 回滚；协调者宕机 -&gt; 重新启用新的协调者；双故障重启 -&gt; 数据库管理员介入</p>
<p>两阶段提交需解决的问题：</p>
<ul>
<li>性能问题：需要多次网络通信，资源需要等待并锁定</li>
<li>新协调者：如何确定状态选出新协调者</li>
<li>Commit阶段网络分区带来的数据不一致：非所有节点都收到Commit请求</li>
</ul>
<h4 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h4><ul>
<li>针对两阶段提交的补充，将两阶段提交中的Prepare阶段，拆成两部分：CanCommit和PreCommit机制</li>
<li>CanCommit阶段：询问是否可以执行；PreCommit阶段：重新确认是否可以执行</li>
<li>DoCommit阶段：向所有人提交事务</li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC：多版本并发控制的方法。维持一个数据的多个版本使读写操作没有冲突。所以既不会阻塞写，也不阻塞读。提高并发性能的同时也解决了脏读的问题。</p>
<p>悲观锁和乐观锁</p>
<ul>
<li>悲观锁：操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据</li>
<li>乐观锁：不会上锁，只是在执行更新时判断别人是否修改数据，只有冲突时才放弃操作</li>
</ul>
<p>版本的选取：使用物理时钟或逻辑时钟</p>
<ul>
<li>物理时钟：提供TrueTime API，有Master节点维持一个绝对时间，保证各个服务器之间时钟误差控制在ϵ内，通常ϵ&lt;7ms。</li>
<li>逻辑时钟：中心化授时的方式–时间戳预言机（TSO），好处是无需硬件的支持</li>
</ul>
<h2 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h2><p>架构概览：</p>
<ul>
<li>网关</li>
<li>服务配置和治理</li>
<li>链路追踪和监控</li>
</ul>
<p>三大要素：</p>
<ul>
<li>服务治理<ul>
<li>服务注册</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>扩缩容</li>
<li>流量治理</li>
<li>稳定性治理</li>
</ul>
</li>
<li>可观测性<ul>
<li>日志采集</li>
<li>日志分析</li>
<li>监控打点</li>
<li>监控大盘</li>
<li>异常报警</li>
<li>链路追踪</li>
</ul>
</li>
<li>安全<ul>
<li>身份验证</li>
<li>认证授权</li>
<li>访问令牌</li>
<li>审计</li>
<li>传输加密</li>
<li>黑产攻击</li>
</ul>
</li>
</ul>
<h3 id="架构原理及特征"><a href="#架构原理及特征" class="headerlink" title="架构原理及特征"></a>架构原理及特征</h3><h4 id="服务注册及服务发现"><a href="#服务注册及服务发现" class="headerlink" title="服务注册及服务发现"></a>服务注册及服务发现</h4><ul>
<li><p>基本问题</p>
<ul>
<li>服务间调用中，如何指定下游服务实例的地址？</li>
</ul>
</li>
<li><p>简单方案</p>
<ul>
<li>直接指定 ip:port？<ul>
<li>没有任何动态能力</li>
<li>有多个实例下游实例怎么办？</li>
</ul>
</li>
<li>使用 DNS？<ul>
<li>本地 DNS 存在缓存，导致延迟</li>
<li>DNS 没有负载均衡</li>
<li>不支持服务探活检查</li>
<li>DNS 不能指定端口</li>
</ul>
</li>
</ul>
</li>
<li><p>服务注册发现</p>
<ul>
<li>新增一个统一的服务注册中心，用于存储服务名到服务实例之间的映射关系</li>
<li>旧服务实例下线前，从服务注册中心删除该实例，下线流量</li>
<li>新服务实例上线后，在服务注册中心注册该实例，上线流量</li>
</ul>
</li>
<li><p>微服务流量特征</p>
<ul>
<li>统一网关入口</li>
<li>外网通信多数采用 HTTP，内网通信多数采用 RPC（Thrift, gRPC）</li>
</ul>
</li>
</ul>
<h3 id="核心服务治理功能"><a href="#核心服务治理功能" class="headerlink" title="核心服务治理功能"></a>核心服务治理功能</h3><h4 id="服务发布"><a href="#服务发布" class="headerlink" title="服务发布"></a>服务发布</h4><ul>
<li><p>何为服务发布</p>
<ul>
<li>让一个服务升级运行新的代码的过程</li>
</ul>
</li>
<li><p>服务发布难点</p>
<ul>
<li>服务不可用</li>
<li>服务抖动</li>
<li>服务回滚</li>
</ul>
</li>
<li><p>蓝绿部署</p>
<ul>
<li>将服务分成两个部分，分别先后发布</li>
<li>简单、稳定</li>
<li>但需要两倍资源</li>
</ul>
</li>
<li><p>灰度发布（金丝雀发布）</p>
<ul>
<li>先发布少部分实例，接着逐步增加发布比例</li>
<li>不需要增加资源</li>
<li>回滚难度大，基础设施要求高</li>
</ul>
</li>
</ul>
<h4 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h4><ul>
<li><p>流量控制</p>
<ul>
<li>在微服务架构中，可以从各个维度对端到端的流量在链路上进行精确控制</li>
</ul>
</li>
<li><p>控制维度</p>
<ul>
<li>地区维度</li>
<li>集群维度</li>
<li>实例维度</li>
<li>请求维度</li>
</ul>
</li>
</ul>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul>
<li><p>Round Robin</p>
</li>
<li><p>Random</p>
</li>
<li><p>Ring Hash</p>
</li>
<li><p>Least Request</p>
</li>
</ul>
<h4 id="稳定性治理"><a href="#稳定性治理" class="headerlink" title="稳定性治理"></a>稳定性治理</h4><ul>
<li><p>限流</p>
<ul>
<li>限制服务处理的最大 QPS，拒绝过多请求</li>
</ul>
</li>
<li><p>熔断</p>
<ul>
<li>中断请求路径，增加冷却时间从而让故障实例尝试恢复</li>
</ul>
</li>
<li><p>过载保护</p>
<ul>
<li>在负载高的实例中，主动拒绝一部分请求，防止实例被打挂</li>
</ul>
</li>
<li><p>降级</p>
<ul>
<li>服务处理能力不足时，拒绝低级别的请求，只响应线上高优请求</li>
</ul>
</li>
</ul>
<h2 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h2><p>发展历史：</p>
<ul>
<li><p>Linux命令-CronJob</p>
</li>
<li><p>单机定时任务-Timer、Ticker</p>
</li>
<li><p>单机定时任务-ScheduledExecutorService</p>
</li>
<li><p>任务调度- Quartz</p>
</li>
<li><p>分布式定时任务</p>
</li>
</ul>
<p>业内流行框架：</p>
<ul>
<li>美团点评Xxl-job</li>
<li>阿里巴巴SchedulerX</li>
<li>腾讯TCT</li>
</ul>
<p>两种方案：</p>
<ul>
<li>触发器（腾讯、字节）</li>
<li>时间轮（Quartz）</li>
</ul>
<p>业务应用：</p>
<ul>
<li>业务应用<ul>
<li>所有需要定时、延时、周期性执行任务的业务场景，都可以考虑使用分布式定时任务</li>
</ul>
</li>
<li>知识面扩充<ul>
<li>分布式定时任务</li>
<li>单机定时任务</li>
<li>延时消息</li>
<li>离线计算引擎Hive</li>
<li>实时计算引擎Flink</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法设计</title>
    <url>/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="1-整数反转"><a href="#1-整数反转" class="headerlink" title="1.整数反转"></a>1.整数反转</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [$−2^{31}$,  $2^{31}$ − $1$] ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p><strong>思路</strong></p>
<p>尝试使用构造字符串或者栈处理，但是题设环境不允许存储64位整数，最终无法判断是否在32位整数范围内。</p>
<p>数学方法解决，证明参考LeetCode官方题解</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//反转后的数</span></span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//判断ans是否超出范围</span></span><br><span class="line">            <span class="keyword">if</span>(ans&lt;Integer.MIN_VALUE/<span class="number">10</span>||ans&gt;Integer.MAX_VALUE/<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> tmp=x%<span class="number">10</span>;<span class="comment">//取模，即取个位数</span></span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">            ans=ans*<span class="number">10</span>+tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-加一"><a href="#2-加一" class="headerlink" title="2.加一"></a>2.加一</h2><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>思路</strong></p>
<p>数组末尾加一，判断是否有进位，若有则进位，若无则直接返回，以此类推。</p>
<p>注意：加一后有可能位数不变，也有可能位数加一，需要特殊处理</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="type">int</span> n=digits.length;</span><br><span class="line">        digits[n-<span class="number">1</span>]+=<span class="number">1</span>;<span class="comment">//末位加一</span></span><br><span class="line">        <span class="type">int</span> carry=<span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> tmp=digits[i]+carry;<span class="comment">//本位+进位</span></span><br><span class="line">            carry=tmp/<span class="number">10</span>;<span class="comment">//向前进位</span></span><br><span class="line">            digits[i]=tmp%<span class="number">10</span>;<span class="comment">//本位</span></span><br><span class="line">            <span class="comment">//判断是否还有进位，若无，则退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(carry==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry==<span class="number">0</span>) <span class="keyword">return</span> digits;<span class="comment">//carry=0，说明位数没有改变</span></span><br><span class="line">        <span class="type">int</span>[] ans=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(digits,<span class="number">0</span>,ans,<span class="number">1</span>,n);<span class="comment">//位数改变处理</span></span><br><span class="line">        ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-两数之和"><a href="#3-两数之和" class="headerlink" title="3.两数之和"></a>3.两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code>  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>思路</strong></p>
<p>使用哈希表，键为<code>nums[i]</code>，值为对应索引<code>i</code>，遍历数组，若哈希表中已经存在<code>target-nums[i]</code>，说明已经找到有效答案，若无，则将该键值对插入表中。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//判读表中是否包含target-nums[i]</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,map.get(target-nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);<span class="comment">//加入哈希表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];<span class="comment">//无有效答案，返回空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-所有奇数长度子数组的和"><a href="#4-所有奇数长度子数组的和" class="headerlink" title="4.所有奇数长度子数组的和"></a>4.所有奇数长度子数组的和</h2><p>给你一个正整数数组 <code>arr</code> ，请你计算所有可能的奇数长度子数组的和。</p>
<p><strong>子数组</strong> 定义为原数组中的一个连续子序列。</p>
<p>请你返回 <code>arr</code> 中 <strong>所有奇数长度子数组的和</strong> 。</p>
<p><strong>思路</strong></p>
<p><strong>方法一.前缀和</strong></p>
<p>计算前缀和，以<code>len=1</code>为起始间隔，每次<code>len+2</code>，依次累加求和。</p>
<p><strong>代码</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOddLengthSubarrays</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=arr.length;</span><br><span class="line">        <span class="type">int</span>[] pre=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        pre[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            pre[i+<span class="number">1</span>]=pre[i]+arr[i];<span class="comment">//前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;i+len&lt;=n;len+=<span class="number">2</span>)&#123;</span><br><span class="line">                sum+=pre[i+len]-pre[i];<span class="comment">//累加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二.数学</strong></p>
<p>摘自LeetCode</p>
<p><img src="/./%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/1.jpg"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOddLengthSubarrays</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> left=i,right=n-i-<span class="number">1</span>;<span class="comment">//左、右个数</span></span><br><span class="line">            <span class="type">int</span> l_o=(left+<span class="number">1</span>)/<span class="number">2</span>,r_o=(right+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//两侧奇数</span></span><br><span class="line">            <span class="type">int</span> l_e=left/<span class="number">2</span>+<span class="number">1</span>,r_e=right/<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//两侧偶数</span></span><br><span class="line">            sum+=arr[i]*(l_o*r_o+l_e*r_e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="1-图的基本应用"><a href="#1-图的基本应用" class="headerlink" title="1. 图的基本应用"></a>1. 图的基本应用</h2><h3 id="1-1-找到小镇的法官"><a href="#1-1-找到小镇的法官" class="headerlink" title="1.1 找到小镇的法官"></a>1.1 找到小镇的法官</h3><p>小镇里有 <code>n</code> 个人，按从 <code>1</code> 到 <code>n</code> 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。</p>
<p>如果小镇法官真的存在，那么：</p>
<ol>
<li>小镇法官不会信任任何人。</li>
<li>每个人（除了小镇法官）都信任这位小镇法官。</li>
<li>只有一个人同时满足属性 <strong>1</strong> 和属性 <strong>2</strong> 。</li>
</ol>
<p>给你一个数组 <code>trust</code> ，其中 <code>trust[i] = [ai, bi]</code> 表示编号为 <code>ai</code> 的人信任编号为 <code>bi</code> 的人。</p>
<p>如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 <code>-1</code> 。</p>
<p><strong>思路</strong></p>
<blockquote>
<p>在有向图中，一个节点的入度是指向该节点的边的数量；而一个节点的出度是从该节点出发的边的数量。</p>
</blockquote>
<p><code>ai-&gt;bi</code>相当于一条边，从<code>ai</code>指向<code>bi</code>，那么<code>ai</code>的出度加一，<code>bi</code>的入度加一，那么小镇法官应满足：</p>
<ul>
<li>入度为<code>n-1</code>(即所有人都信任法官)</li>
<li>出度为<code>0</code>(即法官不信任任何人)</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findJudge</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] trust)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] indegree=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] outdegree=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 出度、入度统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:trust)&#123;</span><br><span class="line">            ++outdegree[edge[<span class="number">0</span>]];</span><br><span class="line">            ++indegree[edge[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">// 判断是否为法官</span></span><br><span class="line">            <span class="keyword">if</span>(outdegree[i]==<span class="number">0</span>&amp;&amp;indegree[i]==n-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-最大网络秩"><a href="#1-2-最大网络秩" class="headerlink" title="1.2 最大网络秩"></a>1.2 最大网络秩</h3><p><code>n</code> 座城市和一些连接这些城市的道路 <code>roads</code> 共同组成一个基础设施网络。每个 <code>roads[i] = [ai, bi]</code> 都表示在城市 <code>ai</code> 和 <code>bi</code> 之间有一条双向道路。</p>
<p>两座不同城市构成的 <strong>城市对</strong> 的 <strong>网络秩</strong> 定义为：与这两座城市 <strong>直接</strong> 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 <strong>一次</strong> 。</p>
<p>整个基础设施网络的 <strong>最大网络秩</strong> 是所有不同城市对中的 <strong>最大网络秩</strong> 。</p>
<p>给你整数 <code>n</code> 和数组 <code>roads</code>，返回整个基础设施网络的 <strong>最大网络秩</strong> 。</p>
<p><strong>思路</strong></p>
<blockquote>
<p>在有向图中，每个点的度数等于其入度与出度之和；在无向图中，每个点的度数等于与其相连的边的数量。</p>
</blockquote>
<p>直观思路：暴力枚举每个城市的度数，然后依次选取两个城市进行比较得出最大网络秩，满足条件为：</p>
<ul>
<li>若两个城市之间有道路相连，那么它们的网络秩为<code>degree[i]+degree[j]-1</code></li>
<li>若两个城市之间没有道路相连，那么它们的网络秩为<code>degree[i]+degree[j]</code></li>
</ul>
<p>依次比较得出最大值即可。</p>
<p>贪心思路：要求最大网络秩，只需要考虑度数最大以及度数次大的城市即可。</p>
<p>不妨设度数最大值为<code>first</code>，度数次大值为<code>second</code>，图中可能存在多个城市度数值等于<code>first</code>或<code>second</code>，那么我们设所有度数值等于最大值的城市构成一个集合<code>firstAttr</code>，所有度数值等于次大值的城市构成一个集合<code>secondAttr</code>，接下来求最大网络秩，我们只需在这两个集合内考虑即可，分为以下几种情况讨论：</p>
<ul>
<li>若<code>firstAttr.size()==1</code>，考虑到<code>first&gt;=second+1 -&gt; first+second-1&gt;=second+second</code>，即在<code>secondAttr</code>中选取两个城市组成的网络秩大小不可能超过在这两个集合中分别选取一个，那么我们必须选取<code>firstAttr</code>中的唯一城市，然后在<code>secondAttr</code>中依次枚举，寻找是否有不与该城市直接相连的城市，若有，则返回<code>first+second</code>；否则返回<code>first+second-1</code>；</li>
<li>若<code>firstAttr.size()&gt;1</code>，考虑到<code>first&gt;=second+1 -&gt; first+first-1&gt;=first+second&gt;second+second</code>，即在<code>firstAttr</code>集合中选择两个城市组成的网络秩最大，设<code>m</code>为城市道路总数，考虑；<ul>
<li>若<code>firstAttr.size()*(firstAttr.size()-1)/2&gt;m</code>，即任意选择两个城市组成的道路总数大于现有道路总数，说明此时一定存在两个城市，它们之间没有道路相连，最大网络秩为<code>first+first</code>；</li>
<li>反之，则枚举集合中的城市，依次选择两个城市，判断是否有道路相连，若无，则返回<code>first+first</code>；否则返回<code>first+first-1</code>。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalNetworkRank</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] roads)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] connect=<span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">int</span>[] degree=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] road:roads)&#123;</span><br><span class="line">            <span class="type">int</span> x=road[<span class="number">0</span>],y=road[<span class="number">1</span>];</span><br><span class="line">            degree[x]++;</span><br><span class="line">            degree[y]++;</span><br><span class="line">            connect[x][y]=<span class="literal">true</span>;</span><br><span class="line">            connect[y][x]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> first=-<span class="number">1</span>,second=-<span class="number">2</span>;</span><br><span class="line">        List&lt;Integer&gt; firstAttr=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; secondAttr=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i]&gt;first)&#123;<span class="comment">// 若度数大于first，更新first</span></span><br><span class="line">                second=first;<span class="comment">// first自然变为了second</span></span><br><span class="line">                secondAttr=<span class="keyword">new</span> <span class="title class_">ArrayList</span>(firstAttr);<span class="comment">// 更新secondAttr</span></span><br><span class="line">                firstAttr.clear();</span><br><span class="line">                firstAttr.add(i);</span><br><span class="line">                first=degree[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(degree[i]==first)&#123;</span><br><span class="line">                firstAttr.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(degree[i]&gt;second)&#123;<span class="comment">// 更新second</span></span><br><span class="line">                secondAttr.clear();</span><br><span class="line">                secondAttr.add(i);</span><br><span class="line">                second=degree[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(degree[i]==second)&#123;</span><br><span class="line">                secondAttr.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(firstAttr.size()==<span class="number">1</span>)&#123;<span class="comment">// firstAttr仅有一个城市，必须选择</span></span><br><span class="line">            <span class="type">int</span> u=firstAttr.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 枚举</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:secondAttr)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!connect[u][v])&#123;</span><br><span class="line">                    <span class="keyword">return</span> first+second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> first+second-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> m=roads.length;</span><br><span class="line">            <span class="keyword">if</span>(firstAttr.size()*(firstAttr.size()-<span class="number">1</span>)/<span class="number">2</span>&gt;m)&#123;<span class="comment">// 判断是否一定存在两个城市不相连</span></span><br><span class="line">                <span class="keyword">return</span> first*<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 枚举</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> u:firstAttr)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> v:firstAttr)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(u!=v&amp;&amp;!connect[u][v])&#123;</span><br><span class="line">                            <span class="keyword">return</span> first*<span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> first*<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-图遍历及其应用"><a href="#2-图遍历及其应用" class="headerlink" title="2. 图遍历及其应用"></a>2. 图遍历及其应用</h2><h3 id="2-1-岛屿数量"><a href="#2-1-岛屿数量" class="headerlink" title="2.1 岛屿数量"></a>2.1 岛屿数量</h3><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索或广度优先搜索，每次遇到<code>&#39;1&#39;</code>则从该点出发遍历图，将<code>&#39;1&#39;</code>置为<code>&#39;0&#39;</code>，岛屿个数加一。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=grid.length,m=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    num+=dfs(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> cur_x,<span class="type">int</span> cur_y)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(cur_x&lt;<span class="number">0</span>||cur_y&lt;<span class="number">0</span>||cur_x&gt;=grid.length||cur_y&gt;=grid[<span class="number">0</span>].length||grid[cur_x][cur_y]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[cur_x][cur_y]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 四个方向遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=cur_x+dx[i],y=cur_y+dy[i];</span><br><span class="line">            dfs(grid,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-判断二分图"><a href="#2-2-判断二分图" class="headerlink" title="2.2 判断二分图"></a>2.2 判断二分图</h3><p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p>
<ul>
<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>
<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>
<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>
<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>
</ul>
<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>
<p>如果图是二分图，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>思路</strong></p>
<p>采用三色标记法，对当前节点进行颜色标记，然后以从该节点开始遍历图，若相邻节点未被标记，那么将其标记上不同的颜色；若相邻节点已被标记，判断其颜色是否和当前节点颜色相同，若相同，返回<code>false</code>；若不同，则继续遍历。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=graph.length;</span><br><span class="line">        <span class="type">int</span>[] color=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 判断当前节点是否被标记及合理性</span></span><br><span class="line">            <span class="keyword">if</span>(color[i]==<span class="number">0</span>&amp;&amp;!dfs(graph,i,<span class="number">1</span>,color))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph,<span class="type">int</span> u,<span class="type">int</span> c_color,<span class="type">int</span>[] color)</span>&#123;</span><br><span class="line">        color[u]=c_color;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ed:graph[u])&#123;</span><br><span class="line">            <span class="comment">// 相邻节点颜色相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(color[ed]==color[u])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 未被标记，递归遍历</span></span><br><span class="line">            <span class="keyword">if</span>(color[ed]==<span class="number">0</span>&amp;&amp;!dfs(graph,ed,<span class="number">3</span>^c_color,color))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-被围绕的区域"><a href="#2-3-被围绕的区域" class="headerlink" title="2.3 被围绕的区域"></a>2.3 被围绕的区域</h3><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p><strong>思路</strong></p>
<p>从边界开始遍历，若遇到<code>&#39;O&#39;</code>则将其置为<code>&#39;1&#39;</code>，并从该节点开始遍历图。</p>
<p>这样处理后，所有与边界相接的<code>&#39;O&#39;</code>均变为了<code>&#39;1&#39;</code>，而对于图中的其它<code>&#39;O&#39;</code>，由于其未与边界相接，即都被<code>&#39;X&#39;</code>包围，将其置为<code>&#39;X&#39;</code>即可，对于<code>&#39;1&#39;</code>，则将其还原为<code>&#39;O&#39;</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=board.length,m=board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 边界处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dfs(board,i,<span class="number">0</span>);</span><br><span class="line">            dfs(board,i,m-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            dfs(board,<span class="number">0</span>,j);</span><br><span class="line">            dfs(board,n-<span class="number">1</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="comment">// 还原变换</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j]=<span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=board.length||y&gt;=board[<span class="number">0</span>].length||board[x][y]!=<span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        dfs(board,x+<span class="number">1</span>,y);</span><br><span class="line">        dfs(board,x,y+<span class="number">1</span>);</span><br><span class="line">        dfs(board,x-<span class="number">1</span>,y);</span><br><span class="line">        dfs(board,x,y-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-二进制矩阵中的最短路径"><a href="#2-4-二进制矩阵中的最短路径" class="headerlink" title="2.4 二进制矩阵中的最短路径"></a>2.4 二进制矩阵中的最短路径</h3><p>给你一个 <code>n x n</code> 的二进制矩阵 <code>grid</code> 中，返回矩阵中最短 <strong>畅通路径</strong> 的长度。如果不存在这样的路径，返回 <code>-1</code> 。</p>
<p>二进制矩阵中的 畅通路径 是一条从 <strong>左上角</strong> 单元格（即，<code>(0, 0)</code>）到 右下角 单元格（即，<code>(n - 1, n - 1)</code>）的路径，该路径同时满足下述要求：</p>
<ul>
<li>路径途经的所有单元格都的值都是 <code>0</code> 。</li>
<li>路径中所有相邻的单元格应当在 <strong>8 个方向之一</strong> 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li>
</ul>
<p><strong>畅通路径的长度</strong> 是该路径途经的单元格总数。</p>
<p> <strong>思路</strong></p>
<p>广度优先搜索，每次遍历一层，直到到达右下角。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathBinaryMatrix</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// 8个方向</span></span><br><span class="line">        <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n=grid.length;</span><br><span class="line">        <span class="comment">// 判断左上角与右下角是否为1</span></span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>||grid[n-<span class="number">1</span>][n-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; hep=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        hep.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> s=hep.size();</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="type">int</span>[] p=hep.poll();</span><br><span class="line">                <span class="comment">// 若到达右下角，返回路径长度</span></span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">0</span>]==n-<span class="number">1</span>&amp;&amp;p[<span class="number">1</span>]==n-<span class="number">1</span>) <span class="keyword">return</span> step;</span><br><span class="line">                <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">                    <span class="type">int</span> x=dx[j]+p[<span class="number">0</span>],y=dy[j]+p[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=n||y&gt;=n||grid[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    grid[x][y]=<span class="number">1</span>;</span><br><span class="line">                    hep.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-腐烂的橘子"><a href="#2-5-腐烂的橘子" class="headerlink" title="2.5 腐烂的橘子"></a>2.5 腐烂的橘子</h3><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>
<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
<p> <strong>思路</strong></p>
<p>广度优先搜索，首先将所有腐烂的橘子入队，然后进行广度优先搜索，最后判断新鲜橘子个数是否为<code>0</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// 四个方向</span></span><br><span class="line">        <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n=grid.length,m=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 新鲜橘子个数</span></span><br><span class="line">        <span class="type">int</span> fr=<span class="number">0</span>;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; hep=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;<span class="comment">// 腐烂橘子入队</span></span><br><span class="line">                    hep.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;<span class="comment">// 新鲜橘子个数加一</span></span><br><span class="line">                    fr++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无新鲜橘子，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(fr==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩散时间</span></span><br><span class="line">        <span class="type">int</span> minutes=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> s=hep.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="type">int</span>[] p=hep.poll();</span><br><span class="line">                <span class="comment">// 广度优先搜索</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                    <span class="type">int</span> x=p[<span class="number">0</span>]+dx[j],y=p[<span class="number">1</span>]+dy[j];</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=n||y&gt;=m||grid[x][y]!=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 新鲜橘子腐烂，个数减一</span></span><br><span class="line">                    fr--;</span><br><span class="line">                    grid[x][y]=<span class="number">2</span>;</span><br><span class="line">                    hep.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minutes++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否还有剩余的新鲜橘子</span></span><br><span class="line">        <span class="comment">// 若有，返回-1；反之返回minutes</span></span><br><span class="line">        <span class="keyword">return</span> fr==<span class="number">0</span>?minutes:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-6-01-矩阵"><a href="#2-6-01-矩阵" class="headerlink" title="2.6 01 矩阵"></a>2.6 01 矩阵</h3><p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code> ，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>
<p>两个相邻元素间的距离为 <code>1</code> 。</p>
<p><strong>思路</strong></p>
<p>动态规划，当前位置到最近<code>0</code>的距离即为从左、上或右、下位置到最近<code>0</code>的距离加一，状态转移方程：</p>
<blockquote>
<p> <code>dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i+1][j],dp[i][j+1])</code></p>
</blockquote>
<p>初始化，若当前位置为<code>0</code>，那么其距离即为<code>0</code>，若当前位置为<code>1</code>，则将其初始化为一个较大的数。</p>
<p>求解时，注意边界范围。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] mat) &#123;</span><br><span class="line">        <span class="type">int</span> n=mat.length,m=mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="comment">// 初始化较大数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i],INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若为0，则置0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左、上方进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i-<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右、下方进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i+<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i][j+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-7-最短的桥"><a href="#2-7-最短的桥" class="headerlink" title="2.7 最短的桥"></a>2.7 最短的桥</h3><p>给你一个大小为 <code>n x n</code> 的二元矩阵 <code>grid</code> ，其中 <code>1</code> 表示陆地，<code>0</code> 表示水域。</p>
<p><strong>岛</strong> 是由四面相连的 <code>1</code> 形成的一个最大组，即不会与非组内的任何其他 <code>1</code> 相连。<code>grid</code> 中 <strong>恰好存在两座岛</strong> 。</p>
<p>你可以将任意数量的 <code>0</code> 变为 <code>1</code> ，以使两座岛连接起来，变成 <strong>一座岛</strong> 。</p>
<p>返回必须翻转的 <code>0</code> 的最小数目。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索+广度优先搜索，首先找到其中一座岛，并通过深度优先搜索将其坐标位置加入队列中，遍历完后，进行广度优先搜索，若找到了陆地，则说明到达了另一座岛，返回翻转<code>0</code>的数目。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;<span class="type">int</span>[]&gt; cnt=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=grid.length;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    <span class="comment">// 广度优先搜索</span></span><br><span class="line">                    <span class="keyword">while</span>(!cnt.isEmpty())&#123;</span><br><span class="line">                        <span class="type">int</span> sz=cnt.size();</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;sz;k++)&#123;</span><br><span class="line">                            <span class="type">int</span>[] p=cnt.poll();</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">0</span>;h&lt;<span class="number">4</span>;h++)&#123;</span><br><span class="line">                                <span class="type">int</span> x=p[<span class="number">0</span>]+dx[h],y=p[<span class="number">1</span>]+dy[h];</span><br><span class="line">                                <span class="comment">// 判断是否越界</span></span><br><span class="line">                                <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=n||y&gt;=n)&#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(grid[x][y]==<span class="number">0</span>)&#123;<span class="comment">// 为0则加入队列</span></span><br><span class="line">                                    cnt.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                                    grid[x][y]=-<span class="number">1</span>;</span><br><span class="line">                                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[x][y]==<span class="number">1</span>)&#123;<span class="comment">// 为1说明已经找到了另一座岛，返回num</span></span><br><span class="line">                                    <span class="keyword">return</span> num;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 翻转0的数目加一</span></span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深度优先搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=grid.length||y&gt;=grid[<span class="number">0</span>].length||grid[x][y]!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y]=<span class="number">0</span>;</span><br><span class="line">        cnt.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">        dfs(grid,x+<span class="number">1</span>,y);</span><br><span class="line">        dfs(grid,x,y+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,x-<span class="number">1</span>,y);</span><br><span class="line">        dfs(grid,x,y-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-8-所有可能的路径"><a href="#2-8-所有可能的路径" class="headerlink" title="2.8 所有可能的路径"></a>2.8 所有可能的路径</h3><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索+回溯，考虑当前节点，将其加入后，进行深度优先搜索继续遍历，若最终未到达节点<code>n-1</code>，则回溯，选取下一个节点继续遍历。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="comment">// 先将0加入数组tmp中</span></span><br><span class="line">        tmp.add(<span class="number">0</span>);</span><br><span class="line">        dfs(graph,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">// 若v==graph.length-1，则将tmp加入目标数组中</span></span><br><span class="line">        <span class="keyword">if</span>(v==graph.length-<span class="number">1</span>)&#123;</span><br><span class="line">            cnt.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u:graph[v])&#123;</span><br><span class="line">            <span class="comment">// 加入节点</span></span><br><span class="line">            tmp.add(u);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            dfs(graph,u);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-最小生成树"><a href="#3-最小生成树" class="headerlink" title="3. 最小生成树"></a>3. 最小生成树</h2><h3 id="3-1-连接所有点的最小费用"><a href="#3-1-连接所有点的最小费用" class="headerlink" title="3.1 连接所有点的最小费用"></a>3.1 连接所有点的最小费用</h3><p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi]</code> 。</p>
<p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>|xi - xj| + |yi - yj|</code>  ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p>
<p><strong>思路</strong></p>
<p>Prim 算法或 Kruskal 算法。</p>
<p>算法：<a href="https://oi-wiki.org/graph/mst/">https://oi-wiki.org/graph/mst/</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=points.length;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出所有边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> x1=points[i][<span class="number">0</span>],y1=points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> x2=points[j][<span class="number">0</span>],y2=points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> weight=Math.abs(x1-x2)+Math.abs(y1-y2);</span><br><span class="line">                graph[i].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j,weight&#125;);</span><br><span class="line">                graph[j].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;j,i,weight&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; cnt=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; (a[<span class="number">2</span>]-b[<span class="number">2</span>]));</span><br><span class="line">        <span class="type">boolean</span>[] vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="comment">// 将第0个点的边加入优先队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] ed:graph[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">// 若节点已经添加过，则continue</span></span><br><span class="line">            <span class="keyword">if</span>(vis[ed[<span class="number">1</span>]])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.add(ed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记节点已被添加</span></span><br><span class="line">        vis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!cnt.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] p=cnt.poll();</span><br><span class="line">            <span class="type">int</span> to=p[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> weight=p[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 若节点被添加过，continue</span></span><br><span class="line">            <span class="keyword">if</span>(vis[to])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加当前节点，并更新最小代价</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] ed:graph[to])&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[ed[<span class="number">1</span>]])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt.add(ed);</span><br><span class="line">            &#125;</span><br><span class="line">            vis[to]=<span class="literal">true</span>;</span><br><span class="line">            ans+=weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-冗余连接"><a href="#3-2-冗余连接" class="headerlink" title="3.2 冗余连接"></a>3.2 冗余连接</h3><p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong> 图。</p>
<p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code> 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code> ，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组 <code>edges</code> 中最后出现的边。</p>
<p><strong>思路</strong></p>
<p>并查集，初始时，每个节点都属于不同的集合，依次遍历边集，更新节点所属集合，若发现两个节点属于同一集合，则说明改边是多余边。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> n=edges.length;</span><br><span class="line">        <span class="type">int</span>[] parent=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 并查集初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历边集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:edges)&#123;</span><br><span class="line">            <span class="type">int</span> x=edge[<span class="number">0</span>],y=edge[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 若两者属于不同集合，合并</span></span><br><span class="line">            <span class="keyword">if</span>(find(parent,x)!=find(parent,y))&#123;</span><br><span class="line">                union(parent,x,y);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 若两者属于同一集合，说明该边多余</span></span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找根节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=parent[x]) parent[x]=find(parent,parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        parent[find(parent,y)]=parent[find(parent,x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-最小体力消耗路径"><a href="#3-3-最小体力消耗路径" class="headerlink" title="3.3 最小体力消耗路径"></a>3.3 最小体力消耗路径</h3><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>
<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>
<p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p>
<p><strong>思路</strong></p>
<p>Dijkstra 算法。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=heights.length;</span><br><span class="line">        <span class="type">int</span> m=heights[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] dx=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; cnt=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; (a[<span class="number">2</span>]-b[<span class="number">2</span>]));</span><br><span class="line">        <span class="type">boolean</span>[] vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n*m];</span><br><span class="line">        <span class="type">int</span>[] dist=<span class="keyword">new</span> <span class="title class_">int</span>[n*m];</span><br><span class="line">        cnt.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        Arrays.fill(dist,Integer.MAX_VALUE);</span><br><span class="line">        dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!cnt.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] p=cnt.poll();</span><br><span class="line">            <span class="type">int</span> x=p[<span class="number">0</span>],y=p[<span class="number">1</span>],w=p[<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> pos=x*m+y;</span><br><span class="line">            <span class="keyword">if</span>(vis[pos])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x==n-<span class="number">1</span>&amp;&amp;y==m-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[pos]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> nx=x+dx[i],ny=y+dy[i];</span><br><span class="line">                <span class="comment">// 更新路径长度</span></span><br><span class="line">                <span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;ny&lt;m&amp;&amp;Math.max(w,Math.abs(heights[nx][ny]-heights[x][y]))&lt;dist[nx*m+ny])&#123;</span><br><span class="line">                    dist[nx*m+ny]=Math.max(w,Math.abs(heights[nx][ny]-heights[x][y]));</span><br><span class="line">                    cnt.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx,ny,dist[nx*m+ny]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[n*m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-最短路径"><a href="#4-最短路径" class="headerlink" title="4. 最短路径"></a>4. 最短路径</h2><h3 id="4-1-网络延迟时间"><a href="#4-1-网络延迟时间" class="headerlink" title="4.1 网络延迟时间"></a>4.1 网络延迟时间</h3><p>有 <code>n</code> 个网络节点，标记为 <code>1</code> 到 <code>n</code>。</p>
<p>给你一个列表 <code>times</code>，表示信号经过 <strong>有向</strong> 边的传递时间。 <code>times[i] = (ui, vi, wi)</code>，其中 <code>ui</code> 是源节点，<code>vi</code> 是目标节点， <code>wi</code> 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 <code>K</code> 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 <code>-1</code> 。</p>
<p> <strong>思路</strong></p>
<p>Dijkstra 算法求出到达所有节点的最短路径，最后比较各个节点的路径长度取最大值得出时间。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">        <span class="comment">// dist初始化</span></span><br><span class="line">        Arrays.fill(dist,INF);</span><br><span class="line">        dist[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; hep=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// 存储图消息</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] time:times)&#123;</span><br><span class="line">            graph[time[<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;time[<span class="number">1</span>],time[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        hep.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,k,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] p=hep.poll();</span><br><span class="line">            <span class="type">int</span> v=p[<span class="number">1</span>],w=p[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] edge:graph[v])&#123;</span><br><span class="line">                <span class="comment">// 更新路径长度</span></span><br><span class="line">                <span class="keyword">if</span>(w+edge[<span class="number">1</span>]&lt;dist[edge[<span class="number">0</span>]])&#123;</span><br><span class="line">                    dist[edge[<span class="number">0</span>]]=w+edge[<span class="number">1</span>];</span><br><span class="line">                    hep.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v,edge[<span class="number">0</span>],dist[edge[<span class="number">0</span>]]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[i]==INF) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            ans=Math.max(ans,dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-阈值距离内邻居最少的城市"><a href="#4-2-阈值距离内邻居最少的城市" class="headerlink" title="4.2 阈值距离内邻居最少的城市"></a>4.2 阈值距离内邻居最少的城市</h3><p>有 <code>n</code> 个城市，按从 <code>0</code> 到 <code>n-1</code> 编号。给你一个边数组 <code>edges</code>，其中 <code>edges[i] = [fromi, toi, weighti]</code> 代表 <code>fromi</code> 和 <code>toi</code> 两个城市之间的双向加权边，距离阈值是一个整数 <code>distanceThreshold</code>。</p>
<p>返回能通过某些路径到达其他城市数目最少、且路径距离 <strong>最大</strong> 为 <code>distanceThreshold</code> 的城市。如果有多个这样的城市，则返回编号最大的城市。</p>
<p>注意，连接城市 <em><strong>i</strong></em> 和 <em><strong>j</strong></em> 的路径的距离等于沿该路径的所有边的权重之和。</p>
<p><strong>思路</strong></p>
<p>Floyd 算法。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTheCity</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> distanceThreshold)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 初始化dp为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i],Integer.MAX_VALUE);</span><br><span class="line">            <span class="comment">// 自身距离为0</span></span><br><span class="line">            dp[i][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据边初始化dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:edges)&#123;</span><br><span class="line">            dp[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]]=edge[<span class="number">2</span>];</span><br><span class="line">            dp[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]]=edge[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Floyd算法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][k]!=Integer.MAX_VALUE&amp;&amp;dp[k][j]!=Integer.MAX_VALUE)</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求阈值距离内邻居最少的城市</span></span><br><span class="line">        <span class="type">int</span> index=-<span class="number">1</span>,count=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&lt;=distanceThreshold)&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=count)&#123;</span><br><span class="line">                count=num;</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-拓扑排序"><a href="#5-拓扑排序" class="headerlink" title="5. 拓扑排序"></a>5. 拓扑排序</h2><h3 id="5-1-课程表"><a href="#5-1-课程表" class="headerlink" title="5.1 课程表"></a>5.1 课程表</h3><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>思路</strong></p>
<p>题意即判断所给是否为有向无环图，通过深度优先搜索判断图中是否有环即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line">        <span class="comment">// 构建图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] prerequisity:prerequisites)&#123;</span><br><span class="line">            graph[prerequisity[<span class="number">1</span>]].add(prerequisity[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] vis=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="comment">// 判断是否有环</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>&amp;&amp;!dfs(graph,i,vis))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt;[] graph,<span class="type">int</span> u,<span class="type">int</span>[] vis)</span>&#123;</span><br><span class="line">        <span class="comment">// 1表示搜索中</span></span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:graph[u])&#123;</span><br><span class="line">            <span class="comment">// 若未被搜索，则搜索该节点</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=dfs(graph,v,vis);</span><br><span class="line">                <span class="comment">// 若出现环，返回false</span></span><br><span class="line">                <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[v]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2表示搜索结束</span></span><br><span class="line">        vis[u]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-课程表-II"><a href="#5-2-课程表-II" class="headerlink" title="5.2 课程表 II"></a>5.2 课程表 II</h3><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p>
<ul>
<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li>
</ul>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>
<p><strong>思路</strong></p>
<p>广度优先搜索+拓扑排序，首先构造图，将入度为 0 的节点加入队列中（入度为 0 即无先修课程），然后依次加入目标数组中，更新图中节点的入度，若入度不为 0 ，不做处理；反之将其加入队列，这样能够保证拓扑排序。</p>
<p>最终比较目标数组大小是否等于课程数，若相等，即所有课程都能够学习；若不等，说明无法满足所有先修课程条件，无法全部学习。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; dq=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="type">int</span>[] indegree=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        List&lt;Integer&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line">        <span class="comment">// 构造图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] pq:prerequisites)&#123;</span><br><span class="line">            graph[pq[<span class="number">1</span>]].add(pq[<span class="number">0</span>]);</span><br><span class="line">            indegree[pq[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="comment">// 入度为0，入队</span></span><br><span class="line">            <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dq.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> u=dq.poll();</span><br><span class="line">            result[index++]=u;</span><br><span class="line">            <span class="comment">// 更新节点入度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:graph[u])&#123;</span><br><span class="line">                --indegree[v];</span><br><span class="line">                <span class="comment">// 入度为0，入队</span></span><br><span class="line">                <span class="keyword">if</span>(indegree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dq.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断index?=numCourses</span></span><br><span class="line">        <span class="comment">// 不等返回空数组</span></span><br><span class="line">        <span class="comment">// 相等返回result</span></span><br><span class="line">        <span class="keyword">return</span> index==numCourses?result:<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3-课程表-IV"><a href="#5-3-课程表-IV" class="headerlink" title="5.3 课程表 IV"></a>5.3 课程表 IV</h3><p>你总共需要上 <code>numCourses</code> 门课，课程编号依次为 <code>0</code> 到 <code>numCourses-1</code> 。你会得到一个数组 <code>prerequisite</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> 你 <strong>必须</strong> 先选 <code>ai</code> 课程。</p>
<ul>
<li>有的课会有直接的先修课程，比如如果想上课程 <code>1</code> ，你必须先上课程 <code>0</code> ，那么会以 <code>[0,1]</code> 数对的形式给出先修课程数对。</li>
</ul>
<p>先决条件也可以是 <strong>间接</strong> 的。如果课程 <code>a</code> 是课程 <code>b</code> 的先决条件，课程 <code>b</code> 是课程 <code>c</code> 的先决条件，那么课程 <code>a</code> 就是课程 <code>c</code> 的先决条件。</p>
<p>你也得到一个数组 <code>queries</code> ，其中 <code>queries[j] = [uj, vj]</code>。对于第 <code>j</code> 个查询，您应该回答课程 <code>uj</code> 是否是课程 <code>vj</code> 的先决条件。</p>
<p>返回一个布尔数组 <code>answer</code> ，其中 <code>answer[j]</code> 是第 <code>j</code> 个查询的答案。</p>
<p><strong>思路</strong></p>
<p>拓扑排序，同题解二，每次更新节点入度时，同时更新节点的先决条件。</p>
<p>先决条件用<code>Set</code>存储可以保证去重。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites, <span class="type">int</span>[][] queries)</span> &#123;</span><br><span class="line">        <span class="comment">// 图</span></span><br><span class="line">        List&lt;Integer&gt;[] graph=<span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line">        <span class="comment">// 先决条件</span></span><br><span class="line">        Set&lt;Integer&gt;[] pre=<span class="keyword">new</span> <span class="title class_">Set</span>[numCourses];</span><br><span class="line">        <span class="comment">// 入度</span></span><br><span class="line">        <span class="type">int</span>[] degree=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            pre[i]=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] pq:prerequisites)&#123;</span><br><span class="line">            graph[pq[<span class="number">0</span>]].add(pq[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 入度加一</span></span><br><span class="line">            degree[pq[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; dq=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dq.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> u=dq.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:graph[u])&#123;</span><br><span class="line">                <span class="comment">// 入度减一</span></span><br><span class="line">                degree[v]--;</span><br><span class="line">                <span class="comment">// v节点的直接先决条件是u，加入u</span></span><br><span class="line">                pre[v].add(u);</span><br><span class="line">                <span class="comment">// v节点的间接先决条件是u的先决条件</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> e:pre[u])&#123;</span><br><span class="line">                    pre[v].add(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(degree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dq.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询query</span></span><br><span class="line">        List&lt;Boolean&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] query:queries)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[query[<span class="number">1</span>]].contains(query[<span class="number">0</span>]))&#123;</span><br><span class="line">                cnt.add(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt.add(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>目的：</p>
<ul>
<li>管理软硬件资源</li>
<li>组织程序运行，提升CPU性能</li>
<li>提供系统调用接口</li>
</ul>
<p>四大功能：</p>
<ul>
<li>进程管理</li>
<li>内存管理</li>
<li>设备管理</li>
<li>文件系统</li>
</ul>
<p>特征：</p>
<ul>
<li>并发性</li>
<li>共享性</li>
<li>虚拟性</li>
<li>随机性</li>
</ul>
<blockquote>
<p>典型操作系统：Windows、Linux、Android、macOS、IOS</p>
</blockquote>
<hr>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>执行方式：</p>
<ul>
<li>顺序执行</li>
<li>并发执行</li>
</ul>
<p>进程：操作系统资源分配、保护和调度的基本单位。</p>
<p>线程：处理器调度和分派的基本单位。</p>
<blockquote>
<p>进程与线程的区别和联系：</p>
<ol>
<li>线程是进程的组成部分，进程通常由多个线程组成</li>
<li>进程是拥有资源的基本单位，线程是调度和分配的基本单位</li>
</ol>
</blockquote>
<p>三态模型：</p>
<ul>
<li>就绪状态：进程在内存中已经具备执行的条件，等待分配CPU</li>
<li>运行状态：进程占用CPU并正在运行</li>
<li>阻塞状态：等待状态</li>
</ul>
<p>PCB：进程控制块，操作系统最重要的数据结构之一，由三部分组成：</p>
<ul>
<li><p>进程标识信息</p>
<ul>
<li>内部标识符：操作系统管理进程时使用</li>
<li>外部标识符：用户访问进程时使用</li>
</ul>
</li>
<li><p>现场信息–执行进程时CPU的即时状态</p>
</li>
<li><p>控制信息</p>
</li>
</ul>
<blockquote>
<p>进程控制方式：核心态（管态）$\longleftrightarrow$ 用户态（目态）</p>
</blockquote>
<p>互斥与同步：</p>
<ul>
<li>死锁：进程陷入无限等待状态，永远无法被执行</li>
<li>饥饿：进程长期不被执行</li>
</ul>
<p>临界资源：某些资源在同一时刻只允许一个进程使用。</p>
<p>同步机制：</p>
<ul>
<li>锁</li>
<li>信号量（P、V原语操作）</li>
<li>管程（临界资源统一管理）</li>
<li>消息传递</li>
</ul>
<blockquote>
<p>经典同步问题：</p>
<ol>
<li>生产者-消费者问题</li>
<li>读者-写者问题</li>
<li>哲学家就餐问题</li>
<li>睡眠理发师问题</li>
</ol>
</blockquote>
<p>进程通信：</p>
<ul>
<li>消息传递</li>
<li>共享内存</li>
<li>管道</li>
</ul>
<p>进程调度算法：</p>
<ul>
<li>先来先服务（FCFS）</li>
<li>短作业优先（SJF）</li>
<li>最短剩余时间优先（SRTF，抢占式）</li>
<li>高响应比优先（HRRF）</li>
<li>优先权（HPF，抢占式）</li>
<li>时间片轮转（RR，抢占式）</li>
<li>多级反馈队列（MFQ）</li>
</ul>
<p>死锁的四个必要条件：</p>
<ol>
<li>互斥条件：资源的使用是互斥的</li>
<li>请求与保持条件：进程请求资源时若无法得到，已得到的资源也不会释放</li>
<li>不剥夺条件：只能由进程自身主动释放资源，系统或其他进程不能剥夺</li>
<li>环路等待条件：若干进程形成环路，每个进程都在等待资源，形成永远等待</li>
</ol>
<blockquote>
<p>死锁的避免：银行家算法</p>
</blockquote>
<p>死锁的检测与解除：</p>
<ul>
<li>重启</li>
<li>撤销（撤销进程）</li>
<li>剥夺（再分配资源）</li>
<li>回滚（回退）</li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存分为两块区域：</p>
<ul>
<li>系统区–操作系统</li>
<li>用户区–内存管理</li>
</ul>
<p>功能：</p>
<ol>
<li>内存的分配和回收</li>
<li>实现地址转换</li>
<li>内存的共享和保护</li>
<li>内存扩充</li>
</ol>
<p>地址转换：</p>
<ul>
<li><p>静态重定位</p>
<ul>
<li>实现简单，无需硬件支持</li>
<li>必须为程序分配一段连续的存储空间，程序执行过程中不能在内存中移动</li>
</ul>
</li>
<li><p>动态重定位</p>
<ul>
<li>内存使用更灵活，容易实现内存的动态扩充和共享</li>
<li>需要硬件支持，内存管理更加复杂</li>
</ul>
</li>
</ul>
<p>分区内存管理（连续）：</p>
<ul>
<li>单一连续内存管理（单用户单任务）</li>
<li>固定分区内存管理（多道程序并发设计）</li>
<li>可变分区内存管理</li>
</ul>
<p>页式存储管理（非连续）：</p>
<ul>
<li><p>页 $\longleftrightarrow$ 物理块</p>
</li>
<li><p>页表：存储页号与物理块号的对应关系</p>
</li>
<li><p>快表：高速缓冲处理器</p>
</li>
</ul>
<p>段式存储管理（非连续）</p>
<blockquote>
<p>分段和分页的比较：</p>
<ul>
<li><p>段</p>
<ul>
<li>信息的逻辑单位，由源程序的逻辑结构决定，用户可见</li>
<li>段长可由用户规定</li>
<li>段起始地址可以为任何地址</li>
<li>源程序经连接装配后仍保持二维结构</li>
</ul>
</li>
<li><p>页</p>
<ul>
<li>信息的物理单位，与源程序的逻辑结构无关，用户不可见</li>
<li>页长由系统确定</li>
<li>页面只能以页大小的整数倍地址开始</li>
<li>源程序经连接装配后为一维结构</li>
</ul>
</li>
</ul>
</blockquote>
<p>虚拟存储技术：外存作为内存的扩充。</p>
<hr>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>功能：</p>
<ol>
<li>设备的分配与回收</li>
<li>缓冲区管理</li>
<li>设备控制和中断处理</li>
<li>实现虚拟设备</li>
</ol>
<p>控制方法：</p>
<ul>
<li>程序循环查询</li>
<li>中断驱动</li>
<li>直接内存（DMA）</li>
<li>通道方式（I&#x2F;O通道）</li>
</ul>
<p>缓冲技术：</p>
<ul>
<li><p>改善中央处理器与外部设备之间速度不匹配的矛盾</p>
</li>
<li><p>减少I&#x2F;O对CPU的中断次数，放宽对CPU中断响应时间的要求</p>
</li>
<li><p>协调逻辑记录大小与物理记录大小不一致的问题</p>
</li>
</ul>
<hr>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件分类：</p>
<ul>
<li><p>逻辑结构</p>
<ul>
<li>流式文件</li>
<li>记录式文件</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li>系统文件</li>
<li>库文件</li>
<li>用户文件</li>
</ul>
</li>
<li><p>性质</p>
<ul>
<li>普通文件</li>
<li>目录文件</li>
<li>特殊文件</li>
</ul>
</li>
</ul>
<p>物理结构：</p>
<ul>
<li><p>连续文件（信息存放在相邻物理块中）</p>
</li>
<li><p>链接文件</p>
<ul>
<li>隐式链接</li>
<li>显示链接（文件分配表FAT）</li>
</ul>
</li>
<li><p>索引文件</p>
</li>
<li><p>直接文件（哈希函数）</p>
</li>
</ul>
<p>存取方式：</p>
<ul>
<li><p>顺序存取</p>
</li>
<li><p>直接存取</p>
</li>
<li><p>按键存取</p>
</li>
</ul>
<p>磁盘空闲空间的管理：</p>
<ul>
<li>空闲区表法</li>
<li>空闲块链表法</li>
<li>位示图法</li>
</ul>
<p>目录文件：</p>
<ul>
<li><p>文件控制块（FCB）：文件属性信息和文件内容信息</p>
</li>
<li><p>FCB 的有序集合称为文件目录</p>
</li>
<li><p>组织方式</p>
<ul>
<li>FCB 线性表</li>
<li>索引节点（常用）</li>
<li>哈希表</li>
</ul>
</li>
</ul>
<p>文件共享：</p>
<ul>
<li><p>静态共享</p>
<ul>
<li>基于索引节点的链接静态共享<ul>
<li>实现简单、访问速度快</li>
<li>只能用于单个文件系统，不能用于目录共享</li>
</ul>
</li>
<li>符号链接静态共享（软链接）<ul>
<li>能用于链接计算机网络中不同机器的文件</li>
<li>扫描包含文件的路径开销大，需要额外空间存储路径</li>
</ul>
</li>
</ul>
</li>
<li><p>动态共享（位移指针）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h1><p>DBMS：数据库管理系统</p>
<p>DBA：数据库管理员</p>
<p>E-R模型：实体-联系数据模型</p>
<p>三级模式结构：外模式$\rightarrow$模式$\rightarrow$内模式</p>
<p>完整性约束：</p>
<ul>
<li>实体完整性（主键不为空）</li>
<li>参照完整性</li>
<li>用户自定义完整性</li>
</ul>
<p>SQL：结构化查询语言</p>
<p>数据访问方式：</p>
<ul>
<li>顺序访问</li>
<li>索引</li>
</ul>
<p>索引特点：</p>
<ul>
<li>小表使用索引，性能不会提高，反而增大开销</li>
<li>查询返回的数据很少时，索引可以优化查询，若返回很多数据，反而会增大系统开销</li>
<li>索引提高了数据返回速度，但使得数据更新操作变慢</li>
<li>索引需要占用额外数据库存储空间</li>
<li>索引更新需要较大开销，不应频繁更新索引</li>
<li>不应将索引与表存储在同一驱动器上，容易造成冲突</li>
</ul>
<p>关系规范化：</p>
<ul>
<li>1NF（属性不可再分）</li>
<li>2NF（仅传递依赖）</li>
<li>3NF（无传递依赖）</li>
<li>BCNF（完全依赖）</li>
</ul>
<p>事务：将一组数据库操作打包起来形成一个逻辑独立的工作单元，这个工作单元不可分割，其中包含的数据库操作要么全部发生，要么都不发生。</p>
<p>事务四大特性：</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<p>建立冗余数据的方式：</p>
<ul>
<li>数据转储</li>
<li>日志文件</li>
</ul>
<p>并发控制四类问题：</p>
<ul>
<li>丢失修改（脏写）</li>
<li>读“脏”数据（脏读）</li>
<li>不可重复读</li>
<li>幻读</li>
</ul>
<p>事务隔离级别：</p>
<ul>
<li>读未提交（脏读、不可重复读、幻读）</li>
<li>读已提交（不可重复读、幻读）</li>
<li>可重复读（幻读）</li>
<li>可串行化</li>
</ul>
<p>封锁技术：</p>
<ul>
<li>排他锁（X 锁、写锁）</li>
<li>共享锁（S 锁、读锁）</li>
</ul>
<p>封锁协议：</p>
<ul>
<li><p>一级封锁协议（脏读、不可重复读、幻读）：修改数据 R 前加 X 锁，事务结束后释放</p>
</li>
<li><p>二级封锁协议（不可重复读、幻读）：在一级封锁协议的基础上，读取数据 R 前加 S 锁，读后释放</p>
</li>
<li><p>三级封锁协议（幻读）：在一级封锁协议的基础上，读取数据 R 前加 S 锁，事务结束后释放</p>
</li>
<li><p>两段锁协议（可串行化）</p>
<ul>
<li>任何读写操作前都需先加锁</li>
<li>释放任意锁后，事务不得再加锁</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库原理</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>数据库原理</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和矩阵</title>
    <url>/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><h3 id="1-1-最大连续-1-的个数"><a href="#1-1-最大连续-1-的个数" class="headerlink" title="1.1 最大连续 1 的个数"></a>1.1 最大连续 1 的个数</h3><p>给定一个二进制数组 <code>nums</code> ， 计算其中最大连续 <code>1</code> 的个数。</p>
<p><strong>思路</strong></p>
<p>一次遍历模拟即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxConsecutiveOnes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>,total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="comment">// 若为1，total++</span></span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">                total++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 更新最大连续1的个数</span></span><br><span class="line">                ans=Math.max(ans,total);</span><br><span class="line">                total=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新最大连续1的个数</span></span><br><span class="line">        ans=Math.max(ans,total);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-多数元素"><a href="#1-2-多数元素" class="headerlink" title="1.2 多数元素"></a>1.2 多数元素</h3><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>思路</strong></p>
<p>Boyer-Moore 投票算法。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 候选元素</span></span><br><span class="line">        <span class="type">int</span> candidate=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="comment">// 更新候选元素</span></span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                candidate=num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新count</span></span><br><span class="line">            count+=(candidate==num)?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-移动零"><a href="#1-3-移动零" class="headerlink" title="1.3 移动零"></a>1.3 移动零</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>思路</strong></p>
<p>将非零数移到数组前面，后面补0。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">// 非零数移动到前面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[index++]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后面补零</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;n;i++)&#123;</span><br><span class="line">            nums[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2. 矩阵"></a>2. 矩阵</h2><h3 id="2-1-转置矩阵"><a href="#2-1-转置矩阵" class="headerlink" title="2.1 转置矩阵"></a>2.1 转置矩阵</h3><p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p>
<p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>
<p><strong>思路</strong></p>
<p>矩阵模拟，即将行变成列，列变成行。</p>
<p>注意：矩阵行和列数可能不等。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] transpose(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="type">int</span> n=matrix.length,m=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] ans=<span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="comment">// 行变成列</span></span><br><span class="line">                ans[j][i]=matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-矩阵对角线元素的和"><a href="#2-2-矩阵对角线元素的和" class="headerlink" title="2.2 矩阵对角线元素的和"></a>2.2 矩阵对角线元素的和</h3><p>给你一个正方形矩阵 <code>mat</code>，请你返回矩阵对角线元素的和。</p>
<p>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p>
<p><strong>思路</strong></p>
<p>按照题意进行模拟即可。</p>
<p>注意：判断<code>n</code>的奇偶性。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diagonalSum</span><span class="params">(<span class="type">int</span>[][] mat)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=mat.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// mat[i][j]为主对角线元素，mat[i][n-i-1]为副对角线元素</span></span><br><span class="line">            ans+=mat[i][i]+mat[i][n-i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据n的奇偶判断是否要减去中间元素</span></span><br><span class="line">        <span class="keyword">return</span> (n&amp;<span class="number">1</span>)==<span class="number">1</span>?ans-mat[n/<span class="number">2</span>][n/<span class="number">2</span>]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-重塑矩阵"><a href="#2-3-重塑矩阵" class="headerlink" title="2.3 重塑矩阵"></a>2.3 重塑矩阵</h3><p>在 MATLAB 中，有一个非常有用的函数 <code>reshape</code> ，它可以将一个 <code>m x n</code> 矩阵重塑为另一个大小不同（<code>r x c</code>）的新矩阵，但保留其原始数据。</p>
<p>给你一个由二维数组 <code>mat</code> 表示的 <code>m x n</code> 矩阵，以及两个正整数 <code>r</code> 和 <code>c</code> ，分别表示想要的重构的矩阵的行数和列数。</p>
<p>重构后的矩阵需要将原始矩阵的所有元素以相同的 <strong>行遍历顺序</strong> 填充。</p>
<p>如果具有给定参数的 <code>reshape</code> 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<p><strong>思路</strong></p>
<p>二维矩阵表示成一维矩阵后，将其转为目标矩阵。</p>
<p>若<code>m</code>为原矩阵的行数，<code>n</code>为原矩阵的列数，那么元素总数为<code>m×n</code>，对于第<code>x</code>个元素，在目标矩阵中的位置即为第<code>x/c</code>行，第<code>x%c</code>列，因为每行有<code>c</code>个数，转换后即得到目标数组。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] matrixReshape(<span class="type">int</span>[][] mat, <span class="type">int</span> r, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span> n=mat.length,m=mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(n*m!=r*c) <span class="keyword">return</span> mat;</span><br><span class="line">        <span class="type">int</span>[][] ans=<span class="keyword">new</span> <span class="title class_">int</span>[r][c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                <span class="comment">// 当前为第x个数</span></span><br><span class="line">                <span class="type">int</span> x=i*c+j;</span><br><span class="line">                <span class="comment">// 目标矩阵第i行第j列的数</span></span><br><span class="line">                <span class="comment">// ans[i][j]=mat[x/m][x%m]</span></span><br><span class="line">                ans[i][j]=mat[x/m][x%m];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-托普利茨矩阵"><a href="#2-4-托普利茨矩阵" class="headerlink" title="2.4 托普利茨矩阵"></a>2.4 托普利茨矩阵</h3><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回 <code>false</code> <em>。</em></p>
<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 <strong>托普利茨矩阵</strong> 。</p>
<p><strong>思路</strong></p>
<p>按照题意进行模拟。</p>
<p>题目要求判断从左上到右下的斜线是否符合要求，即首先从左下角开始向上，到达左上角后再往右移动，最终到达右上角。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isToeplitzMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=matrix.length,m=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 从左下角开始模拟</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,bottom=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;m&amp;&amp;bottom&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> i=bottom,j=left;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;m)&#123;</span><br><span class="line">                <span class="comment">// 依次向右下角判断，若不等，则直接返回false</span></span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]!=matrix[bottom][left])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若还未到达左上角</span></span><br><span class="line">            <span class="keyword">if</span>(bottom&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                bottom--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;<span class="comment">// 到达左上角后向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>查找</title>
    <url>/%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="1-二分查找及其应用"><a href="#1-二分查找及其应用" class="headerlink" title="1. 二分查找及其应用"></a>1. 二分查找及其应用</h2><h3 id="1-1-搜索二维矩阵-II"><a href="#1-1-搜索二维矩阵-II" class="headerlink" title="1.1 搜索二维矩阵 II"></a>1.1 搜索二维矩阵 II</h3><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>思路</strong></p>
<p>直接查找：二重循环遍历，时间复杂度<code>O(mn)</code>。</p>
<p>二分查找：依次对每一行进行二分查找，时间复杂度<code>O(mlogn)</code>。</p>
<p>Z 字形查找：从矩阵右上角开始查找，若小于 target 则从下一行开始查找；若大于则从前一列开始查找，时间复杂度<code>O(m + n)</code>。</p>
<p><strong>代码</strong></p>
<p><strong>Z 字形查找</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=matrix.length,m=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 右上角开始查找</span></span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 大于target，y--</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y]&gt;target)&#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 小于target，x++</span></span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二分查找</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> m=matrix.length,n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="comment">// 二分查找</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]&lt;=target&amp;&amp;target&lt;=matrix[i][n-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> low=<span class="number">0</span>,high=n-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">                    <span class="type">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][mid]==target)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][mid]&lt;target)&#123;</span><br><span class="line">                        low=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        high=mid-<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>直接查找</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=matrix.length,m=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 遍历矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-二分查找"><a href="#1-2-二分查找" class="headerlink" title="1.2 二分查找"></a>1.2 二分查找</h3><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p><strong>思路</strong></p>
<p>二分查找，比较中间元素与 target 的大小，然后更新区间。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>,high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-搜索插入位置"><a href="#1-3-搜索插入位置" class="headerlink" title="1.3 搜索插入位置"></a>1.3 搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>思路</strong></p>
<p>二分查找，维护一个<code>pos</code>指针指向第一个大于等于<code>target</code>的元素位置，初始化<code>pos=-1</code>，若最终<code>pos==-1</code>，说明数组中没有比<code>target</code>大的元素，即插入末尾。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>,high=nums.length-<span class="number">1</span>,pos=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 找到target元素直接返回位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                pos=mid;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若pos==-1，返回nums.length</span></span><br><span class="line">        <span class="comment">// 若pos!=-1，返回pos</span></span><br><span class="line">        <span class="keyword">return</span> pos==-<span class="number">1</span>?nums.length:pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-在排序数组中查找元素的第一个和最后一个位置"><a href="#1-4-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="1.4 在排序数组中查找元素的第一个和最后一个位置"></a>1.4 在排序数组中查找元素的第一个和最后一个位置</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p> <strong>思路</strong></p>
<p>两次二分查找，即要找到第一个大于 target 的位置和第一个大于等于 target 的位置。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>,high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化left=-1，right=nums.length</span></span><br><span class="line">        <span class="comment">// 第一个大于等于target的位置，若无，则为-1</span></span><br><span class="line">        <span class="comment">// 第一个大于target的位置，若无，则为nums.length</span></span><br><span class="line">        <span class="type">int</span> left=-<span class="number">1</span>,right=nums.length;</span><br><span class="line">        <span class="comment">// 寻找right</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        low=<span class="number">0</span>;</span><br><span class="line">        high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 寻找left</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left!=-<span class="number">1</span>&amp;&amp;nums[left]==target?<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right-<span class="number">1</span>&#125;:<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-5-搜索旋转排序数组"><a href="#1-5-搜索旋转排序数组" class="headerlink" title="1.5 搜索旋转排序数组"></a>1.5 搜索旋转排序数组</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>思路</strong></p>
<p>二分查找，观察数组我们可以发现以数组中任意位置为分割点，将数组分为两个部分，总有一个部分是升序排列的。</p>
<p>判断哪个部分是升序我们只需比较<code>nums[0]</code>与当前位置的大小，若当前位置的数较大，说明前半部分为升序排列；反之后半部分为升序排列。</p>
<p>找到升序部分后，我们只需判断该部分最大值与<code>target</code>的大小，若大于或等于<code>target</code>，说明<code>target</code>出现在升序部分；反之，则出现在另一部分。</p>
<p>最终不断缩小区间，我们可以得到<code>target</code>的下标位置。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>,high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 找到target直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nums[0]&lt;=nums[mid]，说明前半段为升序排列</span></span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target&amp;&amp;target&lt;=nums[mid])&#123;</span><br><span class="line">                    high=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 后半段为升序排列</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;=target&amp;&amp;target&lt;=nums[n-<span class="number">1</span>])&#123;</span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-6-搜索旋转排序数组-II"><a href="#1-6-搜索旋转排序数组-II" class="headerlink" title="1.6 搜索旋转排序数组 II"></a>1.6 搜索旋转排序数组 II</h3><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p>你必须尽可能减少整个操作步骤。</p>
<p><strong>思路</strong></p>
<p>相较于<strong>”搜索旋转排序数组“</strong>，变化是所给数组为非降序排列，同题解一，我们可以将其分为两个部分，并找到其中有序的部分，需要注意的是当左右区间端点都等于中间端点的值时，我们无法判断哪个部分为有序部分，此时将左边界加一，有边界减一，即缩小区间继续二分查找即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>,high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左右区间端点均等于中间端点，区间缩小</span></span><br><span class="line">            <span class="keyword">if</span>(nums[low]==nums[mid]&amp;&amp;nums[high]==nums[mid])&#123;</span><br><span class="line">                low++;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[low]&lt;=nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[low]&lt;=target&amp;&amp;nums[mid]&gt;=target)&#123;</span><br><span class="line">                    high=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;=target&amp;&amp;nums[high]&gt;=target)&#123;</span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-7-寻找峰值"><a href="#1-7-寻找峰值" class="headerlink" title="1.7 寻找峰值"></a>1.7 寻找峰值</h3><p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p>
<p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p>
<p> <strong>思路</strong></p>
<p>二分查找，首先处理边界问题，若边界数已经为峰值，直接返回即可，若不为峰值，则进行二分查找，这样边界问题只需处理一次。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 数组长度为1，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 若nums[0]&gt;nums[1]，则nums[0]为峰值</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 若nums[nums.length-1]&gt;nums[nums.length-2]，则nums[nums.length-1]为峰值</span></span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;nums[nums.length-<span class="number">2</span>]) <span class="keyword">return</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 边界问题处理完后，进行二分查找，无需再处理边界</span></span><br><span class="line">        <span class="type">int</span> low=<span class="number">1</span>,high=nums.length-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[mid-<span class="number">1</span>]&amp;&amp;nums[mid]&gt;nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[mid-<span class="number">1</span>])&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-8-寻找两个正序数组的中位数"><a href="#1-8-寻找两个正序数组的中位数" class="headerlink" title="1.8 寻找两个正序数组的中位数"></a>1.8 寻找两个正序数组的中位数</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p><strong>思路</strong></p>
<p>大佬题解：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a></p>
<p><strong>二分解法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums1.length,m=nums2.length;</span><br><span class="line">        <span class="type">int</span> low=(m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> high=(m+n+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (getKthNum(nums1,<span class="number">0</span>,n-<span class="number">1</span>,nums2,<span class="number">0</span>,m-<span class="number">1</span>,low)+getKthNum(nums1,<span class="number">0</span>,n-<span class="number">1</span>,nums2,<span class="number">0</span>,m-<span class="number">1</span>,high))*<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKthNum</span><span class="params">(<span class="type">int</span>[] nums1,<span class="type">int</span> s1,<span class="type">int</span> e1,<span class="type">int</span>[] nums2,<span class="type">int</span> s2,<span class="type">int</span> e2,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> len1=e1-s1+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> len2=e2-s2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len1&gt;len2) <span class="keyword">return</span> getKthNum(nums2,s2,e2,nums1,s1,e1,k);</span><br><span class="line">        <span class="keyword">if</span>(len1==<span class="number">0</span>) <span class="keyword">return</span> nums2[s2+k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[s1],nums2[s2]);</span><br><span class="line">        <span class="type">int</span> i=s1+Math.min(len1,k/<span class="number">2</span>)-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j=s2+Math.min(len2,k/<span class="number">2</span>)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i]&gt;nums2[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> getKthNum(nums1,s1,e1,nums2,j+<span class="number">1</span>,e2,k-(j-s2+<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getKthNum(nums1,i+<span class="number">1</span>,e1,nums2,s2,e2,k-(i-s1+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-二叉排序树及其应用"><a href="#2-二叉排序树及其应用" class="headerlink" title="2. 二叉排序树及其应用"></a>2. 二叉排序树及其应用</h2><h3 id="2-1-不同的二叉搜索树"><a href="#2-1-不同的二叉搜索树" class="headerlink" title="2.1 不同的二叉搜索树"></a>2.1 不同的二叉搜索树</h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><strong>思路</strong></p>
<p>LeetCode 官方题解：<a href="https://leetcode.cn/problems/unique-binary-search-trees/solutions/329807/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">https://leetcode.cn/problems/unique-binary-search-trees/solutions/329807/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/</a></p>
<p><strong>动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数学</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans=<span class="number">2</span>*(<span class="number">2</span>*i+<span class="number">1</span>)*ans/(i+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-不同的二叉搜索树-II"><a href="#2-2-不同的二叉搜索树-II" class="headerlink" title="2.2 不同的二叉搜索树 II"></a>2.2 不同的二叉搜索树 II</h3><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>思路</strong></p>
<p>对于<code>1</code>到<code>n</code>的每个数，以该数为<code>根节点</code>，其<code>左节点</code>为其左半部分构成的不同二叉树，<code>右节点</code>为右半部分构成的不同二叉树，然后左右各选取一棵树作为该数的子树即可。</p>
<p>由该过程可以得出本质上是一个长度缩小的子问题，采用回溯算法生成子树即可。</p>
<p>参考LeetCode官方题解：<a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/solutions/339143/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/">https://leetcode.cn/problems/unique-binary-search-trees-ii/solutions/339143/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; tree=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 若该节点无效，加入null</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            tree.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="comment">// 左子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTree=generate(start,i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 右子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTree=generate(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">// 每次从左右子树集合各取一棵，构成不同的二叉搜索树</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left:leftTree)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right:rightTree)&#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    root.left=left;</span><br><span class="line">                    root.right=right;</span><br><span class="line">                    tree.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-二叉搜索树中的搜索"><a href="#2-3-二叉搜索树中的搜索" class="headerlink" title="2.3 二叉搜索树中的搜索"></a>2.3 二叉搜索树中的搜索</h3><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p>
<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>
<p> <strong>思路</strong></p>
<p>递归或迭代搜索：</p>
<ul>
<li>若<code>root==null||root.val==val</code>，返回<code>root</code></li>
<li>若<code>root.val&lt;val</code>，递归搜索<code>root.right</code></li>
<li>若<code>root.val&gt;val</code>，递归搜索<code>root.left</code></li>
</ul>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||root.val==val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val==val)&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            root=root.val&lt;val?root.right:root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-删除二叉搜索树中的节点"><a href="#2-4-删除二叉搜索树中的节点" class="headerlink" title="2.4 删除二叉搜索树中的节点"></a>2.4 删除二叉搜索树中的节点</h3><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ol>
<p> <strong>思路</strong></p>
<p>递归思路：</p>
<ul>
<li><p><code>root==null</code>，直接返回<code>null</code></p>
</li>
<li><p><code>root.val&lt;key</code>，递归删除左子树</p>
</li>
<li><p><code>root.val&gt;key</code>，递归删除右子树</p>
</li>
<li><p><code>root.val==key</code>：</p>
<ul>
<li><p>左右子树均为空，直接删除，返回<code>null</code></p>
</li>
<li><p>左子树为空，返回右子树</p>
</li>
<li><p>右子树为空，返回左子树</p>
</li>
<li><p>左右子树均不为空</p>
<p>寻找右子树中的最小节点，将其更新为新节点，然后删除它的原本位置</p>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// root==null,直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归删除右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;key)&#123;</span><br><span class="line">            root.left=deleteNode(root.left,key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归删除左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;key)&#123;</span><br><span class="line">            root.right=deleteNode(root.right,key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点直接删除</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树为空，返回右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树为空，返回左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 寻找右子树中的最小节点</span></span><br><span class="line">        TreeNode successor=root.right;</span><br><span class="line">        <span class="keyword">while</span>(successor.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            successor=successor.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新为新节点</span></span><br><span class="line">        root.right=deleteNode(root.right,successor.val);</span><br><span class="line">        successor.right=root.right;</span><br><span class="line">        successor.left=root.left;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-二叉搜索树的最近公共祖先"><a href="#2-5-二叉搜索树的最近公共祖先" class="headerlink" title="2.5 二叉搜索树的最近公共祖先"></a>2.5 二叉搜索树的最近公共祖先</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>思路</strong></p>
<p>遍历二叉搜索树：</p>
<ul>
<li>若<code>p.val&lt;root.val&amp;&amp;q.val&lt;root.val</code>，说明两个节点都在左子树中</li>
<li>若<code>p.val&gt;root.val&amp;&amp;q.val&gt;root.val</code>，说明两个节点都在右子树中</li>
<li>若不符合上面两种情况，说明两个节点分别在左右子树中，则当前节点即为最近公共祖先</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span>(p.val&lt;root.val&amp;&amp;q.val&lt;root.val)&#123;</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val&gt;root.val&amp;&amp;q.val&gt;root.val)&#123;<span class="comment">// 递归遍历右子树</span></span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 找到最近公共祖先，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-6-验证二叉搜索树"><a href="#2-6-验证二叉搜索树" class="headerlink" title="2.6 验证二叉搜索树"></a>2.6 验证二叉搜索树</h3><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p> <strong>思路</strong></p>
<p>中序遍历，二叉搜索树的中序遍历是一个递增序列。</p>
<p>我们在中序遍历中维护一个变量记录中序遍历上一个节点值，若当前访问的节点值不大于上一个节点值，则不为二叉搜索树。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// long类型处理临界问题</span></span><br><span class="line">    <span class="type">long</span> val=Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 二叉搜索树标志位</span></span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root.left);</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;=val)&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val=root.val;</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-7-二叉搜索树的范围和"><a href="#2-7-二叉搜索树的范围和" class="headerlink" title="2.7 二叉搜索树的范围和"></a>2.7 二叉搜索树的范围和</h3><p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p>
<p><strong>思路</strong></p>
<p>中序遍历的同时求出满足条件的节点和。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> low;</span><br><span class="line">    <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.low=low;</span><br><span class="line">        <span class="built_in">this</span>.high=high;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root.left);</span><br><span class="line">            <span class="comment">// 符合条件则累加</span></span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;=high&amp;&amp;root.val&gt;=low) sum+=root.val;</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-平衡二叉树及其应用"><a href="#3-平衡二叉树及其应用" class="headerlink" title="3. 平衡二叉树及其应用"></a>3. 平衡二叉树及其应用</h2><h3 id="3-1-平衡二叉树"><a href="#3-1-平衡二叉树" class="headerlink" title="3.1 平衡二叉树"></a>3.1 平衡二叉树</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<p> <strong>思路</strong></p>
<p>递归求解左右子树高度，判断其高度差是否超过1。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height(root)&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">// 空节点，高度为0</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树高度</span></span><br><span class="line">        <span class="type">int</span> left=height(root.left);</span><br><span class="line">        <span class="comment">// 右子树高度</span></span><br><span class="line">        <span class="type">int</span> right=height(root.right);</span><br><span class="line">        <span class="comment">// 若左子树或右子树已经不满足条件，或当前左右子树高度差超过1，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>||right==-<span class="number">1</span>||Math.abs(left-right)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回子树高度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-将二叉搜索树变平衡"><a href="#3-2-将二叉搜索树变平衡" class="headerlink" title="3.2 将二叉搜索树变平衡"></a>3.2 将二叉搜索树变平衡</h3><p>给你一棵二叉搜索树，请你返回一棵 <strong>平衡后</strong> 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p>
<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 <code>1</code> ，我们就称这棵二叉搜索树是 <strong>平衡的</strong> 。</p>
<p><strong>思路</strong></p>
<p>通过中序遍历得到一个递增序列，然后以中间节点为根节点重新构造平衡二叉树。</p>
<p>之后，每次都选取根节点两边的中间节点作为左右子树的根节点进行递归构造。</p>
<p><strong>证明</strong></p>
<p>以中间节点为根节点，则其两侧元素个数之差不超过1，即左右子树节点数量之差不会超过1，又因为我们是递归构造的，最终每个节点的左右子树节点数量之差都不会超过1，即保证了左右子树高度差都不会超过1。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">balanceBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>,list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造平衡二叉搜索树</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">// 空节点</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 中间位置</span></span><br><span class="line">        <span class="type">int</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 构造根节点</span></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(list.get(mid));</span><br><span class="line">        <span class="comment">// 递归构造左子树</span></span><br><span class="line">        root.left=build(start,mid-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        root.right=build(mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历，将二叉搜索树转化为有序序列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            traversal(root.left);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            traversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-安排工作以达到最大收益"><a href="#3-3-安排工作以达到最大收益" class="headerlink" title="3.3 安排工作以达到最大收益"></a>3.3 安排工作以达到最大收益</h3><p>你有 <code>n</code> 个工作和 <code>m</code> 个工人。给定三个数组： <code>difficulty</code>, <code>profit</code> 和 <code>worker</code> ，其中:</p>
<ul>
<li><code>difficulty[i]</code> 表示第 <code>i</code> 个工作的难度，<code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</li>
<li><code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</li>
</ul>
<p>每个工人 <strong>最多</strong> 只能安排 <strong>一个</strong> 工作，但是一个工作可以 <strong>完成多次</strong> 。</p>
<ul>
<li>举个例子，如果 3 个工人都尝试完成一份报酬为 <code>$1</code> 的同样工作，那么总收益为 <code>$3</code> 。如果一个工人不能完成任何工作，他的收益为 <code>$0</code> 。</li>
</ul>
<p>返回 <em>在把工人分配到工作岗位后，我们所能获得的最大利润</em> 。</p>
<p><strong>思路</strong></p>
<p>先将<code>profit</code>与<code>difficulty</code>对应起来，以<code>profit</code>为<code>key</code>，<code>difficulty</code>为<code>value</code>，按照降序排序，对<code>worker</code>按照升序排序。（不对<code>worker</code>进行降序排列的原因是Java的<code>Arrays.sort()</code>对于<code>Integer[]</code>和<code>int[]</code>的排序有限制，若要降序排序，那么需要将<code>int[]</code>类型转化为<code>Integer[]</code>，浪费空间（弊端）。C++则不会有此问题。）</p>
<p>然后依次从<code>worker</code>末尾开始反向遍历，若值大于当前第一个<code>profit</code>对应的<code>difficulty</code>，则直接安排该项工作；否则寻找第一个<code>difficulty</code>不大于<code>worker</code>值的工作。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfitAssignment</span><span class="params">(<span class="type">int</span>[] difficulty, <span class="type">int</span>[] profit, <span class="type">int</span>[] worker)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; pro=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> n=profit.length,m=worker.length;</span><br><span class="line">        <span class="comment">// 以profit为键，difficulty为值对应</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            pro.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;profit[i],difficulty[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 降序排列pro</span></span><br><span class="line">        Collections.sort(pro,(<span class="type">int</span>[] a1,<span class="type">int</span>[] a2) -&gt; (a2[<span class="number">0</span>]-a1[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 升序排列worker</span></span><br><span class="line">        Arrays.sort(worker);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="type">int</span> work=worker[j];</span><br><span class="line">            <span class="comment">// 当前worker能胜任工作，分派该工作</span></span><br><span class="line">            <span class="keyword">if</span>(work&gt;=pro.get(i)[<span class="number">1</span>])&#123;</span><br><span class="line">                sum+=pro.get(i)[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 寻找第一个当前worker能胜任的工作</span></span><br><span class="line">                <span class="keyword">while</span>(i&lt;n&amp;&amp;work&lt;pro.get(i)[<span class="number">1</span>])&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;n)&#123;</span><br><span class="line">                    sum+=pro.get(i)[<span class="number">0</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 未找到，说明worker及其之后的worker已经无法胜任任何工作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-第三大的数"><a href="#3-4-第三大的数" class="headerlink" title="3.4 第三大的数"></a>3.4 第三大的数</h3><p>给你一个非空数组，返回此数组中 <strong>第三大的数</strong> 。如果不存在，则返回数组中最大的数。</p>
<p> <strong>思路</strong></p>
<p>维护三个变量<code>first</code>、<code>second</code>和<code>third</code>，分别代表最大数、次大数和第三大的数，然后根据规则进行更新。</p>
<p>注意<code>int</code>边界判断。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">thirdMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> first=Integer.MIN_VALUE,second=Integer.MIN_VALUE,third=Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="comment">// 判断是否出现了Integer.MIN_VALUE</span></span><br><span class="line">            <span class="keyword">if</span>(num==Integer.MIN_VALUE)&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新规则</span></span><br><span class="line">            <span class="keyword">if</span>(num&gt;first)&#123;</span><br><span class="line">                <span class="type">int</span> tmp=second;</span><br><span class="line">                second=first;</span><br><span class="line">                third=tmp;</span><br><span class="line">                first=num;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num==first)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;second)&#123;</span><br><span class="line">                third=second;</span><br><span class="line">                second=num;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num==second)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;third)&#123;</span><br><span class="line">                third=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// first!=second,说明first存在</span></span><br><span class="line">        <span class="comment">// second!=third,说明second存在</span></span><br><span class="line">        <span class="comment">// third!=Integer.MIN_VALUE说明third存在，或flag==true(表示数组中存在Integer.MIN_VALUE，此时即使third==Integer.MIN_VALUE，third也是存在的)</span></span><br><span class="line">        <span class="keyword">return</span> first!=second&amp;&amp;second!=third&amp;&amp;(third!=Integer.MIN_VALUE||flag)?third:first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-哈希表及其应用"><a href="#4-哈希表及其应用" class="headerlink" title="4. 哈希表及其应用"></a>4. 哈希表及其应用</h2><h3 id="4-1-设计哈希集合"><a href="#4-1-设计哈希集合" class="headerlink" title="4.1 设计哈希集合"></a>4.1 设计哈希集合</h3><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>
<p>实现 <code>MyHashSet</code> 类：</p>
<ul>
<li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li>
<li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li>
<li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>
</ul>
<p> <strong>思路</strong></p>
<p>拉链法，参考官方题解以<code>BASE=769</code>作为基数进行哈希映射，遇到冲突元素则延长拉链。</p>
<p>宫水三叶大佬题解（「简单数组」&amp;「链表」&amp; 「分桶数组」）：<a href="https://leetcode.cn/problems/design-hashset/solutions/653184/yi-ti-san-jie-jian-dan-shu-zu-lian-biao-nj3dg/">https://leetcode.cn/problems/design-hashset/solutions/653184/yi-ti-san-jie-jian-dan-shu-zu-lian-biao-nj3dg/</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE</span> <span class="operator">=</span> <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList[] set; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        set = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[BASE];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;BASE;i++)&#123;</span><br><span class="line">            set[i]=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n_key=hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator=set[n_key].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> val=iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(val==key)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set[n_key].offerLast(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n_key=hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator=set[n_key].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> val=iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(val==key)&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n_key=hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator=set[n_key].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> val=iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(val==key)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % BASE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj.add(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-LRU-缓存"><a href="#4-2-LRU-缓存" class="headerlink" title="4.2 LRU 缓存"></a>4.2 LRU 缓存</h3><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>思路</strong></p>
<p>双向链表+哈希表，也就是Java中<code>LinkedHashMap</code>的简单实现，链表节点中存储对应的键值对，链表节点的先后顺序表示访问的顺序，哈希表中存储键对应的链表节点，每次访问或添加键值对时，更新对应链表节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 双向链表节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        Node()&#123;&#125;</span><br><span class="line">        Node(<span class="type">int</span> key,<span class="type">int</span> val)&#123;</span><br><span class="line">            <span class="built_in">this</span>.key=key;</span><br><span class="line">            <span class="built_in">this</span>.val=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    Map&lt;Integer,Node&gt; map;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    Node head;</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    Node tail;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity=capacity;</span><br><span class="line">        map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        head=<span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail=<span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.pre=head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// 若存在，则将其访问顺序移到头部</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            Node node=map.get(key);</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">// 更新节点</span></span><br><span class="line">            Node node=map.get(key);</span><br><span class="line">            node.val=value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node node=<span class="keyword">new</span> <span class="title class_">Node</span>(key,value);</span><br><span class="line">            <span class="comment">// 容量为空则删除尾节点，否则容量减1</span></span><br><span class="line">            <span class="keyword">if</span>(capacity==<span class="number">0</span>)&#123;</span><br><span class="line">                Node cur=removeTail();</span><br><span class="line">                map.remove(cur.key);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                capacity--;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key,node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        node.pre.next=node.next;</span><br><span class="line">        node.next.pre=node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在头部添加节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        node.pre=head;</span><br><span class="line">        node.next=head.next;</span><br><span class="line">        head.next.pre=node;</span><br><span class="line">        head.next=node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除尾节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeTail</span><span class="params">()</span>&#123;</span><br><span class="line">        Node node=tail.pre;</span><br><span class="line">        remove(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点移到头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        remove(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-数组中的第K个最大元素"><a href="#4-3-数组中的第K个最大元素" class="headerlink" title="4.3 数组中的第K个最大元素"></a>4.3 数组中的第K个最大元素</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>思路</strong></p>
<p>快速选择算法。参考快速排序算法的分治思想，我们并不需要将两个分治区间都进行排序，而只需判断当前位置在排序好的数组中是在第几个位置，因此我们只需递归一个区间即可。中间引入随机化思想，可使时间复杂度达到<code>O(n)</code>。</p>
<p>官方题解：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/307351/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/307351/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Random random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length-k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">     	<span class="comment">// 对数组中的某个位置进行随机划分</span></span><br><span class="line">        <span class="type">int</span> n=randomPartition(nums,l,r);</span><br><span class="line">        <span class="comment">// n==index，说明找到了第K个最大元素</span></span><br><span class="line">        <span class="keyword">if</span>(n==index)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[n];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 根据位置大小，递归左或右区间</span></span><br><span class="line">            <span class="keyword">return</span> n&lt;index?quickSelect(nums,n+<span class="number">1</span>,r,index):quickSelect(nums,l,n-<span class="number">1</span>,index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">randomPartition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="comment">// 随机选取一个位置，判断它在排序后数组中的位置</span></span><br><span class="line">        <span class="type">int</span> index=random.nextInt(r-l+<span class="number">1</span>)+l;</span><br><span class="line">        <span class="comment">// 将需要判断的数转移到数组末尾</span></span><br><span class="line">        swap(nums,index,r);</span><br><span class="line">        <span class="comment">// 划分区间</span></span><br><span class="line">        <span class="keyword">return</span> partition(nums,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="comment">// 由于我们将index与r位置调换了，所以现在r位置即为我们要判断的随机数的位置</span></span><br><span class="line">        <span class="type">int</span> num=nums[r],i=l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;r;j++)&#123;</span><br><span class="line">            <span class="comment">// 不大于num的数移到左侧区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=num)&#123;</span><br><span class="line">                swap(nums,i++,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换该数到最终位置</span></span><br><span class="line">        swap(nums,i,r);</span><br><span class="line">        <span class="comment">// 该数在排序后数组中的最终位置</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-O-1-时间插入、删除和获取随机元素"><a href="#4-4-O-1-时间插入、删除和获取随机元素" class="headerlink" title="4.4 O(1) 时间插入、删除和获取随机元素"></a>4.4 O(1) 时间插入、删除和获取随机元素</h3><p>实现<code>RandomizedSet</code> 类：</p>
<ul>
<li><p><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code> 对象</p>
</li>
<li><p><code>bool insert(int val)</code> 当元素 <code>val</code> 不存在时，向集合中插入该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</li>
<li><p><code>bool remove(int val)</code> 当元素 <code>val</code> 存在时，从集合中移除该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</li>
<li><p><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 <strong>相同的概率</strong> 被返回。</p>
</li>
</ul>
<p>你必须实现类的所有函数，并满足每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p>
<p><strong>思路</strong></p>
<p>数组存储元素，哈希表存储元素-索引键值对。</p>
<ul>
<li>插入：通过哈希表判断是否存在该元素，不存在则向数组中插入该元素，哈希表插入元素-索引键值对</li>
<li>删除：通过哈希表判断是否存在该元素，存在则移除，同时更新数组</li>
<li>获取随机元素：生成随机数下标，在数组中获取即可</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    Map&lt;Integer,Integer&gt; vis;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        nums=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        vis=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 若存在，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(vis.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        nums.add(val);</span><br><span class="line">        vis.put(val,nums.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 若不存在，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(!vis.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取被删除元素在数组中的下标</span></span><br><span class="line">        <span class="type">int</span> index=vis.get(val);</span><br><span class="line">        <span class="comment">// 将数组中的最后一个元素下标更新为当前下标，即覆盖了当前下标的数，相当于删除</span></span><br><span class="line">        nums.set(index,nums.get(nums.size()-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 更新数组中的最后一个元素的下标位置</span></span><br><span class="line">        vis.put(nums.get(nums.size()-<span class="number">1</span>),index);</span><br><span class="line">        <span class="comment">// 数组中的最后一个元素已经被更新，直接删除最后一个元素</span></span><br><span class="line">        nums.remove(nums.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 移除需要被删除元素的键值对</span></span><br><span class="line">        vis.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取随机下标</span></span><br><span class="line">        <span class="type">int</span> index=random.nextInt(nums.size());</span><br><span class="line">        <span class="keyword">return</span> nums.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与队列</title>
    <url>/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="1-栈的实现"><a href="#1-栈的实现" class="headerlink" title="1. 栈的实现"></a>1. 栈的实现</h2><h3 id="1-1-设计一个支持增量操作的栈"><a href="#1-1-设计一个支持增量操作的栈" class="headerlink" title="1.1 设计一个支持增量操作的栈"></a>1.1 设计一个支持增量操作的栈</h3><p>请你设计一个支持对其元素进行增量操作的栈。</p>
<p>实现自定义栈类 <code>CustomStack</code> ：</p>
<ul>
<li><code>CustomStack(int maxSize)</code>：用 <code>maxSize</code> 初始化对象，<code>maxSize</code> 是栈中最多能容纳的元素数量。</li>
<li><code>void push(int x)</code>：如果栈还未增长到 <code>maxSize</code> ，就将 <code>x</code> 添加到栈顶。</li>
<li><code>int pop()</code>：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 <strong>-1</strong> 。</li>
<li><code>void inc(int k, int val)</code>：栈底的 <code>k</code> 个元素的值都增加 <code>val</code> 。如果栈中元素总数小于 <code>k</code> ，则栈中的所有元素都增加 <code>val</code> 。</li>
</ul>
<p><strong>思路</strong></p>
<p>使用数组进行模拟即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomStack</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; stack;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(maxSize);</span><br><span class="line">        size=maxSize; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.size()&lt;size)&#123;</span><br><span class="line">            stack.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty()?-<span class="number">1</span>:stack.remove(stack.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// k与栈中元素个数取较小值</span></span><br><span class="line">        <span class="type">int</span> s=stack.size()&lt;k?stack.size():k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">            stack.set(i,stack.get(i)+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CustomStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CustomStack obj = new CustomStack(maxSize);</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * obj.increment(k,val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-最小栈"><a href="#1-2-最小栈" class="headerlink" title="1.2 最小栈"></a>1.2 最小栈</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<p><strong>思路</strong></p>
<p>维护两个栈，一个是当前栈，一个是最小栈。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        minStack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 最小栈中预先存入int最大值，这样不必判断栈是否为空</span></span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123; </span><br><span class="line">        <span class="comment">// 入栈操作</span></span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="comment">// 最小栈更新当前最小值</span></span><br><span class="line">        minStack.push(minStack.peek()&lt;=val?minStack.peek():val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回当前栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回最小元素</span></span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-栈的应用"><a href="#2-栈的应用" class="headerlink" title="2. 栈的应用"></a>2. 栈的应用</h2><h3 id="2-1-有效的括号"><a href="#2-1-有效的括号" class="headerlink" title="2.1 有效的括号"></a>2.1 有效的括号</h3><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>思路</strong></p>
<p>使用栈进行模拟，每次比较栈顶元素与当前元素是否配对。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; hep=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> k=s.charAt(i);</span><br><span class="line">            <span class="comment">// 若为左括号，直接入栈</span></span><br><span class="line">            <span class="keyword">if</span>(k==<span class="string">&#x27;(&#x27;</span>||k==<span class="string">&#x27;[&#x27;</span>||k==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                hep.push(k);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 若为右括号，需判断</span></span><br><span class="line">                <span class="comment">// 栈空，说明不配对，返回false</span></span><br><span class="line">                <span class="keyword">if</span>(hep.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">char</span> r=hep.poll();</span><br><span class="line">                    <span class="comment">// 判断元素是否配对</span></span><br><span class="line">                    <span class="keyword">if</span>((k==<span class="string">&#x27;)&#x27;</span>&amp;&amp;r==<span class="string">&#x27;(&#x27;</span>)||(k==<span class="string">&#x27;]&#x27;</span>&amp;&amp;r==<span class="string">&#x27;[&#x27;</span>)||(k==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;r==<span class="string">&#x27;&#123;&#x27;</span>))&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈空说明表达式有效，否则还有元素残留在栈中则无效</span></span><br><span class="line">        <span class="keyword">return</span> hep.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-移除无效的括号"><a href="#2-2-移除无效的括号" class="headerlink" title="2.2 移除无效的括号"></a>2.2 移除无效的括号</h3><p>给你一个由 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 和小写字母组成的字符串 <code>s</code>。</p>
<p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p>
<p>请返回任意一个合法字符串。</p>
<p>有效「括号字符串」应当符合以下 <strong>任意一条</strong> 要求：</p>
<ul>
<li>空字符串或只包含小写字母的字符串</li>
<li>可以被写作 <code>AB</code>（<code>A</code> 连接 <code>B</code>）的字符串，其中 <code>A</code> 和 <code>B</code> 都是有效「括号字符串」</li>
<li>可以被写作 <code>(A)</code> 的字符串，其中 <code>A</code> 是一个有效的「括号字符串」</li>
</ul>
<p><strong>思路</strong></p>
<p>栈思想模拟，仅一种括号类型，无需使用栈，仅需一个变量存储当前状态即可。</p>
<p>首先删除多余的<code>)</code>，然后根据<code>left</code>的数量删除多余的左括号。</p>
<p>注意：删除左括号时，要从字符串末尾开始删除，因为从左往右遍历，若左括号多余，则是右端先多出左括号。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minRemoveToMakeValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        StringBuilder cnt=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> k=s.charAt(i);</span><br><span class="line">            <span class="comment">// 左括号加入字符串中，后期再处理是否多余</span></span><br><span class="line">            <span class="keyword">if</span>(k==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                cnt.append(k);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 判断右括号是否能加入字符串中</span></span><br><span class="line">                <span class="keyword">if</span>(left==<span class="number">0</span>)&#123;<span class="comment">// 左括号数量为0，无法加入</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 若加入，那么左括号数量减一</span></span><br><span class="line">                    left--;</span><br><span class="line">                    cnt.append(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt.append(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> over=left;</span><br><span class="line">        <span class="type">int</span> size=cnt.length();</span><br><span class="line">        StringBuilder target=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 多余左括号处理</span></span><br><span class="line">            <span class="keyword">if</span>(over&gt;<span class="number">0</span>&amp;&amp;cnt.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                over--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            target.append(cnt.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于从右往左遍历，字符串需要反转</span></span><br><span class="line">        <span class="keyword">return</span> target.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-验证栈序列"><a href="#2-3-验证栈序列" class="headerlink" title="2.3 验证栈序列"></a>2.3 验证栈序列</h3><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>
<p><strong>思路</strong></p>
<p>模拟入栈与出栈操作。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=pushed.length;</span><br><span class="line">        Deque&lt;Integer&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// popped指针</span></span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// pushed指针</span></span><br><span class="line">        <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(id&lt;n||index&lt;n)&#123;</span><br><span class="line">            <span class="comment">// 栈空或栈顶元素不等于出栈元素</span></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty()||stack.peek()!=popped[index])&#123;</span><br><span class="line">                <span class="comment">// 若元素已经全部入栈，返回false</span></span><br><span class="line">                <span class="keyword">if</span>(id&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 否则将元素入栈</span></span><br><span class="line">                <span class="keyword">else</span> stack.push(pushed[id++]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 栈顶元素等于出栈元素，出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">// popped指针后移</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-用栈操作构建数组"><a href="#2-4-用栈操作构建数组" class="headerlink" title="2.4 用栈操作构建数组"></a>2.4 用栈操作构建数组</h3><p>给你一个数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从 <code>list = &#123; 1 , 2 , 3 ..., n &#125;</code> 中依次读取一个数字。</p>
<p>请使用下述操作来构建目标数组 <code>target</code> ：</p>
<ul>
<li><code>&quot;Push&quot;</code>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li>
<li><code>&quot;Pop&quot;</code>：删除数组中的最后一个元素。</li>
<li>如果目标数组构建完成，就停止读取更多元素。</li>
</ul>
<p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p>
<p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p>
<p><strong>思路</strong></p>
<p>按照题意进行栈模拟即可</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">buildArray</span><span class="params">(<span class="type">int</span>[] target, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 结果数组</span></span><br><span class="line">        List&lt;String&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// push和pop</span></span><br><span class="line">        String push=<span class="string">&quot;Push&quot;</span>,pop=<span class="string">&quot;Pop&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len=target.length,id=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">// 若target数组已遍历完，则返回结果</span></span><br><span class="line">            <span class="keyword">if</span>(id==len) <span class="keyword">return</span> cnt;</span><br><span class="line">            <span class="comment">// 将当前元素入栈</span></span><br><span class="line">            cnt.add(push);</span><br><span class="line">            <span class="comment">// 若当前元素在目标数组中，则指针后移</span></span><br><span class="line">            <span class="keyword">if</span>(i==target[id])&#123;</span><br><span class="line">                id++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 否则将当前元素出栈</span></span><br><span class="line">                cnt.add(pop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-表达式求值"><a href="#3-表达式求值" class="headerlink" title="3. 表达式求值"></a>3. 表达式求值</h2><h3 id="3-1-逆波兰表达式求值"><a href="#3-1-逆波兰表达式求值" class="headerlink" title="3.1 逆波兰表达式求值"></a>3.1 逆波兰表达式求值</h3><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<p><strong>思路</strong></p>
<p>栈模拟，遇到操作数则将其入栈，遇到运算符则运算，并将结果入栈。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; op=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String token:tokens)&#123;</span><br><span class="line">            <span class="comment">// 判断是否为运算符</span></span><br><span class="line">            <span class="keyword">if</span>(token.equals(<span class="string">&quot;+&quot;</span>)||token.equals(<span class="string">&quot;-&quot;</span>)||token.equals(<span class="string">&quot;*&quot;</span>)||token.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">// 运算</span></span><br><span class="line">                <span class="keyword">switch</span>(token.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:op.push(op.poll()+op.poll());<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:x=op.poll();y=op.poll();op.push(y-x);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:op.push(op.poll()*op.poll());<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:x=op.poll();y=op.poll();op.push(y/x);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 操作数直接入栈</span></span><br><span class="line">                op.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> op.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-基本计算器-II"><a href="#3-2-基本计算器-II" class="headerlink" title="3.2 基本计算器 II"></a>3.2 基本计算器 II</h3><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-231, 231 - 1]</code> 的范围内。</p>
<p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>
<p><strong>思路</strong></p>
<p>栈模拟，由于表达式中运算符仅有加减乘除，操作数均为非负数，对于加减操作，可以直接将对应操作数推入栈中；对于乘除操作，则推出栈顶元素进行运算后再将结果推入栈中。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        Deque&lt;Integer&gt; cnt=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始状态为非负数，即+</span></span><br><span class="line">        <span class="type">char</span> pre=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                num=num*<span class="number">10</span>+s.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若为’ ‘，不执行</span></span><br><span class="line">            <span class="comment">// 若i==n-1，说明已到末尾，进行最终运算</span></span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i))&amp;&amp;s.charAt(i)!=<span class="string">&#x27; &#x27;</span>||i==n-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 每次对数字前的运算符进行运算，而非对当前运算符运算</span></span><br><span class="line">                <span class="keyword">switch</span>(pre)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:cnt.push(num);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:cnt.push(-num);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:cnt.push(cnt.pop()*num);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:cnt.push(cnt.pop()/num);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre=s.charAt(i);</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 由于加减操作是直接将操作数推入栈中，需要将栈中数字累加得到结果</span></span><br><span class="line">        <span class="keyword">while</span>(!cnt.isEmpty())&#123;</span><br><span class="line">            ans+=cnt.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-基本计算器"><a href="#3-3-基本计算器" class="headerlink" title="3.3 基本计算器"></a>3.3 基本计算器</h3><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>
<p><strong>思路</strong></p>
<p>思路与上一题解类似，表达式中的运算符只有加减，对于左括号，存储它前面的运算符号，对于右括号，直接出栈即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; cnt=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化为正</span></span><br><span class="line">        cnt.push(flag);</span><br><span class="line">        <span class="type">int</span> answer=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">// 空格跳过</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;+&#x27;</span>)&#123;<span class="comment">// 取当前栈顶元素符号</span></span><br><span class="line">                flag=cnt.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;-&#x27;</span>)&#123;<span class="comment">// 取当前栈顶元素符号的相反数</span></span><br><span class="line">                flag=-cnt.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">// 将括号前的元素符号入栈</span></span><br><span class="line">                cnt.push(flag);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;<span class="comment">// 括号内运算结束，出栈</span></span><br><span class="line">                cnt.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 运算</span></span><br><span class="line">                <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;n&amp;&amp;Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                    ans=ans*<span class="number">10</span>+s.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                answer+=flag*ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-队列的实现"><a href="#4-队列的实现" class="headerlink" title="4. 队列的实现"></a>4. 队列的实现</h2><h3 id="4-1-设计循环队列"><a href="#4-1-设计循环队列" class="headerlink" title="4.1 设计循环队列"></a>4.1 设计循环队列</h3><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li>
<li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li>
<li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li>
<li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li>
<li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li>
<li><code>isEmpty()</code>: 检查循环队列是否为空。</li>
<li><code>isFull()</code>: 检查循环队列是否已满。</li>
</ul>
<p><strong>思路</strong></p>
<p>通过数组或链表模拟队列。</p>
<p>数组模拟：<code>front</code>指针指向队首，<code>tail</code>指针指向最后一个未被占用的空间，即队尾之后。</p>
<p>注意：数组模拟时注意队列为空与队列已满的判断条件。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularQueue</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化容量为k+1，因为tail指向最后一个不被占用的空间</span></span><br><span class="line">        <span class="comment">// 即数组需要多一个元素位置，这样在队列满时，tail才能指向最后剩余的空间</span></span><br><span class="line">        size=k+<span class="number">1</span>;</span><br><span class="line">        queue=<span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        front=<span class="number">0</span>;</span><br><span class="line">        tail=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否已满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入队列中</span></span><br><span class="line">        queue[tail]=value;</span><br><span class="line">        <span class="comment">// 队尾指针后移</span></span><br><span class="line">        <span class="comment">// （tail+1）%size保证tail指针不越界</span></span><br><span class="line">        tail=(tail+<span class="number">1</span>)%size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除队首元素即队首指针后移一位</span></span><br><span class="line">        <span class="comment">// 处理了队首指针越界问题</span></span><br><span class="line">        front=(front+<span class="number">1</span>)%size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回队首元素</span></span><br><span class="line">        <span class="keyword">return</span> queue[front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tail指向的是未使用的空间，即它的前一个位置才是队尾元素</span></span><br><span class="line">        <span class="comment">// （tail-1+size）%size防止tail指针越界（tail可能小于0）</span></span><br><span class="line">        <span class="keyword">return</span> queue[(tail-<span class="number">1</span>+size)%size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="comment">// 即队首==队尾</span></span><br><span class="line">        <span class="keyword">return</span> front==tail;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否已满</span></span><br><span class="line">        <span class="comment">// 即队尾指针的后一位置是否是队首</span></span><br><span class="line">        <span class="keyword">return</span> (tail+<span class="number">1</span>)%size==front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.enQueue(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.Rear();</span></span><br><span class="line"><span class="comment"> * boolean param_5 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_6 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-设计循环双端队列"><a href="#4-2-设计循环双端队列" class="headerlink" title="4.2 设计循环双端队列"></a>4.2 设计循环双端队列</h3><p>设计实现双端队列。</p>
<p>实现 <code>MyCircularDeque</code> 类:</p>
<ul>
<li><code>MyCircularDeque(int k)</code> ：构造函数,双端队列最大为 <code>k</code> 。</li>
<li><code>boolean insertFront()</code>：将一个元素添加到双端队列头部。 如果操作成功返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>boolean insertLast()</code> ：将一个元素添加到双端队列尾部。如果操作成功返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>boolean deleteFront()</code> ：从双端队列头部删除一个元素。 如果操作成功返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>boolean deleteLast()</code> ：从双端队列尾部删除一个元素。如果操作成功返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>int getFront()</code> )：从双端队列头部获得一个元素。如果双端队列为空，返回 <code>-1</code> 。</li>
<li><code>int getRear()</code> ：获得双端队列的最后一个元素。 如果双端队列为空，返回 <code>-1</code> 。</li>
<li><code>boolean isEmpty()</code> ：若双端队列为空，则返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>boolean isFull()</code> ：若双端队列满了，则返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
</ul>
<p><strong>思路</strong></p>
<p>双端队列模拟，思路同题解一。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularDeque</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] deque;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularDeque</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        size=k+<span class="number">1</span>;</span><br><span class="line">        deque=<span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        front=tail=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertFront</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front=(front-<span class="number">1</span>+size)%size;</span><br><span class="line">        deque[front]=value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deque[tail]=value;</span><br><span class="line">        tail=(tail+<span class="number">1</span>)%size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front=(front+<span class="number">1</span>)%size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail=(tail-<span class="number">1</span>+size)%size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque[front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque[(tail-<span class="number">1</span>+size)%size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> front==tail;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (tail+<span class="number">1</span>)%size==front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque obj = new MyCircularDeque(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insertFront(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.insertLast(value);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.deleteFront();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.deleteLast();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.getFront();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.getRear();</span></span><br><span class="line"><span class="comment"> * boolean param_7 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_8 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-栈和队列相互实现"><a href="#5-栈和队列相互实现" class="headerlink" title="5. 栈和队列相互实现"></a>5. 栈和队列相互实现</h2><h3 id="5-1-用队列实现栈"><a href="#5-1-用队列实现栈" class="headerlink" title="5.1 用队列实现栈"></a>5.1 用队列实现栈</h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>
<p>实现 <code>MyStack</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>
<li><code>int pop()</code> 移除并返回栈顶元素。</li>
<li><code>int top()</code> 返回栈顶元素。</li>
<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
</ul>
<p><strong>思路</strong></p>
<p>维护两个队列，<code>outStack</code>存储栈内元素，<code>inStack</code>作为辅助队列，辅助入栈。</p>
<p>每次进行入栈操作时，先将其插入<code>inStack</code>中，然后再将<code>outStack</code>中元素依次插入<code>inStack</code>中，再将二者交换，即实现了栈。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; inStack;</span><br><span class="line">    Deque&lt;Integer&gt; outStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        inStack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        outStack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 加入辅助队列</span></span><br><span class="line">        inStack.offer(x);</span><br><span class="line">        <span class="comment">// 将原来栈中元素加入辅助队列中</span></span><br><span class="line">        <span class="keyword">while</span>(!outStack.isEmpty())&#123;</span><br><span class="line">            inStack.offer(outStack.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换两者指针，实现栈</span></span><br><span class="line">        Deque&lt;Integer&gt; tmp=outStack;</span><br><span class="line">        outStack=inStack;</span><br><span class="line">        inStack=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> outStack.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-用栈实现队列"><a href="#5-2-用栈实现队列" class="headerlink" title="5.2 用栈实现队列"></a>5.2 用栈实现队列</h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p><strong>思路</strong></p>
<p>维护两个栈，一个栈用于输入，一个用于输出。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; inQueue;</span><br><span class="line">    Deque&lt;Integer&gt; outQueue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        inQueue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        outQueue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        inQueue.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将输入栈中的元素依次加入输出栈中</span></span><br><span class="line">        <span class="comment">// 这样使得栈顶元素变为了栈底元素，即实现了队列</span></span><br><span class="line">        <span class="keyword">if</span>(outQueue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inQueue.isEmpty())&#123;</span><br><span class="line">                outQueue.push(inQueue.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outQueue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将输入栈中的元素依次加入输出栈中</span></span><br><span class="line">        <span class="comment">// 这样使得栈顶元素变为了栈底元素，即实现了队列</span></span><br><span class="line">        <span class="keyword">if</span>(outQueue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inQueue.isEmpty())&#123;</span><br><span class="line">                outQueue.push(inQueue.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断输入栈和输出栈是否同时为空</span></span><br><span class="line">        <span class="keyword">return</span> inQueue.isEmpty()&amp;&amp;outQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 学习手札</title>
    <url>/MySQL/</url>
    <content><![CDATA[<h1 id="MySQL-学习手札"><a href="#MySQL-学习手札" class="headerlink" title="MySQL 学习手札"></a>MySQL 学习手札</h1><blockquote>
<p><strong>”MySQL 是怎样运行的“</strong>读书笔记</p>
</blockquote>
<h2 id="初识MySQL"><a href="#初识MySQL" class="headerlink" title="初识MySQL"></a>初识MySQL</h2><h3 id="一-服务器处理客户端请求"><a href="#一-服务器处理客户端请求" class="headerlink" title="一. 服务器处理客户端请求"></a>一. 服务器处理客户端请求</h3><p>服务器处理流程图：</p>
<p><img src="/./MySQL/NeatReader-1682560193918.png"></p>
<h3 id="二-常用存储引擎"><a href="#二-常用存储引擎" class="headerlink" title="二. 常用存储引擎"></a>二. 常用存储引擎</h3><table>
<thead>
<tr>
<th>存储引擎</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ARCHIVE</code></td>
<td>用于数据存档（行被插入后不能再修改）</td>
</tr>
<tr>
<td><code>BLACKHOLE</code></td>
<td>丢弃写操作，读操作会返回空内容</td>
</tr>
<tr>
<td><code>CSV</code></td>
<td>在存储数据时，以逗号分隔各个数据项</td>
</tr>
<tr>
<td><code>FEDERATED</code></td>
<td>用来访问远程表</td>
</tr>
<tr>
<td><code>InnoDB</code></td>
<td>具备外键支持功能的事务存储引擎</td>
</tr>
<tr>
<td><code>MEMORY</code></td>
<td>置于内存的表</td>
</tr>
<tr>
<td><code>MERGE</code></td>
<td>用来管理多个MyISAM表构成的表集合</td>
</tr>
<tr>
<td><code>MyISAM</code></td>
<td>主要的非事务处理存储引擎</td>
</tr>
<tr>
<td><code>NDB</code></td>
<td>MySQL集群专用存储引擎</td>
</tr>
</tbody></table>
<p>其中 <code>InnoDB </code>是 <code>MySQL </code>默认的存储引擎。</p>
<h3 id="三-关于存储引擎的一些操作"><a href="#三-关于存储引擎的一些操作" class="headerlink" title="三. 关于存储引擎的一些操作"></a>三. 关于存储引擎的一些操作</h3><p><strong>查看当前服务器程序支持的存储引擎</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure>

<p><strong>设置表的存储引擎</strong></p>
<p>创建表时指定存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    建表语句;</span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<p>修改表的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<h3 id="四-启动选项和配置文件"><a href="#四-启动选项和配置文件" class="headerlink" title="四. 启动选项和配置文件"></a>四. 启动选项和配置文件</h3><h4 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h4><table>
<thead>
<tr>
<th align="center">长形式</th>
<th align="center">短形式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>--host</code></td>
<td align="center"><code>-h</code></td>
<td align="left">主机名</td>
</tr>
<tr>
<td align="center"><code>--user</code></td>
<td align="center"><code>-u</code></td>
<td align="left">用户名</td>
</tr>
<tr>
<td align="center"><code>--password</code></td>
<td align="center"><code>-p</code></td>
<td align="left">密码</td>
</tr>
<tr>
<td align="center"><code>--port</code></td>
<td align="center"><code>-P</code></td>
<td align="left">端口</td>
</tr>
<tr>
<td align="center"><code>--version</code></td>
<td align="center"><code>-V</code></td>
<td align="left">版本信息</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">启动命令</th>
<th align="center">类别</th>
<th align="center">能读取的组</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>mysqld</code></td>
<td align="center">启动服务器</td>
<td align="center"><code>[mysqld] </code>、 <code>[server]</code></td>
</tr>
<tr>
<td align="center"><code>mysqld_safe</code></td>
<td align="center">启动服务器</td>
<td align="center"><code>[mysqld] </code>、 <code>[server] </code>、 <code>[mysqld_safe]</code></td>
</tr>
<tr>
<td align="center"><code>mysql.server</code></td>
<td align="center">启动服务器</td>
<td align="center"><code>[mysqld] </code>、 <code>[server] </code>、 <code>[mysql.server]</code></td>
</tr>
<tr>
<td align="center"><code>mysql</code></td>
<td align="center">启动客户端</td>
<td align="center"><code>[mysql] </code>、 <code>[client]</code></td>
</tr>
<tr>
<td align="center"><code>mysqladmin</code></td>
<td align="center">启动客户端</td>
<td align="center"><code>[mysqladmin] </code>、 <code>[client]</code></td>
</tr>
<tr>
<td align="center"><code>mysqldump</code></td>
<td align="center">启动客户端</td>
<td align="center"><code>[mysqldump] </code>、 <code>[client]</code></td>
</tr>
</tbody></table>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>在 <code>Windows </code>操作系统中， <code>MySQL </code>会按照下列路径来寻找配置文件：</p>
<table>
<thead>
<tr>
<th>路径名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>%WINDIR%\my.ini </code>， <code>%WINDIR%\my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>C:\my.ini </code>， <code>C:\my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>BASEDIR\my.ini </code>， <code>BASEDIR\my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>defaults-extra-file</code></td>
<td>命令行指定的额外配置文件路径</td>
</tr>
<tr>
<td><code>%APPDATA%\MySQL\.mylogin.cnf</code></td>
<td>登录路径选项（仅限客户端）</td>
</tr>
</tbody></table>
<p>在类 <code>UNIX </code>操作系统中， <code>MySQL </code>会按照下列路径来寻找配置文件：</p>
<table>
<thead>
<tr>
<th>路径名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>/etc/my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>/etc/mysql/my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>SYSCONFDIR/my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>$MYSQL_HOME/my.cnf</code></td>
<td>特定于服务器的选项（仅限服务器）</td>
</tr>
<tr>
<td><code>defaults-extra-file</code></td>
<td>命令行指定的额外配置文件路径</td>
</tr>
<tr>
<td><code>~/.my.cnf</code></td>
<td>用户特定选项</td>
</tr>
<tr>
<td><code>~/.mylogin.cnf</code></td>
<td>用户特定的登录路径选项（仅限客户端）</td>
</tr>
</tbody></table>
<h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p><strong>查看系统变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES [LIKE 匹配的模式]; // 支持通配符模糊查询</span><br></pre></td></tr></table></figure>

<h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><p><strong>查看状态变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式]; // 支持通配符模糊查询</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：</p>
<ul>
<li>系统变量和状态变量均有<code>GLOBAL</code>和<code>SESSION</code>作用范围</li>
<li>默认为<code>SESSION</code>作用范围</li>
<li>状态变量不可由用户更改，只能由服务器程序设置</li>
</ul>
<hr>
<h2 id="字符集和比较规则"><a href="#字符集和比较规则" class="headerlink" title="字符集和比较规则"></a>字符集和比较规则</h2><h3 id="一-常用字符集"><a href="#一-常用字符集" class="headerlink" title="一. 常用字符集"></a>一. 常用字符集</h3><p>不同字符集具有不同的编码规则：</p>
<ul>
<li><code>ASCII </code>字符集</li>
<li><code>ISO 8859-1 </code>字符集</li>
<li><code>GB2312 </code>字符集</li>
<li><code>GBK </code>字符集</li>
<li><code>utf8 </code>字符集</li>
</ul>
<p><code>MySQL </code>有4个级别的字符集和比较规则，分别是：</p>
<ul>
<li>服务器级别</li>
<li>数据库级别</li>
<li>表级别</li>
<li>列级别</li>
</ul>
<p> <code>MySQL </code>中 的默认字符集是<code>utf8</code>，<code>utf8 </code>是 <code>utf8mb3 </code>的别名。</p>
<h3 id="二-字符集的查看"><a href="#二-字符集的查看" class="headerlink" title="二. 字符集的查看"></a>二. 字符集的查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>

<h3 id="三-比较规则的查看"><a href="#三-比较规则的查看" class="headerlink" title="三. 比较规则的查看"></a>三. 比较规则的查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW COLLATION [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>

<h3 id="四-客户端和服务器通信中的字符集"><a href="#四-客户端和服务器通信中的字符集" class="headerlink" title="四. 客户端和服务器通信中的字符集"></a>四. 客户端和服务器通信中的字符集</h3><p>从发送请求到接收结果过程中发生的字符集转换：</p>
<ul>
<li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li>
<li>服务器将客户端发送来的字节串采用 <code>character_set_client </code>代表的字符集进行解码，将解码后的字符串再按照 <code>character_set_connection </code>代表的字符集进行编码。</li>
<li>如果 <code>character_set_connection </code>代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从 <code>character_set_connection </code>代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li>
<li>将从某个列获取到的字节串从该列使用的字符集转换为 <code>character_set_results </code>代表的字符集后发送到客户端。</li>
<li>客户端使用操作系统的字符集解析收到的结果集字节串。</li>
</ul>
<p>在这个过程中各个系统变量的含义如下：</p>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>character_set_client</code></td>
<td>服务器解码请求时使用的字符集</td>
</tr>
<tr>
<td><code>character_set_connection</code></td>
<td>服务器处理请求时会把请求字符串从 <code>character_set_client </code>转为 <code>character_set_connection</code></td>
</tr>
<tr>
<td><code>character_set_results</code></td>
<td>服务器向客户端返回数据时使用的字符集</td>
</tr>
</tbody></table>
<p>处理流程：</p>
<p><img src="/./MySQL/NeatReader-1682563641366.png"></p>
<hr>
<h2 id="InnoDB-记录结构"><a href="#InnoDB-记录结构" class="headerlink" title="InnoDB 记录结构"></a>InnoDB 记录结构</h2><h3 id="一-InnoDB-页简介"><a href="#一-InnoDB-页简介" class="headerlink" title="一. InnoDB 页简介"></a>一. InnoDB 页简介</h3><p><code>InnoDB </code>存储的方式是： 将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，<code>InnoDB</code>中页的大小一般为 <strong>16 KB</strong> 。也就是在一般情况下，一次最少从磁盘中读取 <strong>16 KB</strong> 的内容到内存中，一次最少把内存中的 <strong>16 KB</strong> 内容刷新到磁盘中。</p>
<h3 id="二-InnoDB-行格式"><a href="#二-InnoDB-行格式" class="headerlink" title="二. InnoDB 行格式"></a>二. InnoDB 行格式</h3><p><strong>指定行格式的语法</strong></p>
<p>我们可以在创建或修改表的语句中指定 <code>行格式 </code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    </span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure>

<h4 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h4><p><img src="/./MySQL/NeatReader-1682564637978.png"></p>
<p><strong>注：</strong></p>
<ul>
<li><p>变长字段长度列表按照列的顺序逆序存放</p>
</li>
<li><p><code>NULL</code>值列表将每个允许存储<code>NULL</code>值的列对应一个二进制位，按照列的顺序逆序排列</p>
<ul>
<li>二进制位的值为 <code>1 </code>时，代表该列的值为 <code>NULL </code>。</li>
<li>二进制位的值为 <code>0 </code>时，代表该列的值不为 <code>NULL </code>。</li>
</ul>
</li>
<li><p>记录头信息</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>预留位1</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>预留位2</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>delete_mask</code></td>
<td><code>1</code></td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td><code>min_rec_mask</code></td>
<td><code>1</code></td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td><code>n_owned</code></td>
<td><code>4</code></td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td><code>heap_no</code></td>
<td><code>13</code></td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td><code>record_type</code></td>
<td><code>3</code></td>
<td>表示当前记录的类型， <code>0 </code>表示普通记录， <code>1 </code>表示B+树非叶子节点记录， <code>2 </code>表示最小记录， <code>3 </code>表示最大记录</td>
</tr>
<tr>
<td><code>next_record</code></td>
<td><code>16</code></td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody></table>
</li>
<li><p>记录的真实数据会默认添加一些<code>隐藏列</code></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>row_id</code></td>
<td>否</td>
<td><code>6 </code>字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td><code>transaction_id</code></td>
<td>是</td>
<td><code>6 </code>字节</td>
<td>事务ID</td>
</tr>
<tr>
<td><code>roll_pointer</code></td>
<td>是</td>
<td><code>7 </code>字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h4><p><img src="/./MySQL/NeatReader-1682565875075.png"></p>
<p><strong>注：</strong></p>
<ul>
<li><p>字段长度偏移列表</p>
<p>对比<code>Compact</code>行格式：</p>
<ul>
<li>没有了 变长 两个字，意味着 <code>Redundant </code>行格式会把该条记录中 所有列 （包括 <code>隐藏列 </code>）的长度信息都按照 逆序 存储到 <code>字段长度偏移列表 </code>。</li>
<li>多了个 偏移 两个字，这意味着计算列值长度的方式不像 <code>Compact </code>行格式那么直观，它是采用两个相邻数值的 差值 来计算各个列值的长度。</li>
</ul>
</li>
<li><p>记录头信息</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>预留位1</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>预留位2</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>delete_mask</code></td>
<td><code>1</code></td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td><code>min_rec_mask</code></td>
<td><code>1</code></td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td><code>n_owned</code></td>
<td><code>4</code></td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td><code>heap_no</code></td>
<td><code>13</code></td>
<td>表示当前记录在页面堆的位置信息</td>
</tr>
<tr>
<td><code>n_field</code></td>
<td><code>10</code></td>
<td>表示记录中列的数量</td>
</tr>
<tr>
<td><code>1byte_offs_flag</code></td>
<td><code>1</code></td>
<td>标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的</td>
</tr>
<tr>
<td><code>next_record</code></td>
<td><code>16</code></td>
<td>表示下一条记录的绝对位置</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h4><p>在 <code>Compact </code>和 <code>Redundant </code>行格式中，对于占用存储空间非常大的列，在 <code>记录的真实数据 </code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后 <code>记录的真实数据 </code>处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：</p>
<p><img src="/./MySQL/NeatReader-1682567475219.png"></p>
<h4 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h4><p><img src="/./MySQL/NeatReader-1682567617643.png"></p>
<p><code>Compressed </code>行格式和 <code>Dynamic </code>不同的一点是， <code>Compressed </code>行格式会采用压缩算法对页面进行压缩，以节省空间。</p>
<hr>
<h2 id="InnoDB-数据页结构"><a href="#InnoDB-数据页结构" class="headerlink" title="InnoDB 数据页结构"></a>InnoDB 数据页结构</h2><h3 id="一-数据页结构"><a href="#一-数据页结构" class="headerlink" title="一. 数据页结构"></a>一. 数据页结构</h3><p><img src="/./MySQL/NeatReader-1682729790459.png"></p>
<p>功能展示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>File Header</code></td>
<td>文件头部</td>
<td><code>38 </code>字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td><code>Page Header</code></td>
<td>页面头部</td>
<td><code>56 </code>字节</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td><code>Infimum + Supremum</code></td>
<td>最小记录和最大记录</td>
<td><code>26 </code>字节</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td><code>User Records</code></td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td><code>Free Space</code></td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td><code>Page Directory</code></td>
<td>页面目录</td>
<td>不确定</td>
<td>页中的某些记录的相对位置</td>
</tr>
<tr>
<td><code>File Trailer</code></td>
<td>文件尾部</td>
<td><code>8 </code>字节</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<p><strong>小结：</strong></p>
<ol>
<li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做 <code>数据页 </code>。</li>
<li>一个数据页可以被大致划分为7个部分，分别是<ul>
<li><code>File Header </code>，表示页的一些通用信息，占固定的38字节。</li>
<li><code>Page Header </code>，表示数据页专有的一些信息，占固定的56个字节。</li>
<li><code>Infimum + Supremum </code>，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的 <code>26 </code>个字节。</li>
<li><code>User Records </code>：真实存储我们插入的记录的部分，大小不固定。</li>
<li><code>Free Space </code>：页中尚未使用的部分，大小不确定。</li>
<li><code>Page Directory </code>：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。</li>
<li><code>File Trailer </code>：用于检验页是否完整的部分，占用固定的8个字节。</li>
</ul>
</li>
<li>每个记录的头信息中都有一个 <code>next_record </code>属性，从而使页中的所有记录串联成一个 <code>单链表 </code>。</li>
<li><code>InnoDB </code>会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个 <code>槽 </code>，存放在 <code>Page Directory </code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：<ul>
<li>通过二分法确定该记录所在的槽。</li>
<li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li>
</ul>
</li>
<li>每个数据页的 <code>File Header </code>部分都有上一个和下一个页的编号，所以所有的数据页会组成一个 <code>双链表 </code>。</li>
<li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的 <code>LSN </code>值，如果首部和尾部的校验和和 <code>LSN </code>值校验不成功的话，就说明同步过程出现了问题。</li>
</ol>
<hr>
<h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h2><h3 id="一-InnoDB-中的索引方案"><a href="#一-InnoDB-中的索引方案" class="headerlink" title="一. InnoDB 中的索引方案"></a>一. InnoDB 中的索引方案</h3><p>索引结构（B+ 树）：</p>
<p><img src="/./MySQL/NeatReader-1682734269244.png"></p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>两个特点：</p>
<ol>
<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>
</ul>
</li>
<li><p><code>B+ </code>树的叶子节点存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。我们把具有这两种特性的 <code>B+ </code>树称为 <code>聚簇索引 </code>，所有完整的用户记录都存放在这个 <code>聚簇索引 </code>的叶子节点处。这就是所谓的索引即数据，数据即索引。</p>
</li>
</ol>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>与聚簇索引区别：</p>
<ul>
<li>叶子节点只存放索引列和主键的值，并非完整的用户记录</li>
<li>搜索完毕后若想得到完整的用户记录，还需要根据搜索得到的主键值到<code>聚簇索引</code>中再查找一遍，即<code>回表</code></li>
</ul>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>与二级索引区别：</p>
<ul>
<li>建立<code>联合索引</code>只会建立一棵<code>B+</code>树</li>
<li>若分别建立索引则会产生多棵<code>B+</code>树</li>
</ul>
<h4 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h4><p>为了让新插入记录能找到自己在那个页里， 我们需要保证在B+树的同一层内节点的目录项记录除 <code>页号 </code>这个字段以外是唯一的 。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>有了主键值我们便能确保唯一性。</p>
<h3 id="二-B-树索引的使用"><a href="#二-B-树索引的使用" class="headerlink" title="二. B+ 树索引的使用"></a>二. B+ 树索引的使用</h3><p><strong>小结：</strong></p>
<ol>
<li><code>B+ </code>树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</li>
<li><code>B+ </code>树索引适用于下边这些情况：<ul>
<li>全值匹配</li>
<li>匹配左边的列</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>用于排序</li>
<li>用于分组</li>
</ul>
</li>
<li>在使用索引时需要注意下边这些事项：<ul>
<li>只为用于搜索、排序或分组的列创建索引</li>
<li>为列的基数大的列创建索引</li>
<li>索引列的类型尽量小</li>
<li>可以只对字符串值的前缀建立索引</li>
<li>只有索引列在比较表达式中单独出现才可以适用索引</li>
<li>为了尽可能少的让 <code>聚簇索引 </code>发生页面分裂和记录移位的情况，建议让主键拥有 <code>AUTO_INCREMENT </code>属性。</li>
<li>定位并删除表中的重复和冗余索引</li>
<li>尽量使用 <code>覆盖索引 </code>进行查询，避免 <code>回表 </code>带来的性能损耗。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="MySQL-的数据目录"><a href="#MySQL-的数据目录" class="headerlink" title="MySQL 的数据目录"></a>MySQL 的数据目录</h2><h3 id="一-数据目录"><a href="#一-数据目录" class="headerlink" title="一. 数据目录"></a>一. 数据目录</h3><p><strong>查看数据目录位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;datadir&#x27;;</span><br><span class="line">+---------------+-----------------------+</span><br><span class="line">| Variable_name | Value                 |</span><br><span class="line">+---------------+-----------------------+</span><br><span class="line">| datadir       | /usr/local/var/mysql/ |</span><br><span class="line">+---------------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="二-数据目录的结构"><a href="#二-数据目录的结构" class="headerlink" title="二. 数据目录的结构"></a>二. 数据目录的结构</h3><ul>
<li><p>数据库在文件系统中的表示</p>
<ul>
<li>对应数据目录下的一个同名子目录</li>
<li>在改子目录下创建一个名为 db.opt 的文件，用来描述数据库的属性</li>
</ul>
</li>
<li><p>表在文件系统中的表示</p>
<ul>
<li><p>对应数据库子目录下创建一个<strong>“表名.frm”</strong>文件，用来描述表的结构</p>
</li>
<li><p>InnoDB 存储表数据</p>
<ul>
<li><p>系统表空间（system tablespace）</p>
<ul>
<li>数据目录下有一个ibdata1文件，大小为12M，是自扩展文件</li>
<li>在一个MySQL服务器中，系统表空间只有一份</li>
<li>从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个 <em><strong>系统表空间</strong></em> 。</li>
</ul>
</li>
<li><p>独立表空间(file-per-table tablespace)</p>
<ul>
<li><p>每个表对应一个独立表空间，文件名为<strong>“表名.ibd”</strong></p>
</li>
<li><p>移动表空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 TABLESPACE [=] innodb_system/innodb_file_per_table;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>MyISAM 存储表数据</p>
<p>对应数据库子目录下创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.frm // 表结构信息</span><br><span class="line">test.MYD // 数据文件</span><br><span class="line">test.MYI // 索引文件</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>视图在文件系统中的表示</p>
<p>存储 <code>视图 </code>的时候是不需要存储真实的数据的， 只需要把它的结构存储起来就行了 。</p>
<p>对应数据库子目录下创建一个 <code>视图名.frm </code>的文件。</p>
</li>
</ul>
<h3 id="三-文件系统对数据库的影响"><a href="#三-文件系统对数据库的影响" class="headerlink" title="三. 文件系统对数据库的影响"></a>三. 文件系统对数据库的影响</h3><ul>
<li><p>数据库名称和表名称不得超过文件系统所允许的最大长度。</p>
</li>
<li><p>特殊字符的问题</p>
<p>特殊字符会被映射成编码值</p>
</li>
<li><p>文件长度受文件系统最大长度限制</p>
</li>
</ul>
<h3 id="四-MySQL-系统数据库"><a href="#四-MySQL-系统数据库" class="headerlink" title="四. MySQL 系统数据库"></a>四. MySQL 系统数据库</h3><ul>
<li><p><code>mysql</code></p>
<p>这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p>
</li>
<li><p><code>information_schema</code></p>
<p>这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引吧啦吧啦。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。</p>
</li>
<li><p><code>performance_schema</code></p>
<p>这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。</p>
</li>
<li><p><code>sys</code></p>
<p>这个数据库主要是通过视图的形式把 <code>information_schema </code>和 <code>performance_schema </code>结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。</p>
</li>
</ul>
<hr>
<h2 id="InnoDB-的表空间"><a href="#InnoDB-的表空间" class="headerlink" title="InnoDB 的表空间"></a>InnoDB 的表空间</h2><p><strong>页面通用部分</strong></p>
<p><img src="/./MySQL/NeatReader-1682820945091.png"></p>
<h3 id="一-独立表空间结构"><a href="#一-独立表空间结构" class="headerlink" title="一. 独立表空间结构"></a>一. 独立表空间结构</h3><h4 id="1-区（extent）"><a href="#1-区（extent）" class="headerlink" title="1. 区（extent）"></a>1. 区（extent）</h4><p>对于16KB的页来说，连续的64个页就是一个 <code>区 </code>，也就是说一个区默认占用1MB空间大小。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。画个图表示就是这样：</p>
<p><img src="/./MySQL/NeatReader-1682821057863.png"></p>
<p>这些组的头几个页面的类型都是类似的，就像这样：</p>
<p><img src="/./MySQL/NeatReader-1682821091728.png"></p>
<p>信息：</p>
<ul>
<li><code>FSP_HDR </code>类型：登记整个表空间的一些整体属性以及本组所有的区的属性，整个表空间只有一个 <code>FSP_HDR </code>类型的页面。</li>
<li><code>XDES </code>类型：登记本组所有区的属性。</li>
<li><code>IBUF_BITMAP </code>类型：存储本组所有的区的所有页面关于 <code>INSERT BUFFER </code>的信息。</li>
<li><code>INODE </code>类型：存储了许多称为 <code>INODE </code>的数据结构。</li>
</ul>
<h4 id="2-段（segment）"><a href="#2-段（segment）" class="headerlink" title="2. 段（segment）"></a>2. 段（segment）</h4><p>叶子节点有自己独有的 <code>区 </code>，非叶子节点也有自己独有的 <code>区 </code>。存放叶子节点的区的集合就算是一个 <code>段 </code>（ <code>segment </code>），存放非叶子节点的区的集合也算是一个 <code>段 </code>。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p>
<p>碎片区：在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是可以用于不同的段。</p>
<p>段分配存储空间的策略：</p>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。</li>
</ul>
<h4 id="3-区的分类"><a href="#3-区的分类" class="headerlink" title="3. 区的分类"></a>3. 区的分类</h4><table>
<thead>
<tr>
<th>状态名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>FREE</code></td>
<td>空闲的区</td>
</tr>
<tr>
<td><code>FREE_FRAG</code></td>
<td>有剩余空间的碎片区</td>
</tr>
<tr>
<td><code>FULL_FRAG</code></td>
<td>没有剩余空间的碎片区</td>
</tr>
<tr>
<td><code>FSEG</code></td>
<td>附属于某个段的区</td>
</tr>
</tbody></table>
<p>处于 <code>FREE </code>、 <code>FREE_FRAG </code>以及 <code>FULL_FRAG </code>这三种状态的区都是独立的，算是直属于表空间；而处于 <code>FSEG </code>状态的区是附属于某个段的。</p>
<h5 id="1-XDES-Entry-结构"><a href="#1-XDES-Entry-结构" class="headerlink" title="1. XDES Entry 结构"></a>1. XDES Entry 结构</h5><p>记录对应的区的一些属性：</p>
<p><img src="/./MySQL/NeatReader-1682821747935.png"></p>
<ul>
<li><p><code>Segment ID </code>（8字节）</p>
<p>表示段的唯一编号。</p>
</li>
<li><p><code>List Node </code>（12字节）</p>
<p>定位表空间的某一个位置。</p>
<p><img src="/./MySQL/NeatReader-1682821818679.png"></p>
</li>
<li><p><code>State </code>（4字节）</p>
<p>表明区的状态。</p>
</li>
<li><p><code>Page State Bitmap </code>（16字节）</p>
<p>一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。</p>
<p>这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用。</p>
</li>
</ul>
<h5 id="2-XDES-Entry-链表"><a href="#2-XDES-Entry-链表" class="headerlink" title="2. XDES Entry 链表"></a>2. XDES Entry 链表</h5><p>对于 <code>FREE </code>、 <code>FREE_FRAG </code>、 <code>FULL_FRAG </code>三种区，分别通过<code>List Node </code>建立链表。</p>
<p>对于<code>FSEG</code>，对每个不同的段分别建立以下三个链表：</p>
<ul>
<li><code>FREE </code>链表：同一个段中，所有页面都是空闲的区对应的 <code>XDES Entry </code>结构会被加入到这个链表。注意和直属于表空间的 <code>FREE </code>链表区别开了，此处的 <code>FREE </code>链表是附属于某个段的。</li>
<li><code>NOT_FULL </code>链表：同一个段中，仍有空闲空间的区对应的 <code>XDES Entry </code>结构会被加入到这个链表。</li>
<li><code>FULL </code>链表：同一个段中，已经没有空闲空间的区对应的 <code>XDES Entry </code>结构会被加入到这个链表。</li>
</ul>
<h5 id="3-链表基节点"><a href="#3-链表基节点" class="headerlink" title="3. 链表基节点"></a>3. 链表基节点</h5><p>为了寻找到某个链表的头节点或尾节点，产生了 <code>List Base Node </code>结构：</p>
<p><img src="/./MySQL/NeatReader-1682822360029.png"></p>
<p>一般我们把某个链表对应的 <code>List Base Node </code>结构放置在表空间中固定的位置，这样想定位某个链表就变得很容易了。</p>
<h5 id="4-链表小结"><a href="#4-链表小结" class="headerlink" title="4. 链表小结"></a>4. 链表小结</h5><p>综上所述，表空间是由若干个区组成的，每个区都对应一个 <code>XDES Entry </code>的结构，直属于表空间的区对应的 <code>XDES Entry </code>结构可以分成 <code>FREE </code>、 <code>FREE_FRAG </code>和 <code>FULL_FRAG </code>这3个链表；每个段可以附属若干个区，每个段中的区对应的 <code>XDES Entry </code>结构可以分成 <code>FREE </code>、 <code>NOT_FULL </code>和 <code>FULL </code>这3个链表。每个链表都对应一个 <code>List Base Node </code>的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。正是因为这些链表的存在，管理这些区才变成了一件容易的事情。</p>
<h4 id="4-段的结构"><a href="#4-段的结构" class="headerlink" title="4. 段的结构"></a>4. 段的结构</h4><p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。像每个区都有对应的 <code>XDES Entry </code>来记录这个区中的属性一样，设计 <code>InnoDB </code>的大叔为每个段都定义了一个 <code>INODE Entry </code>结构来记录一下段中的属性。</p>
<p><img src="/./MySQL/NeatReader-1682822583693.png"></p>
<ul>
<li><p><code>Segment ID</code></p>
<p>段的唯一编号。</p>
</li>
<li><p><code>NOT_FULL_N_USED</code></p>
<p>这个字段指的是在 <code>NOT_FULL </code>链表中已经使用了多少个页面。</p>
</li>
<li><p>3个 <code>List Base Node</code></p>
<p>分别为段的 <code>FREE </code>链表、 <code>NOT_FULL </code>链表、 <code>FULL </code>链表定义了 <code>List Base Node </code>。</p>
</li>
<li><p><code>Magic Number </code>：</p>
<p>这个值是用来标记这个 <code>INODE Entry </code>是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了）。如果这个值是 <code>97937874 </code>，表明该 <code>INODE Entry </code>已经初始化，否则没有被初始化。（不用纠结这个值有啥特殊含义，人家规定的）。</p>
</li>
<li><p><code>Fragment Array Entry</code></p>
<p>我们前边强调过无数次段是一些零散页面和一些完整的区的集合，每个 <code>Fragment Array Entry </code>结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号。</p>
</li>
</ul>
<h4 id="5-各类型页面详细情况"><a href="#5-各类型页面详细情况" class="headerlink" title="5. 各类型页面详细情况"></a>5. 各类型页面详细情况</h4><h5 id="1-FSP-HDR-类型"><a href="#1-FSP-HDR-类型" class="headerlink" title="1. FSP_HDR 类型"></a>1. <code>FSP_HDR </code>类型</h5><p><img src="/./MySQL/NeatReader-1682822810511.png"></p>
<h6 id="File-Space-Header-部分"><a href="#File-Space-Header-部分" class="headerlink" title="File Space Header 部分"></a><code>File Space Header</code> 部分</h6><p><img src="/./MySQL/NeatReader-1682822865870.png"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Space ID</code></td>
<td><code>4 </code>字节</td>
<td>表空间的ID</td>
</tr>
<tr>
<td><code>Not Used</code></td>
<td><code>4 </code>字节</td>
<td>这4个字节未被使用，可以忽略</td>
</tr>
<tr>
<td><code>Size</code></td>
<td><code>4 </code>字节</td>
<td>当前表空间占有的页面数</td>
</tr>
<tr>
<td><code>FREE Limit</code></td>
<td><code>4 </code>字节</td>
<td>尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表</td>
</tr>
<tr>
<td><code>Space Flags</code></td>
<td><code>4 </code>字节</td>
<td>表空间的一些占用存储空间比较小的属性</td>
</tr>
<tr>
<td><code>FRAG_N_USED</code></td>
<td><code>4 </code>字节</td>
<td>FREE_FRAG链表中已使用的页面数量</td>
</tr>
<tr>
<td><code>List Base Node for FREE List</code></td>
<td><code>16 </code>字节</td>
<td>FREE链表的基节点</td>
</tr>
<tr>
<td><code>List Base Node for FREE_FRAG List</code></td>
<td><code>16 </code>字节</td>
<td>FREE_FRAG链表的基节点</td>
</tr>
<tr>
<td><code>List Base Node for FULL_FRAG List</code></td>
<td><code>16 </code>字节</td>
<td>FULL_FRAG链表的基节点</td>
</tr>
<tr>
<td><code>Next Unused Segment ID</code></td>
<td><code>8 </code>字节</td>
<td>当前表空间中下一个未使用的 Segment ID</td>
</tr>
<tr>
<td><code>List Base Node for SEG_INODES_FULL List</code></td>
<td><code>16 </code>字节</td>
<td>SEG_INODES_FULL链表的基节点</td>
</tr>
<tr>
<td><code>List Base Node for SEG_INODES_FREE List</code></td>
<td><code>16 </code>字节</td>
<td>SEG_INODES_FREE链表的基节点</td>
</tr>
</tbody></table>
<ul>
<li><p><code>FRAG_N_USED</code></p>
<p>这个字段表明在 <code>FREE_FRAG </code>链表中已经使用的页面数量。</p>
</li>
<li><p><code>FREE Limit</code></p>
<p>在该字段表示的页号之前的区都被初始化了，之后的区尚未被初始化。</p>
</li>
<li><p><code>Next Unused Segment ID</code></p>
<p>该字段表明当前表空间中最大的段ID的下一个ID，这样在创建新段的时候赋予新段一个唯一的ID值就so easy啦，直接使用这个字段的值就好了。</p>
</li>
<li><p><code>Space Flags</code></p>
<p>表空间对于一些布尔类型的属性。</p>
</li>
<li><p><code>List Base Node for SEG_INODES_FULL List </code>和 <code>List Base Node for SEG_INODES_FREE List</code></p>
<p>每个段对应的 <code>INODE Entry </code>结构会集中存放到一个类型为 <code>INODE </code>的页中，如果表空间中的段特别多，则会有多个 <code>INODE Entry </code>结构，可能一个页放不下，这些 <code>INODE </code>类型的页会组成两种列表：</p>
<ul>
<li><code>SEG_INODES_FULL </code>链表，该链表中的 <code>INODE </code>类型的页面都已经被 <code>INODE Entry </code>结构填充满了，没空闲空间存放额外的 <code>INODE Entry </code>了。</li>
<li><code>SEG_INODES_FREE </code>链表，该链表中的 <code>INODE </code>类型的页面仍有空闲空间来存放 <code>INODE Entry </code>结构。</li>
</ul>
</li>
</ul>
<h5 id="2-XDES-类型"><a href="#2-XDES-类型" class="headerlink" title="2. XDES 类型"></a>2. <code>XDES</code> 类型</h5><p><img src="/./MySQL/NeatReader-1682823267420.png"></p>
<p>与 <code>FSP_HDR </code>类型的页面对比，除了少了 <code>File Space Header </code>部分之外，也就是除了少了记录表空间整体属性的部分之外，其余的部分是一样一样的。</p>
<h5 id="3-IBUF-BITMAP-类型"><a href="#3-IBUF-BITMAP-类型" class="headerlink" title="3. IBUF_BITMAP 类型"></a>3. <code>IBUF_BITMAP</code> 类型</h5><p>这种类型的页里边记录了一些有关 <code>Change Buffer </code>的信息。</p>
<h5 id="4-INODE-类型"><a href="#4-INODE-类型" class="headerlink" title="4. INODE 类型"></a>4. <code>INODE </code>类型</h5><p><img src="/./MySQL/NeatReader-1682823421468.png"></p>
<h6 id="List-Node-for-INODE-Page-List-部分"><a href="#List-Node-for-INODE-Page-List-部分" class="headerlink" title="List Node for INODE Page List  部分"></a><code>List Node for INODE Page List </code> 部分</h6><ul>
<li><code>SEG_INODES_FULL </code>链表：该链表中的 <code>INODE </code>类型的页面中已经没有空闲空间来存储额外的 <code>INODE Entry </code>结构了。</li>
<li><code>SEG_INODES_FREE </code>链表：该链表中的 <code>INODE </code>类型的页面中还有空闲空间来存储额外的 <code>INODE Entry </code>结构了。</li>
</ul>
<h4 id="6-Segment-Header-结构的运用"><a href="#6-Segment-Header-结构的运用" class="headerlink" title="6. Segment Header 结构的运用"></a>6. Segment Header 结构的运用</h4><p>索引页中有一个<code>Page Header</code>部分：</p>
<p><strong>Page Header部分</strong> （为突出重点，省略了好多属性）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td><code>PAGE_BTR_SEG_LEAF</code></td>
<td><code>10 </code>字节</td>
<td>B+树叶子段的头部信息，仅在B+树的根页定义</td>
</tr>
<tr>
<td><code>PAGE_BTR_SEG_TOP</code></td>
<td><code>10 </code>字节</td>
<td>B+树非叶子段的头部信息，仅在B+树的根页定义</td>
</tr>
</tbody></table>
<p>对应的结构：</p>
<p><img src="/./MySQL/NeatReader-1682823700510.png"></p>
<p>各个部分的具体释义如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用字节数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Space ID of the INODE Entry</code></td>
<td><code>4</code></td>
<td>INODE Entry结构所在的表空间ID</td>
</tr>
<tr>
<td><code>Page Number of the INODE Entry</code></td>
<td><code>4</code></td>
<td>INODE Entry结构所在的页面页号</td>
</tr>
<tr>
<td><code>Byte Offset of the INODE Ent</code></td>
<td><code>2</code></td>
<td>INODE Entry结构在该页面中的偏移量</td>
</tr>
</tbody></table>
<p>这样便可以知道哪个段对应哪个 <code>INODE Entry </code>结构。</p>
<h3 id="二-系统表空间"><a href="#二-系统表空间" class="headerlink" title="二. 系统表空间"></a>二. 系统表空间</h3><h4 id="1-系统表空间的整体结构"><a href="#1-系统表空间的整体结构" class="headerlink" title="1. 系统表空间的整体结构"></a>1. 系统表空间的整体结构</h4><p><img src="/./MySQL/NeatReader-1682823928389.png"></p>
<table>
<thead>
<tr>
<th>页号</th>
<th>页面类型</th>
<th>英文描述</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>3</code></td>
<td><code>SYS</code></td>
<td>Insert Buffer Header</td>
<td>存储Insert Buffer的头部信息</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>INDEX</code></td>
<td>Insert Buffer Root</td>
<td>存储Insert Buffer的根页面</td>
</tr>
<tr>
<td><code>5</code></td>
<td><code>TRX_SYS</code></td>
<td>Transction System</td>
<td>事务系统的相关信息</td>
</tr>
<tr>
<td><code>6</code></td>
<td><code>SYS</code></td>
<td>First Rollback Segment</td>
<td>第一个回滚段的页面</td>
</tr>
<tr>
<td><code>7</code></td>
<td><code>SYS</code></td>
<td>Data Dictionary Header</td>
<td>数据字典头部信息</td>
</tr>
</tbody></table>
<h4 id="2-InnoDB-数据字典"><a href="#2-InnoDB-数据字典" class="headerlink" title="2. InnoDB 数据字典"></a>2. InnoDB 数据字典</h4><table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SYS_TABLES</code></td>
<td>整个InnoDB存储引擎中所有的表的信息</td>
</tr>
<tr>
<td><code>SYS_COLUMNS</code></td>
<td>整个InnoDB存储引擎中所有的列的信息</td>
</tr>
<tr>
<td><code>SYS_INDEXES</code></td>
<td>整个InnoDB存储引擎中所有的索引的信息</td>
</tr>
<tr>
<td><code>SYS_FIELDS</code></td>
<td>整个InnoDB存储引擎中所有的索引对应的列的信息</td>
</tr>
<tr>
<td><code>SYS_FOREIGN</code></td>
<td>整个InnoDB存储引擎中所有的外键的信息</td>
</tr>
<tr>
<td><code>SYS_FOREIGN_COLS</code></td>
<td>整个InnoDB存储引擎中所有的外键对应列的信息</td>
</tr>
<tr>
<td><code>SYS_TABLESPACES</code></td>
<td>整个InnoDB存储引擎中所有的表空间信息</td>
</tr>
<tr>
<td><code>SYS_DATAFILES</code></td>
<td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td>
</tr>
<tr>
<td><code>SYS_VIRTUAL</code></td>
<td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td>
</tr>
</tbody></table>
<p>为了存储获取到数据字典的信息，还需要数据字典的头部信息，即 <code>Data Dictionary Header </code>：</p>
<p><img src="/./MySQL/NeatReader-1682824193948.png"></p>
<ul>
<li><code>Max Row ID </code>：我们说过如果我们不显式的为表定义主键，而且表中也没有 <code>UNIQUE </code>索引，那么 <code>InnoDB </code>存储引擎会默认为我们生成一个名为 <code>row_id </code>的列作为主键。因为它是主键，所以每条记录的 <code>row_id </code>列的值不能重复。原则上只要一个表中的 <code>row_id </code>列不重复就可以了，也就是说表a和表b拥有一样的 <code>row_id </code>列也没啥关系，不过设计InnoDB的大叔只提供了这个 <code>Max Row ID </code>字段，不论哪个拥有 <code>row_id </code>列的表插入一条记录时，该记录的 <code>row_id </code>列的值就是 <code>Max Row ID </code>对应的值，然后再把 <code>Max Row ID </code>对应的值加1，也就是说这个 <code>Max Row ID </code>是全局共享的。</li>
<li><code>Max Table ID </code>：InnoDB存储引擎中的所有的表都对应一个唯一的ID，每次新建一个表时，就会把本字段的值作为该表的ID，然后自增本字段的值。</li>
<li><code>Max Index ID </code>：InnoDB存储引擎中的所有的索引都对应一个唯一的ID，每次新建一个索引时，就会把本字段的值作为该索引的ID，然后自增本字段的值。</li>
<li><code>Max Space ID </code>：InnoDB存储引擎中的所有的表空间都对应一个唯一的ID，每次新建一个表空间时，就会把本字段的值作为该表空间的ID，然后自增本字段的值。</li>
<li><code>Mix ID Low(Unused) </code>：这个字段没啥用，跳过。</li>
<li><code>Root of SYS_TABLES clust index </code>：本字段代表 <code>SYS_TABLES </code>表聚簇索引的根页面的页号。</li>
<li><code>Root of SYS_TABLE_IDS sec index </code>：本字段代表 <code>SYS_TABLES </code>表为 <code>ID </code>列建立的二级索引的根页面的页号。</li>
<li><code>Root of SYS_COLUMNS clust index </code>：本字段代表 <code>SYS_COLUMNS </code>表聚簇索引的根页面的页号。</li>
<li><code>Root of SYS_INDEXES clust index </code>本字段代表 <code>SYS_INDEXES </code>表聚簇索引的根页面的页号。</li>
<li><code>Root of SYS_FIELDS clust index </code>：本字段代表 <code>SYS_FIELDS </code>表聚簇索引的根页面的页号。</li>
<li><code>Unused </code>：这4个字节没用，跳过。</li>
</ul>
<h3 id="三-总结图"><a href="#三-总结图" class="headerlink" title="三. 总结图"></a>三. 总结图</h3><p><img src="/./MySQL/NeatReader-1682824362115.png"></p>
<hr>
<h2 id="单表访问方法"><a href="#单表访问方法" class="headerlink" title="单表访问方法"></a>单表访问方法</h2><p>一条查询语句经过<code>查询优化器</code>优化后生成<code>执行计划</code>，最后根据执行计划调用存储引擎提供的方法进行查询</p>
<h3 id="一-访问方法（access-method）的概念"><a href="#一-访问方法（access-method）的概念" class="headerlink" title="一. 访问方法（access method）的概念"></a>一. 访问方法（access method）的概念</h3><p>设计 <code>MySQL </code>的大叔把 <code>MySQL </code>执行查询语句的方式称之为 <code>访问方法 </code>或者 <code>访问类型 </code>。一条语句可以使用不同的访问方法来执行，但最终的查询结果是一样的。</p>
<h4 id="1-const"><a href="#1-const" class="headerlink" title="1. const"></a>1. const</h4><p>通过主键或者唯一二级索引列来定位一条记录的访问方法定义为： <code>const </code>，意思是常数级别的，代价是可以忽略不计的。</p>
<p><strong>条件：</strong></p>
<ul>
<li>只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效</li>
<li>主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。</li>
</ul>
<p>对于<code>NULL</code>值，由于可能访问到多条记录，因而无法使用<code>const</code>方法。</p>
<h4 id="2-ref"><a href="#2-ref" class="headerlink" title="2. ref"></a>2. ref</h4><p>搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为： <code>ref </code>。</p>
<p>注意两种情况：</p>
<ul>
<li><p>二级索引列值为 <code>NULL </code>的情况</p>
<p>最多只能使用<code>ref</code>访问方法，而不是<code>const</code>访问方法。</p>
</li>
<li><p>对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用 <code>ref </code>的访问方法。</p>
</li>
</ul>
<h4 id="3-range"><a href="#3-range" class="headerlink" title="3. range"></a>3. range</h4><p>利用索引进行范围匹配的访问方法称之为： <code>range </code>。</p>
<p>索引列等值匹配的情况称之为 <code>单点区间 </code>，否则称为<code>连续范围区间</code>。</p>
<h4 id="4-index"><a href="#4-index" class="headerlink" title="4. index"></a>4. index</h4><p><strong>条件：</strong></p>
<ul>
<li>查询列表中只包含某个索引的列，而不包含其它不属于该索引的列</li>
<li>搜索条件中的列部分或全部包含在该索引中</li>
</ul>
<p>此时我们只需要遍历该索引的<code>B+ 树</code>，找到满足条件的记录，又因为我们只需查询出指定的几个列，而且这几个列又恰好在索引中，那么直接将查询出的记录中提取出所需列的值加入到结果集中即可，这样无需进行<code>回表</code>操作，成本小很多，这种方式称为：<code>index</code>。</p>
<h4 id="5-all"><a href="#5-all" class="headerlink" title="5. all"></a>5. all</h4><p>使用全表扫描执行查询的方式称之为： <code>all </code>。</p>
<h3 id="二-注意事项"><a href="#二-注意事项" class="headerlink" title="二. 注意事项"></a>二. 注意事项</h3><h4 id="1-单个索引"><a href="#1-单个索引" class="headerlink" title="1. 单个索引"></a>1. 单个索引</h4><p>一般情况下，优化器只会利用单个二级索引执行查询，然后再从查询结果中根据其它条件进行过滤，最后返回结果。</p>
<h5 id="range-的范围区间"><a href="#range-的范围区间" class="headerlink" title="range 的范围区间"></a>range 的范围区间</h5><p>其实对于 <code>B+ </code>树索引来说，只要索引列和常数使用 <code>= </code>、 <code>&lt;=&gt; </code>、 <code>IN </code>、 <code>NOT IN </code>、 <code>IS NULL </code>、 <code>IS NOT NULL </code>、 <code>&gt; </code>、 <code>&lt; </code>、 <code>&gt;= </code>、 <code>&lt;= </code>、 <code>BETWEEN </code>、 <code>!= </code>（不等于也可以写成 <code>&lt;&gt; </code>）或者 <code>LIKE </code>操作符连接起来，就可以产生一个所谓的 <code>区间 </code>。</p>
<blockquote>
<p>LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引</p>
<p>IN操作符的效果和若干个等值匹配操作符<code>=</code>之间用<code>OR</code>连接起来是一样的，也就是说会产生多个单点区间</p>
</blockquote>
<p>优化查询时先把其它用不到索引的搜索条件替换为 TRUE ，即不考虑其对查询的影响，最后再过滤。</p>
<h4 id="2-索引合并"><a href="#2-索引合并" class="headerlink" title="2. 索引合并"></a>2. 索引合并</h4><p>某些特殊情况下，也可能在一个查询中使用到多个二级索引。</p>
<h5 id="Intersection-合并"><a href="#Intersection-合并" class="headerlink" title="Intersection 合并"></a>Intersection 合并</h5><p>比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure>

<p>假设这个查询使用 <code>Intersection </code>合并的方式执行的话，那这个过程就是这样的：</p>
<ul>
<li>从 <code>idx_key1 </code>二级索引对应的 <code>B+ </code>树中取出 <code>key1 = &#39;a&#39; </code>的相关记录。</li>
<li>从 <code>idx_key3 </code>二级索引对应的 <code>B+ </code>树中取出 <code>key3 = &#39;b&#39; </code>的相关记录。</li>
<li>二级索引的记录都是由 <code>索引列 + 主键 </code>构成的，所以我们可以计算出这两个结果集中 <code>id </code>值的交集。</li>
<li>按照上一步生成的 <code>id </code>值列表进行回表操作，也就是从聚簇索引中把指定 <code>id </code>值的完整用户记录取出来，返回给用户。</li>
</ul>
<p>读取多个二级索引得到的记录数肯定不多于读取一个二级索引得到的记录数。</p>
<p>若 <code>回表 </code>造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。</p>
<p><strong>条件：</strong></p>
<ul>
<li><p>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</p>
<p>这样可以在保证二级索引列值相同的情况下，查询的记录按照主键值进行排序，取交集时无需排序，性能更高。</p>
</li>
<li><p>主键列可以是范围匹配</p>
<p>此时没必要用到主键索引，只需在二级索引查询出的记录中根据主键列的范围进行过滤即可。</p>
</li>
</ul>
<p>这些只是发生 <code>Intersection </code>索引合并的必要条件，不是充分条件。</p>
<p>优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过 <code>Intersection </code>索引合并后需要回表的记录数大大减少时才会使用 <code>Intersection </code>索引合并。</p>
<h5 id="Union-合并"><a href="#Union-合并" class="headerlink" title="Union 合并"></a>Union 合并</h5><p>条件同Intersection合并相似，均为必要条件，不是充分条件。</p>
<p>优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过 <code>Union </code>索引合并后进行访问的代价比全表扫描更小时才会使用 <code>Union </code>索引合并。</p>
<h5 id="Sort-Union-合并"><a href="#Sort-Union-合并" class="headerlink" title="Sort-Union 合并"></a>Sort-Union 合并</h5><p> <code>Sort-Union </code>索引合并比单纯的 <code>Union </code>索引合并多了一步对二级索引记录的主键值排序的过程。</p>
<p>这样也拓宽了合并范围，不必满足等值匹配。</p>
<blockquote>
<p>为啥有Sort-Union索引合并，就没有Sort-Intersection索引合并么？是的，的确没有Sort-Intersection索引合并这么一说，</p>
<p>Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高</p>
<p>而Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了，所以也就没有引入Sort-Intersection这个玩意儿。</p>
</blockquote>
<h5 id="联合索引替代Intersection索引合并"><a href="#联合索引替代Intersection索引合并" class="headerlink" title="联合索引替代Intersection索引合并"></a>联合索引替代Intersection索引合并</h5><p>在搜索条件中出现的多个二级索引在一定条件下如果可以合并成一个联合索引，那么可以直接使用该联合索引进行查询，这样无需访问多棵<code>B+ 树</code>，减少开销。</p>
<blockquote>
<p>如果有对某个索引列进行单独查询的情况或者范围匹配等情况，尽量避免替代索引。</p>
</blockquote>
<hr>
<h2 id="连接的原理"><a href="#连接的原理" class="headerlink" title="连接的原理"></a>连接的原理</h2><h3 id="一-连接简介"><a href="#一-连接简介" class="headerlink" title="一. 连接简介"></a>一. 连接简介</h3><h4 id="1-连接的本质"><a href="#1-连接的本质" class="headerlink" title="1. 连接的本质"></a>1. 连接的本质</h4><p><code>连接 </code>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。</p>
<p>连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为 <code>笛卡尔积 </code>。</p>
<h4 id="2-连接过程"><a href="#2-连接过程" class="headerlink" title="2. 连接过程"></a>2. 连接过程</h4><p>以两表查询为例：</p>
<p>第一个需要查询的表为<code>驱动表</code>，将其单表查询后得出的结果集放到第二个表中过滤查询，第二个表被称为<code>被驱动表</code>，最后返回结果。</p>
<p>在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p>
<h5 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h5><p>本质：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集 。</p>
<ul>
<li><p>对于 <code>内连接 </code>的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的 <code>内连接 </code>。</p>
</li>
<li><p>对于 <code>外连接 </code>的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</p>
<p>在 <code>MySQL </code>中，根据选取驱动表的不同，外连接仍然可以细分为2种：</p>
<ul>
<li><p>左外连接</p>
<p>选取左侧的表为驱动表。</p>
</li>
<li><p>右外连接</p>
<p>选取右侧的表为驱动表。</p>
</li>
</ul>
</li>
</ul>
<p>过滤条件：</p>
<ul>
<li><p><code>WHERE </code>子句中的过滤条件</p>
<p><code>WHERE </code>子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合 <code>WHERE </code>子句中的过滤条件的记录都不会被加入最后的结果集。</p>
</li>
<li><p><code>ON </code>子句中的过滤条件</p>
<p>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 <code>ON </code>子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 <code>NULL </code>值填充。</p>
<p>内连接条件下，WHERE子句和ON子句是等价的 。</p>
</li>
</ul>
<p>一般情况下，我们都把只涉及单表的过滤条件放到 <code>WHERE </code>子句中，把涉及两表的过滤条件都放到 <code>ON </code>子句中，我们也一般把放到 <code>ON </code>子句中的过滤条件也称之为 <code>连接条件 </code>。</p>
<p>外连接必须使用 <code>ON </code>子句来指出连接条件 。</p>
<p><strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 [INNER | CROSS] JOIN 表名 [ON 连接条件] [WHERE 普通过滤条件]; // 内连接</span><br><span class="line">SELECT * FROM 表名 LEFT [OUTER] JOIN 表名 ON 连接条件 [WHERE 普通过滤条件]; // 左连接</span><br><span class="line">SELECT * FROM 表名 RIGHT [OUTER] JOIN 表名 ON 连接条件 [WHERE 普通过滤条件]; // 右连接</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句</li>
<li>对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果</li>
<li>左外连接和右外连接的驱动表和被驱动表不能轻易互换</li>
</ul>
<h4 id="3-连接的原理"><a href="#3-连接的原理" class="headerlink" title="3. 连接的原理"></a>3. 连接的原理</h4><h5 id="嵌套循环连接（Nested-Loop-Join）"><a href="#嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="嵌套循环连接（Nested-Loop Join）"></a>嵌套循环连接（Nested-Loop Join）</h5><p> 驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数 的连接执行方式称之为 <code>嵌套循环连接 </code>（ <code>Nested-Loop Join </code>），这是最简单，也是最笨拙的一种连接查询算法。</p>
<h5 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）"><a href="#基于块的嵌套循环连接（Block-Nested-Loop-Join）" class="headerlink" title="基于块的嵌套循环连接（Block Nested-Loop Join）"></a>基于块的嵌套循环连接（Block Nested-Loop Join）</h5><p>为了尽量减少访问被驱动表的次数，设计 <code>MySQL </code>的大叔提出了一个 <code>join buffer </code>的概念， <code>join buffer </code>就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 <code>join buffer </code>中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 <code>join buffer </code>中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 <code>I/O </code>代价。使用 <code>join buffer </code>的过程如下图所示：</p>
<p><img src="/./MySQL/NeatReader-1682910935459.png"></p>
<p>最好的情况是 <code>join buffer </code>足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。设计 <code>MySQL </code>的大叔把这种加入了 <code>join buffer </code>的嵌套循环连接算法称之为 <code>基于块的嵌套连接 </code>（Block Nested-Loop Join）算法。</p>
<p>这个 <code>join buffer </code>的大小是可以通过启动参数或者系统变量 <code>join_buffer_size </code>进行配置，默认大小为 <code>262144字节 </code>（也就是 <code>256KB </code>），最小可以设置为 <code>128字节 </code>。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大 <code>join_buffer_size </code>的值来对连接查询进行优化。</p>
<hr>
<h2 id="MySQL-基于成本的优化"><a href="#MySQL-基于成本的优化" class="headerlink" title="MySQL 基于成本的优化"></a>MySQL 基于成本的优化</h2><p>在 MySQL 中一条查询语句的执行成本由两个方面组成：</p>
<ul>
<li><p><code>I/O </code>成本（成本常数 1.0）</p>
<p>从磁盘到内存这个加载的过程损耗的时间称之为 <code>I/O </code>成本。</p>
</li>
<li><p><code>CPU </code>成本（成本常数 0.2）</p>
<p>读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 <code>CPU </code>成本。</p>
</li>
</ul>
<h3 id="一-单表查询的成本"><a href="#一-单表查询的成本" class="headerlink" title="一. 单表查询的成本"></a>一. 单表查询的成本</h3><h4 id="1-优化步骤"><a href="#1-优化步骤" class="headerlink" title="1. 优化步骤"></a>1. 优化步骤</h4><p><strong>流程：</strong></p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
<h5 id="1-根据搜索条件，找出所有可能使用的索引"><a href="#1-根据搜索条件，找出所有可能使用的索引" class="headerlink" title="1. 根据搜索条件，找出所有可能使用的索引"></a>1. 根据搜索条件，找出所有可能使用的索引</h5><p>搜索条件中可能使用到的索引称为<code>possible keys</code>。</p>
<h5 id="2-计算全表扫描的代价"><a href="#2-计算全表扫描的代价" class="headerlink" title="2. 计算全表扫描的代价"></a>2. 计算全表扫描的代价</h5><p>计算全表扫描的代价需要两个信息：</p>
<ul>
<li>聚簇索引占用的页面数</li>
<li>该表中的记录数</li>
</ul>
<p><strong>查看表的统计信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS LIKE 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>I/O </code>成本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">聚簇索引占用的页面数 × 1.0 + 1.1</span><br></pre></td></tr></table></figure>

<p>1.0 为成本常数，1.1 是规定的微调值。</p>
</li>
<li><p><code>CPU </code>成本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询出的记录总数 × 0.2 + 1.0</span><br></pre></td></tr></table></figure>

<p>0.2 为成本常数，1.0 是规定的微调值。</p>
</li>
</ul>
<h5 id="3-计算使用不同索引执行查询的代价"><a href="#3-计算使用不同索引执行查询的代价" class="headerlink" title="3. 计算使用不同索引执行查询的代价"></a>3. 计算使用不同索引执行查询的代价</h5><p>计算这种查询的成本依赖两个方面的数据：</p>
<ul>
<li><p>范围区间数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区间数量 × 1.0</span><br></pre></td></tr></table></figure>

<p>查询优化器粗暴的认为读取索引的一个范围区间的 <code>I/O </code>成本和读取一个页面是相同的。</p>
</li>
<li><p>需要回表的记录数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">记录总数 × 0.2 + 0.01</span><br></pre></td></tr></table></figure>

<p>0.01 是规定的微调值。</p>
</li>
</ul>
<p>在通过二级索引获取到记录之后，还需要干两件事儿：</p>
<ul>
<li><p>根据这些记录里的主键值到聚簇索引中做回表操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二级索引记录数 × 1.0 </span><br></pre></td></tr></table></figure>
</li>
<li><p>回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">记录数 × 0.2</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="4-对比各种执行方案的代价，找出成本最低的那一个"><a href="#4-对比各种执行方案的代价，找出成本最低的那一个" class="headerlink" title="4. 对比各种执行方案的代价，找出成本最低的那一个"></a>4. 对比各种执行方案的代价，找出成本最低的那一个</h5><h4 id="2-基于索引统计数据的成本计算"><a href="#2-基于索引统计数据的成本计算" class="headerlink" title="2. 基于索引统计数据的成本计算"></a>2. 基于索引统计数据的成本计算</h4><p>通过直接访问索引对应的 <code>B+ </code>树来计算某个范围区间对应的索引记录条数的方式称之为 <code>index dive </code>。</p>
<p>当区间过多时，计算这些区间对应的记录条数成本可能非常大，因而我们需要采取<code>索引统计数据</code>的方法。</p>
<p><strong>查看索引统计数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM 表名;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Table</code></td>
<td>索引所属表的名称。</td>
</tr>
<tr>
<td align="center"><code>Non_unique</code></td>
<td>索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为 <code>0 </code>，普通二级索引该列值为 <code>1 </code>。</td>
</tr>
<tr>
<td align="center"><code>Key_name</code></td>
<td>索引的名称。</td>
</tr>
<tr>
<td align="center"><code>Seq_in_index</code></td>
<td>索引列在索引中的位置，从1开始计数。比如对于联合索引 <code>idx_key_part </code>，来说， <code>key_part1 </code>、 <code>key_part2 </code>和 <code>key_part3 </code>对应的位置分别是1、2、3。</td>
</tr>
<tr>
<td align="center"><code>Column_name</code></td>
<td>索引列的名称。</td>
</tr>
<tr>
<td align="center"><code>Collation</code></td>
<td>索引列中的值是按照何种排序方式存放的，值为 <code>A </code>时代表升序存放，为 <code>NULL </code>时代表降序存放。</td>
</tr>
<tr>
<td align="center"><code>Cardinality</code></td>
<td>索引列中不重复值的数量。后边我们会重点看这个属性的。（估计值，即基数）</td>
</tr>
<tr>
<td align="center"><code>Sub_part</code></td>
<td>对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前 <code>n </code>个字符或字节建立索引，这个属性表示的就是那个 <code>n </code>值。如果对完整的列建立索引的话，该属性的值就是 <code>NULL </code>。</td>
</tr>
<tr>
<td align="center"><code>Packed</code></td>
<td>索引列如何被压缩， <code>NULL </code>值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。</td>
</tr>
<tr>
<td align="center"><code>Null</code></td>
<td>该索引列是否允许存储 <code>NULL </code>值。</td>
</tr>
<tr>
<td align="center"><code>Index_type</code></td>
<td>使用索引的类型，我们最常见的就是 <code>BTREE </code>，其实也就是 <code>B+ </code>树索引。</td>
</tr>
<tr>
<td align="center"><code>Comment</code></td>
<td>索引列注释信息。</td>
</tr>
<tr>
<td align="center"><code>Index_comment</code></td>
<td>索引注释信息。</td>
</tr>
</tbody></table>
<p>这里所指的 <code>索引统计数据 </code>指的是这两个值：</p>
<ul>
<li><p>使用 <code>SHOW TABLE STATUS </code>展示出的 <code>Rows </code>值，也就是一个表中有多少条记录。</p>
</li>
<li><p>使用 <code>SHOW INDEX </code>语句展示出的 <code>Cardinality </code>属性。</p>
<p>结合上一个 <code>Rows </code>统计数据，我们可以针对索引列，计算出平均一个值重复多少次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个值的重复次数 ≈ Rows ÷ Cardinality</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二-连接查询的成本"><a href="#二-连接查询的成本" class="headerlink" title="二. 连接查询的成本"></a>二. 连接查询的成本</h3><h4 id="Condition-filtering"><a href="#Condition-filtering" class="headerlink" title="Condition filtering"></a>Condition filtering</h4><p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的 <code>扇出 </code>（英文名： <code>fanout </code>）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。</p>
<p>这个过程即为<code>Condition filtering</code></p>
<h4 id="两表连接的成本分析"><a href="#两表连接的成本分析" class="headerlink" title="两表连接的成本分析"></a>两表连接的成本分析</h4><p>连接查询的成本计算公式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</span><br></pre></td></tr></table></figure>

<p>对于外连接，考虑：</p>
<ul>
<li>分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>对于内连接，考虑：</p>
<ul>
<li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li>
<li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>连接查询成本占大头的其实是 <code>驱动表扇出数 x 单次访问被驱动表的成本 </code>，所以我们的优化重点其实是下边这两个部分：</p>
<ul>
<li><p>尽量减少驱动表的扇出</p>
</li>
<li><p>对被驱动表的访问成本尽量低</p>
<p>尽量在被驱动表的连接列上建立索引</p>
</li>
</ul>
<h4 id="多表连接的成本分析"><a href="#多表连接的成本分析" class="headerlink" title="多表连接的成本分析"></a>多表连接的成本分析</h4><p>减少计算非常多种连接顺序的成本的方法：</p>
<ul>
<li><p>提前结束某种顺序的成本评估</p>
<p>维护一个全局的变量，这个变量表示当前最小的连接查询成本。若在分析某个连接顺序的成本时，其成本已经超过当前最小的连接查询成本，则无需再往下分析。</p>
</li>
<li><p>系统变量 <code>optimizer_search_depth</code></p>
<p>为了防止无穷无尽的分析各种连接顺序的成本，设计 <code>MySQL </code>的大叔们提出了 <code>optimizer_search_depth </code>系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与 <code>optimizer_search_depth </code>值相同数量的表进行穷举分析。</p>
</li>
<li><p>根据某些规则压根儿就不考虑某些连接顺序</p>
<p>根据一些<code>启发式规则</code>直接过滤掉一些连接顺序。系统变量 <code>optimizer_prune_level </code>来控制到底是不是用这些启发式规则。</p>
</li>
</ul>
<h3 id="三-调节成本常数"><a href="#三-调节成本常数" class="headerlink" title="三. 调节成本常数"></a>三. 调节成本常数</h3><p>成本常数被存储到了<code>mysql</code>数据库（一个系统数据库）。</p>
<p><strong>查看成本常数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES FROM mysql LIKE &#x27;%cost%&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>修改成本常数</strong></p>
<p>修改指定表的内容，然后重新加载这个表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS; // 重新加载</span><br></pre></td></tr></table></figure>

<p>主要分为<code>server</code>层和<code>engine</code>层：</p>
<ul>
<li><p><code>server</code></p>
<p>主要是创建临时表的成本</p>
</li>
<li><p><code>engine</code></p>
<p>主要是读取<code>块</code>的成本</p>
</li>
</ul>
<hr>
<h2 id="InnoDB-统计数据是如何收集的"><a href="#InnoDB-统计数据是如何收集的" class="headerlink" title="InnoDB 统计数据是如何收集的"></a>InnoDB 统计数据是如何收集的</h2><p>两种不同的统计数据存储方式：</p>
<ul>
<li><p>永久性的统计数据</p>
<p>这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。</p>
</li>
<li><p>非永久性的统计数据</p>
<p>这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。</p>
</li>
</ul>
<p>系统变量 <code>innodb_stats_persistent </code>控制到底采用哪种方式去存储统计数据。</p>
<p> <code>InnoDB </code>默认是 以表为单位来收集和存储统计数据的。</p>
<p>创建和修改表的时候通过指定 <code>STATS_PERSISTENT </code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0);</span><br></pre></td></tr></table></figure>

<p>1 表示永久，0 表示非永久，如果我们在创建表时未指定 <code>STATS_PERSISTENT </code>属性，那默认采用系统变量 <code>innodb_stats_persistent </code>的值作为该属性的值。</p>
<h3 id="一-基于磁盘的永久性统计数据"><a href="#一-基于磁盘的永久性统计数据" class="headerlink" title="一. 基于磁盘的永久性统计数据"></a>一. 基于磁盘的永久性统计数据</h3><p> <code>mysql </code>系统数据库下的两个表：</p>
<ul>
<li><code>innodb_table_stats </code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li>
<li><code>innodb_index_stats </code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li>
</ul>
<h4 id="innodb-table-stats"><a href="#innodb-table-stats" class="headerlink" title="innodb_table_stats"></a>innodb_table_stats</h4><table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>database_name</code></td>
<td align="left">数据库名</td>
</tr>
<tr>
<td align="center"><code>table_name</code></td>
<td align="left">表名</td>
</tr>
<tr>
<td align="center"><code>last_update</code></td>
<td align="left">本条记录最后更新时间</td>
</tr>
<tr>
<td align="center"><code>n_rows</code></td>
<td align="left">表中记录的条数</td>
</tr>
<tr>
<td align="center"><code>clustered_index_size</code></td>
<td align="left">表的聚簇索引占用的页面数量</td>
</tr>
<tr>
<td align="center"><code>sum_of_other_index_sizes</code></td>
<td align="left">表的其他索引占用的页面数量</td>
</tr>
</tbody></table>
<p>注意这个表的主键是 <code>(database_name,table_name) </code>，也就是 innodb_table_stats表的每条记录代表着一个表的统计信息 。</p>
<h5 id="n-rows统计项的收集"><a href="#n-rows统计项的收集" class="headerlink" title="n_rows统计项的收集"></a>n_rows统计项的收集</h5><p>按照一定算法（并不是纯粹随机的）选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的 <code>n_rows </code>值。</p>
<p><code>innodb_stats_persistent_sample_pages </code>系统变量来控制 使用永久性的统计数据时，计算统计数据时采样的页面数量 。</p>
<p>创建或修改表的时候通过指定 <code>STATS_SAMPLE_PAGES </code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;</span><br></pre></td></tr></table></figure>

<h5 id="clustered-index-size和sum-of-other-index-sizes统计项的收集"><a href="#clustered-index-size和sum-of-other-index-sizes统计项的收集" class="headerlink" title="clustered_index_size和sum_of_other_index_sizes统计项的收集"></a>clustered_index_size和sum_of_other_index_sizes统计项的收集</h5><p>收集过程：</p>
<ul>
<li>从数据字典里找到表的各个索引对应的根页面位置。</li>
<li>从根页面的 <code>Page Header </code>里找到叶子节点段和非叶子节点段对应的 <code>Segment Header </code>。</li>
<li>从叶子节点段和非叶子节点段的 <code>Segment Header </code>中找到这两个段对应的 <code>INODE Entry </code>结构。</li>
<li>从对应的 <code>INODE Entry </code>结构中可以找到该段对应所有零散的页面地址以及 <code>FREE </code>、 <code>NOT_FULL </code>、 <code>FULL </code>链表的基节点。</li>
<li>直接统计零散的页面有多少个，然后从那三个链表的 <code>List Length </code>字段中读出该段占用的区的大小，每个区占用 <code>64 </code>个页，所以就可以统计出整个段占用的页面。</li>
<li>分别计算聚簇索引的叶子结点段和非叶子节点段占用的页面数，它们的和就是 <code>clustered_index_size </code>的值，按照同样的套路把其余索引占用的页面数都算出来，加起来之后就是 <code>sum_of_other_index_sizes </code>的值。</li>
</ul>
<h4 id="innodb-index-stats"><a href="#innodb-index-stats" class="headerlink" title="innodb_index_stats"></a>innodb_index_stats</h4><table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>database_name</code></td>
<td align="left">数据库名</td>
</tr>
<tr>
<td align="center"><code>table_name</code></td>
<td align="left">表名</td>
</tr>
<tr>
<td align="center"><code>index_name</code></td>
<td align="left">索引名</td>
</tr>
<tr>
<td align="center"><code>last_update</code></td>
<td align="left">本条记录最后更新时间</td>
</tr>
<tr>
<td align="center"><code>stat_name</code></td>
<td align="left">统计项的名称</td>
</tr>
<tr>
<td align="center"><code>stat_value</code></td>
<td align="left">对应的统计项的值</td>
</tr>
<tr>
<td align="center"><code>sample_size</code></td>
<td align="left">为生成统计数据而采样的页面数量</td>
</tr>
<tr>
<td align="center"><code>stat_description</code></td>
<td align="left">对应的统计项的描述</td>
</tr>
</tbody></table>
<p>注意这个表的主键是 <code>(database_name,table_name,index_name,stat_name) </code>，其中的 <code>stat_name </code>是指统计项的名称，也就是说 innodb_index_stats表的每条记录代表着一个索引的一个统计项 。</p>
<ul>
<li><code>n_leaf_pages </code>：表示该索引的叶子节点占用多少页面。</li>
<li><code>size </code>：表示该索引共占用多少页面。</li>
<li><code>n_diff_pfx NN </code>：表示对应的索引列不重复的值有多少。</li>
<li>在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样， <code>sample_size </code>列就表明了采样的页面数量是多少。</li>
</ul>
<h4 id="定期更新统计数据"><a href="#定期更新统计数据" class="headerlink" title="定期更新统计数据"></a>定期更新统计数据</h4><ul>
<li><p>开启 <code>innodb_stats_auto_recalc </code>。</p>
<p>如果发生变动的记录数量超过了表大小的 <code>10% </code>，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新 <code>innodb_table_stats </code>和 <code>innodb_index_stats </code>表。不过 自动重新计算统计数据的过程是异步发生的 ，也就是即使表中变动的记录数超过了 <code>10% </code>，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。</p>
</li>
<li><p>手动调用 <code>ANALYZE TABLE </code>语句来更新统计信息</p>
<p><code>ANALYZE TABLE</code>语句会立即重新计算统计数据，也就是这个过程是同步的 ，在表中索引多或者采样页面特别多时这个过程可能会特别慢.</p>
</li>
</ul>
<h4 id="手动更新-innodb-table-stats-和-innodb-index-stats-表"><a href="#手动更新-innodb-table-stats-和-innodb-index-stats-表" class="headerlink" title="手动更新 innodb_table_stats 和 innodb_index_stats 表"></a>手动更新 <code>innodb_table_stats </code>和 <code>innodb_index_stats </code>表</h4><p>更新指定表的内容，然后重新加载表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH TABLE 表名;</span><br></pre></td></tr></table></figure>

<h3 id="二-基于内存的非永久性统计数据"><a href="#二-基于内存的非永久性统计数据" class="headerlink" title="二. 基于内存的非永久性统计数据"></a>二. 基于内存的非永久性统计数据</h3><p>与永久性的统计数据不同，非永久性的统计数据采样的页面数量是由 <code>innodb_stats_transient_sample_pages </code>控制的，这个系统变量的默认值是 <code>8 </code>。</p>
<p>对于<code>NULL</code>值的处理：</p>
<ul>
<li><code>nulls_equal </code>：认为所有 <code>NULL </code>值都是相等的。这个值也是 <code>innodb_stats_method </code>的默认值。</li>
<li><code>nulls_unequal </code>：认为所有 <code>NULL </code>值都是不相等的。</li>
<li><code>nulls_ignored </code>：直接把 <code>NULL </code>值忽略掉。</li>
</ul>
<p> 最好不在索引列中存放<code>NULL</code>值才是正解。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>InnoDB </code>以表为单位来收集统计数据，这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据。</li>
<li><code>innodb_stats_persistent </code>控制着使用永久性统计数据还是非永久性统计数据； <code>innodb_stats_persistent_sample_pages </code>控制着永久性统计数据的采样页面数量； <code>innodb_stats_transient_sample_pages </code>控制着非永久性统计数据的采样页面数量； <code>innodb_stats_auto_recalc </code>控制着是否自动重新计算统计数据。</li>
<li>我们可以针对某个具体的表，在创建和修改表时通过指定 <code>STATS_PERSISTENT </code>、 <code>STATS_AUTO_RECALC </code>、 <code>STATS_SAMPLE_PAGES </code>的值来控制相关统计数据属性。</li>
<li><code>innodb_stats_method </code>决定着在统计某个索引列不重复值的数量时如何对待 <code>NULL </code>值。</li>
</ul>
<hr>
<h2 id="MySQL-基于规则的优化"><a href="#MySQL-基于规则的优化" class="headerlink" title="MySQL 基于规则的优化"></a>MySQL 基于规则的优化</h2><h3 id="一-条件化简"><a href="#一-条件化简" class="headerlink" title="一. 条件化简"></a>一. 条件化简</h3><ul>
<li><p>移除不必要的括号</p>
</li>
<li><p>常量传递（constant_propagation）</p>
</li>
<li><p>等值传递（equality_propagation）</p>
</li>
<li><p>移除没用的条件（trivial_condition_removal）</p>
</li>
<li><p>表达式计算</p>
<p>如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABS(a) &gt; 5</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a &lt; -8</span><br></pre></td></tr></table></figure>

<p>优化器是不会尝试对这些表达式进行化简的 。</p>
</li>
<li><p>HAVING子句和WHERE子句的合并</p>
<p>如果查询语句中没有出现诸如 <code>SUM </code>、 <code>MAX </code>等等的聚集函数以及 <code>GROUP BY </code>子句，优化器就把 <code>HAVING </code>子句和 <code>WHERE </code>子句合并起来。</p>
</li>
<li><p>常量表检测</p>
<ul>
<li>查询的表中一条记录没有，或者只有一条记录。</li>
<li>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。</li>
</ul>
<p>设计 <code>MySQL </code>的大叔觉得这两种查询花费的时间特别少，少到可以忽略，所以也把通过这两种方式查询的表称之为 <code>常量表 </code>（英文名： <code>constant tables </code>）。优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。</p>
</li>
<li><p>外连接消除</p>
<p>外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃 。</p>
<p>在外连接查询中，指定的 <code>WHERE </code>子句中包含被驱动表中的列不为 <code>NULL </code>值的条件称之为 <code>空值拒绝 </code>（英文名： <code>reject-NULL </code>）。 在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换 。</p>
</li>
</ul>
<h3 id="二-子查询优化"><a href="#二-子查询优化" class="headerlink" title="二. 子查询优化"></a>二. 子查询优化</h3><h4 id="1-按返回的结果集区分子查询"><a href="#1-按返回的结果集区分子查询" class="headerlink" title="1. 按返回的结果集区分子查询"></a>1. 按返回的结果集区分子查询</h4><ul>
<li><p>标量子查询</p>
<p>示例：<code>SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);</code></p>
<p>只返回一个单一值的子查询称之为 <code>标量子查询 </code>。</p>
</li>
<li><p>行子查询</p>
<p>示例：<code>SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);</code></p>
<p>返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。</p>
</li>
<li><p>列子查询</p>
<p>示例：<code>SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);</code></p>
<p>查询出一个列的数据，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询了）。</p>
</li>
<li><p>表子查询</p>
<p>示例：<code>SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);</code></p>
<p>子查询的结果既包含很多条记录，又包含很多个列。</p>
</li>
</ul>
<h4 id="2-按与外层查询关系来区分子查询"><a href="#2-按与外层查询关系来区分子查询" class="headerlink" title="2. 按与外层查询关系来区分子查询"></a>2. 按与外层查询关系来区分子查询</h4><ul>
<li><p>相关子查询</p>
<p>如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为 <code>不相关子查询 </code>。</p>
</li>
<li><p>不相关子查询</p>
<p>如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为 <code>相关子查询 </code>。</p>
</li>
</ul>
<h4 id="3-子查询在布尔表达式中的使用"><a href="#3-子查询在布尔表达式中的使用" class="headerlink" title="3. 子查询在布尔表达式中的使用"></a>3. 子查询在布尔表达式中的使用</h4><ul>
<li><p>使用 <code>= </code>、 <code>&gt; </code>、 <code>&lt; </code>、 <code>&gt;= </code>、 <code>&lt;= </code>、 <code>&lt;&gt; </code>、 <code>!= </code>、 <code>&lt;=&gt; </code>作为布尔表达式的操作符</p>
<p><code>操作数 comparison_operator (子查询)</code></p>
<p>这里的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能返回一个单一的值或者只能是一条记录 。</p>
</li>
<li><p><code>[NOT] IN/ANY/SOME/ALL</code>子查询</p>
<ul>
<li><p><code>IN </code>或者 <code>NOT IN</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作数 [NOT] IN (子查询)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ANY/SOME </code>（ <code>ANY </code>和 <code>SOME </code>是同义词）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作数 comparison_operator ANY/SOME(子查询)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ALL</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作数 comparison_operator ALL(子查询)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>EXISTS</code>子查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[NOT] EXISTS (子查询)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>子查询必须用小括号扩起来。</li>
<li>在 <code>SELECT </code>子句中的子查询必须是标量子查询。</li>
<li>在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用 <code>LIMIT 1 </code>语句来限制记录数量。</li>
<li>对于 <code>[NOT] IN/ANY/SOME/ALL </code>子查询来说，子查询中不允许有 <code>LIMIT </code>语句。</li>
<li>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</li>
</ul>
<h4 id="4-子查询的执行"><a href="#4-子查询的执行" class="headerlink" title="4. 子查询的执行"></a>4. 子查询的执行</h4><p>不相关子查询：</p>
<ul>
<li>先单独执行这个子查询。</li>
<li>将上一步得到的结果当作外层查询的参数再执行外层查询 。</li>
</ul>
<p>相关子查询：</p>
<ul>
<li>先从外层查询中获取一条记录。</li>
<li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，然后执行子查询。</li>
<li>最后根据子查询的查询结果来检测外层查询 <code>WHERE </code>子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li>
<li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li>
</ul>
<h4 id="5-IN子查询优化"><a href="#5-IN子查询优化" class="headerlink" title="5. IN子查询优化"></a>5. <code>IN</code>子查询优化</h4><h5 id="物化表的提出"><a href="#物化表的提出" class="headerlink" title="物化表的提出"></a>物化表的提出</h5><p>不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里 。写入临时表的过程是这样的：</p>
<ul>
<li><p>该临时表的列就是子查询结果集中的列。</p>
</li>
<li><p>写入临时表的记录会被去重。</p>
</li>
<li><p>一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用 <code>Memory </code>存储引擎的临时表，而且会为该表建立哈希索引。</p>
<p>如果子查询的结果集非常大，超过了系统变量 <code>tmp_table_size </code>或者 <code>max_heap_table_size </code>，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为 <code>B+ </code>树索引。</p>
</li>
</ul>
<p>这个将子查询结果集中的记录保存到临时表的过程称之为 <code>物化 </code>（英文名： <code>Materialize </code>）。为了方便起见，我们就把那个存储子查询结果集的临时表称之为 <code>物化表 </code>。由于物化表索引的存在，子查询语句性能等到提升。</p>
<h5 id="物化表转连接"><a href="#物化表转连接" class="headerlink" title="物化表转连接"></a>物化表转连接</h5><p>子查询结果集转成物化表后就相当于两表查询，某些情况下可以转换成连接。</p>
<h5 id="子查询转换为semi-join"><a href="#子查询转换为semi-join" class="headerlink" title="子查询转换为semi-join"></a>子查询转换为semi-join</h5><p><code>半连接 </code>（英文名： <code>semi-join </code>）：对于一个表的某条记录来说，我们只关心在另一个表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留第一个表的记录 。</p>
<p><strong>实现方法：</strong></p>
<ul>
<li><p>Table pullout （子查询中的表上拉）</p>
<p>当 子查询的查询列表处只有主键或者唯一索引列 时，可以直接把子查询中的表 <code>上拉 </code>到外层查询的 <code>FROM </code>子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中。</p>
</li>
<li><p>DuplicateWeedout execution strategy （重复值消除）</p>
<p>对于这个查询来说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure>

<p>转换为半连接查询后， <code>s1 </code>表中的某条记录可能在 <code>s2 </code>表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中，为了消除重复，我们可以建立一个临时表，比方说这个临时表长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tmp (</span><br><span class="line">    id PRIMARY KEY</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这样在执行连接查询的过程中，每当某条 <code>s1 </code>表中的记录要加入结果集时，就首先把这条记录的 <code>id </code>值加入到这个临时表里，如果添加成功，说明之前这条 <code>s1 </code>表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，说明之前这条 <code>s1 </code>表中的记录已经加入过最终的结果集，这里直接把它丢弃就好了，这种使用临时表消除 <code>semi-join </code>结果集中的重复值的方式称之为 <code>DuplicateWeedout </code>。</p>
</li>
<li><p>LooseScan execution strategy （松散扫描）</p>
<p>扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为 <code>松散扫描 </code>。</p>
</li>
<li><p>Semi-join Materialization execution strategy</p>
<p>即物化表。</p>
</li>
<li><p>FirstMatch execution strategy （首次匹配）</p>
<p>即相关子查询的执行方式。</p>
<p>由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询。</p>
</li>
</ul>
<h6 id="semi-join的适用条件"><a href="#semi-join的适用条件" class="headerlink" title="semi-join的适用条件"></a>semi-join的适用条件</h6><ul>
<li>该子查询必须是和 <code>IN </code>语句组成的布尔表达式，并且在外层查询的 <code>WHERE </code>或者 <code>ON </code>子句中出现。</li>
<li>外层查询也可以有其他的搜索条件，只不过和 <code>IN </code>子查询的搜索条件必须使用 <code>AND </code>连接起来。</li>
<li>该子查询必须是一个单一的查询，不能是由若干查询由 <code>UNION </code>连接起来的形式。</li>
<li>该子查询不能包含 <code>GROUP BY </code>或者 <code>HAVING </code>语句或者聚集函数。</li>
</ul>
<h6 id="不适用于semi-join的情况"><a href="#不适用于semi-join的情况" class="headerlink" title="不适用于semi-join的情况"></a>不适用于semi-join的情况</h6><ul>
<li>外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用 <code>OR </code>连接起来</li>
<li>使用 <code>NOT IN </code>而不是 <code>IN </code>的情况</li>
<li>在 <code>SELECT </code>子句中的IN子查询的情况</li>
<li>子查询中包含 <code>GROUP BY </code>、 <code>HAVING </code>或者聚集函数的情况</li>
<li>子查询中包含 <code>UNION </code>的情况</li>
</ul>
<p>对于不能转为 <code>semi-join </code>查询的子查询：</p>
<ul>
<li>对于不相关子查询来说，可以尝试把它们物化之后再参与查询</li>
<li>不管子查询是相关的还是不相关的，都可以把 <code>IN </code>子查询尝试转为 <code>EXISTS </code>子查询</li>
</ul>
<h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><ul>
<li><p>如果 <code>IN </code>子查询符合转换为 <code>semi-join </code>的条件，查询优化器会优先把该子查询转换为 <code>semi-join </code>，然后再考虑下边5种执行半连接的策略中哪个成本最低：</p>
<ul>
<li>Table pullout</li>
<li>DuplicateWeedout</li>
<li>LooseScan</li>
<li>Materialization</li>
<li>FirstMatch</li>
</ul>
<p>选择成本最低的那种执行策略来执行子查询。</p>
</li>
<li><p>如果 <code>IN </code>子查询不符合转换为 <code>semi-join </code>的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：</p>
<ul>
<li>先将子查询物化之后再执行查询</li>
<li>执行 <code>IN to EXISTS </code>转换。</li>
</ul>
</li>
</ul>
<h4 id="6-派生表优化"><a href="#6-派生表优化" class="headerlink" title="6. 派生表优化"></a>6. 派生表优化</h4><p>子查询放在外层查询的 <code>FROM </code>子句后，那么这个子查询的结果相当于一个 <code>派生表 </code>。</p>
<ul>
<li>派生表物化</li>
<li>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</li>
</ul>
<hr>
<h2 id="Explain-详解"><a href="#Explain-详解" class="headerlink" title="Explain 详解"></a>Explain 详解</h2><p>Explain 输出列作用：</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>id</code></td>
<td align="left">在一个大的查询语句中每个 <code>SELECT </code>关键字都对应一个唯一的 <code>id</code></td>
</tr>
<tr>
<td align="center"><code>select_type</code></td>
<td align="left"><code>SELECT </code>关键字对应的那个查询的类型</td>
</tr>
<tr>
<td align="center"><code>table</code></td>
<td align="left">表名</td>
</tr>
<tr>
<td align="center"><code>partitions</code></td>
<td align="left">匹配的分区信息</td>
</tr>
<tr>
<td align="center"><code>type</code></td>
<td align="left">针对单表的访问方法</td>
</tr>
<tr>
<td align="center"><code>possible_keys</code></td>
<td align="left">可能用到的索引</td>
</tr>
<tr>
<td align="center"><code>key</code></td>
<td align="left">实际上使用的索引</td>
</tr>
<tr>
<td align="center"><code>key_len</code></td>
<td align="left">实际使用到的索引长度</td>
</tr>
<tr>
<td align="center"><code>ref</code></td>
<td align="left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td align="center"><code>rows</code></td>
<td align="left">预估的需要读取的记录条数</td>
</tr>
<tr>
<td align="center"><code>filtered</code></td>
<td align="left">某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td align="center"><code>Extra</code></td>
<td align="left">一些额外的信息</td>
</tr>
</tbody></table>
<h3 id="一-执行计划输出中各列详解"><a href="#一-执行计划输出中各列详解" class="headerlink" title="一. 执行计划输出中各列详解"></a>一. 执行计划输出中各列详解</h3><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>查询语句中每出现一个 <code>SELECT </code>关键字，优化器就会为它分配一个唯一的 id 值。</p>
<p>对于连接查询来说，一个 <code>SELECT </code>关键字后边的 <code>FROM </code>子句中可以跟随多个表，所以在连接查询的执行计划中， 每个表都会对应一条记录，但是这些记录的id值都是相同的。在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表。</p>
<p>对于包含子查询的查询语句来说，就可能涉及多个 <code>SELECT </code>关键字，所以在包含子查询的查询语句的执行计划中，每个 <code>SELECT </code>关键字都会对应一个唯一的 <code>id </code>值。需要注意的是，查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询，此时它们的id值便是相同的，因此可以判断优化器是否将子查询转化成了连接查询。</p>
<p>对于<code>UNION</code>查询，需要将多个查询的结果集合并起来并去重，需要构建临时表，因而执行计划中会产生一个id为NULL的记录，但对于<code>UNION ALL</code>则无需去重。</p>
<h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>SIMPLE</code></td>
<td align="left">Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td align="center"><code>PRIMARY</code></td>
<td align="left">Outermost SELECT</td>
</tr>
<tr>
<td align="center"><code>UNION</code></td>
<td align="left">Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td align="center"><code>UNION RESULT</code></td>
<td align="left">Result of a UNION</td>
</tr>
<tr>
<td align="center"><code>SUBQUERY</code></td>
<td align="left">First SELECT in subquery</td>
</tr>
<tr>
<td align="center"><code>DEPENDENT SUBQUERY</code></td>
<td align="left">First SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td align="center"><code>DEPENDENT UNION</code></td>
<td align="left">Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td align="center"><code>DERIVED</code></td>
<td align="left">Derived table</td>
</tr>
<tr>
<td align="center"><code>MATERIALIZED</code></td>
<td align="left">Materialized subquery</td>
</tr>
<tr>
<td align="center"><code>UNCACHEABLE SUBQUERY</code></td>
<td align="left">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td align="center"><code>UNCACHEABLE UNION</code></td>
<td align="left">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<ul>
<li><p>SIMPLE</p>
<p>查询语句中不包含 <code>UNION </code>或者子查询的查询都算作是 <code>SIMPLE </code>类型</p>
</li>
<li><p>PRIMARY</p>
<p>对于包含 <code>UNION </code>、 <code>UNION ALL </code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 <code>select_type </code>值就是 <code>PRIMARY</code></p>
</li>
<li><p>UNION</p>
<p>对于包含 <code>UNION </code>或者 <code>UNION ALL </code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 <code>select_type </code>值就是 <code>UNION </code></p>
</li>
<li><p>UNION RESULT</p>
<p>使用临时表来完成 <code>UNION </code>查询的去重工作，针对该临时表的查询的 <code>select_type </code>就是 <code>UNION RESULT </code></p>
</li>
<li><p>SUBQUERY</p>
<p>如果包含子查询的查询语句不能够转为对应的 <code>semi-join </code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个 <code>SELECT </code>关键字代表的那个查询的 <code>select_type </code>就是 <code>SUBQUERY</code>。</p>
<p>由于select_type为SUBQUERY的子查询会被物化，所以只需要执行一遍。</p>
</li>
<li><p>DEPENDENT SUBQUERY</p>
<p>如果包含子查询的查询语句不能够转为对应的 <code>semi-join </code>的形式，并且该子查询是相关子查询，则该子查询的第一个 <code>SELECT </code>关键字代表的那个查询的 <code>select_type </code>就是 <code>DEPENDENT SUBQUERY </code>。</p>
<p>select_type为DEPENDENT SUBQUERY的查询可能会被执行多次。</p>
</li>
<li><p>DEPENDENT UNION</p>
<p>在包含 <code>UNION </code>或者 <code>UNION ALL </code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的 <code>select_type </code>的值就是 <code>DEPENDENT UNION </code></p>
</li>
<li><p>DERIVED</p>
<p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的 <code>select_type </code>就是 <code>DERIVED</code></p>
</li>
<li><p>MATERIALIZED</p>
<p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 <code>select_type </code>属性就是 <code>MATERIALIZED </code></p>
</li>
</ul>
<h4 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h4><p>一般情况下为<code>NULL</code>。</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p> <code>type </code>列表明单表访问方法，完整的单表访问方法： <code>system </code>， <code>const </code>， <code>eq_ref </code>， <code>ref </code>， <code>fulltext </code>， <code>ref_or_null </code>， <code>index_merge </code>， <code>unique_subquery </code>， <code>index_subquery </code>， <code>range </code>， <code>index </code>， <code>ALL </code>。</p>
<ul>
<li><p>system</p>
<p>当表中只有一条记录并且 该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory ，那么对该表的访问方法就是 <code>system </code>。</p>
</li>
<li><p>const</p>
<p>根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 <code>const </code></p>
</li>
<li><p>eq_ref</p>
<p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是 <code>eq_ref </code></p>
</li>
<li><p>ref</p>
<p>通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就 可能 是 <code>ref </code></p>
</li>
<li><p>fulltext</p>
<p>全文索引</p>
</li>
<li><p>ref_or_null</p>
<p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是 <code>NULL </code>值时，那么对该表的访问方法就 可能 是 <code>ref_or_null</code></p>
</li>
<li><p>index_merge</p>
<p>索引合并</p>
</li>
<li><p>unique_subquery</p>
<p>类似于两表连接中被驱动表的 <code>eq_ref </code>访问方法， <code>unique_subquery </code>是针对在一些包含 <code>IN </code>子查询的查询语句中，如果查询优化器决定将 <code>IN </code>子查询转换为 <code>EXISTS </code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 <code>type </code>列的值就是 <code>unique_subquery </code></p>
</li>
<li><p>index_subquery</p>
<p><code>index_subquery </code>与 <code>unique_subquery </code>类似，只不过访问子查询中的表时使用的是普通的索引</p>
</li>
<li><p>range</p>
<p>如果使用索引获取某些 <code>范围区间 </code>的记录，那么就 可能 使用到 <code>range </code>访问方法</p>
</li>
<li><p>index</p>
<p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 <code>index </code></p>
</li>
<li><p>ALL </p>
<p>全表扫描</p>
</li>
</ul>
<p>一般来说，这些访问方法按照我们介绍它们的顺序性能依次变差。其中除了 <code>All </code>这个访问方法外，其余的访问方法都能用到索引，除了 <code>index_merge </code>访问方法外，其余的访问方法都最多只能用到一个索引。</p>
<h4 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h4><p><strong>注意事项</strong></p>
<ul>
<li>在使用 <code>index </code>访问方法来查询某个表时， <code>possible_keys </code>列是空的，而 <code>key </code>列展示的是实际使用到的索引</li>
<li><code>possible_keys</code>列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引</li>
</ul>
<h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p><code>key_len </code>列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 <code>VARCHAR(100) </code>，使用的字符集是 <code>utf8 </code>，那么该列实际占用的最大存储空间就是 <code>100 × 3 = 300 </code>个字节。</li>
<li>如果该索引列可以存储 <code>NULL </code>值，则 <code>key_len </code>比不可以存储 <code>NULL </code>值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 <code>const </code>、 <code>eq_ref </code>、 <code>ref </code>、 <code>ref_or_null </code>、 <code>unique_subquery </code>、 <code>index_subquery </code>其中之一时， <code>ref </code>列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</p>
<h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 <code>rows </code>列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 <code>rows </code>列就代表预计扫描的索引记录行数。</p>
<h4 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h4><p>估计扇出值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扇出值 = rows × filtered%</span><br></pre></td></tr></table></figure>

<h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><ul>
<li><p>No tables used</p>
<p>查询语句的没有 <code>FROM </code>子句时将会提示该额外信息</p>
</li>
<li><p>Impossible WHERE</p>
<p>查询语句的 <code>WHERE </code>子句永远为 <code>FALSE </code>时将会提示该额外信息</p>
</li>
<li><p>No matching min&#x2F;max row</p>
<p>查询列表处有 <code>MIN </code>或者 <code>MAX </code>聚集函数，但是并没有符合 <code>WHERE </code>子句中的搜索条件的记录时，将会提示该额外信息</p>
</li>
<li><p>Using index</p>
<p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在 <code>Extra </code>列将会提示该额外信息。</p>
</li>
<li><p>Using index condition</p>
<p>有些搜索条件中虽然出现了索引列，但却并不能用来形成范围区间，也就是不能被用来减少需要扫描的记录数量，通常情况下我们是通过索引回表查询出所有信息然后过滤，但这样会增加很多<code>I/0</code>开销。</p>
<p> <code>索引条件下推 </code>（英文名： <code>Index Condition Pushdown </code>）特性，通过二级索引查询出的记录中直接进行过滤，然后再回表得到完整的用户记录，极大减少了<code>I/O</code>开销，这个特性只适用于二级索引。</p>
</li>
<li><p>Using where</p>
<p>当某个搜索条件需要在 <code>server层 </code>进行判断时，在 <code>Extra </code>列中会提示 <code>Using where </code>。</p>
</li>
<li><p>Using join buffer</p>
<p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度， <code>MySQL </code>一般会为其分配一块名叫 <code>join buffer </code>的内存块来加快查询速度，也就是我们所讲的 <code>基于块的嵌套循环算法 </code></p>
</li>
<li><p>Not exists</p>
<p>当我们使用左（外）连接时，如果 <code>WHERE </code>子句中包含要求被驱动表的某个列等于 <code>NULL </code>值的搜索条件，而且那个列又是不允许存储 <code>NULL </code>值的，那么在该表的执行计划的 <code>Extra </code>列就会提示 <code>Not exists </code>额外信息</p>
</li>
<li><p>Using intersect(…) <code>、 </code>Using union(…) <code>和 </code>Using sort_union(…)</p>
<p>索引合并方式</p>
</li>
<li><p>Zero limit</p>
<p>当我们的 <code>LIMIT </code>子句的参数为 <code>0 </code>时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息</p>
</li>
<li><p>Using filesort</p>
<p>在内存中或者磁盘上进行排序的方式统称为文件排序（英文名： <code>filesort </code>）。即查询出的记录需要排序。</p>
</li>
<li><p>Using temporary</p>
<p>如果查询中使用到了内部的临时表，在执行计划的 <code>Extra </code>列将会显示 <code>Using temporary </code>提示</p>
</li>
<li><p>Start temporary, End temporary</p>
<p>在将 <code>In </code>子查询转为 <code>semi-join </code>时，当执行策略为 <code>DuplicateWeedout </code>时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的 <code>Extra </code>列将显示 <code>Start temporary </code>提示，被驱动表查询执行计划的 <code>Extra </code>列将显示 <code>End temporary </code>提示</p>
</li>
<li><p>LooseScan</p>
<p>在将 <code>In </code>子查询转为 <code>semi-join </code>时，如果采用的是 <code>LooseScan </code>执行策略，则在驱动表执行计划的 <code>Extra </code>列就是显示 <code>LooseScan </code>提示</p>
</li>
<li><p>FirstMatch(tb_name)</p>
<p>在将 <code>In </code>子查询转为 <code>semi-join </code>时，如果采用的是 <code>FirstMatch </code>执行策略，则在被驱动表执行计划的 <code>Extra </code>列就是显示 <code>FirstMatch(tb_name) </code>提示</p>
</li>
</ul>
<h3 id="二-Json-格式的执行计划"><a href="#二-Json-格式的执行计划" class="headerlink" title="二. Json 格式的执行计划"></a>二. Json 格式的执行计划</h3><p>查看某个执行计划花费的成本的方式：</p>
<ul>
<li>在 <code>EXPLAIN </code>单词和真正的查询语句中间加上 <code>FORMAT=JSON </code>。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1840.84&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;193.76&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2034.60&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1M&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>read_cost</p>
<ul>
<li><code>IO </code>成本</li>
<li>检测 <code>rows × (1 - filter) </code>条记录的 <code>CPU </code>成本</li>
</ul>
</li>
<li><p>eval_cost</p>
<p>检测 <code>rows × filter </code>条记录的成本。</p>
</li>
<li><p>prefix_cost</p>
<p>单表查询成本</p>
<p>read_cost + eval_cost</p>
</li>
<li><p>data_read_per_join</p>
<p>此次查询中需要读取的数据量</p>
</li>
</ul>
<h3 id="三-Extented-EXPLAIN"><a href="#三-Extented-EXPLAIN" class="headerlink" title="三. Extented EXPLAIN"></a>三. Extented EXPLAIN</h3><p><code>SHOW WARNINGS </code>语句查看与这个查询的执行计划有关的一些扩展信息：</p>
<ul>
<li><p><code>Level </code></p>
</li>
<li><p><code>Code </code></p>
</li>
<li><p><code>Message</code></p>
</li>
</ul>
<p>  类似于 查询优化器将我们的查询语句重写后的语句</p>
<hr>
<h2 id="InnoDB-的-Buffer-Pool"><a href="#InnoDB-的-Buffer-Pool" class="headerlink" title="InnoDB 的 Buffer Pool"></a>InnoDB 的 Buffer Pool</h2><h3 id="一-缓存的重要性"><a href="#一-缓存的重要性" class="headerlink" title="一. 缓存的重要性"></a>一. 缓存的重要性</h3><p><code>InnoDB </code>存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说 即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中 。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其 <code>缓存 </code>起来，这样将来有请求再次访问该页面时，就可以省去磁盘 <code>IO </code>的开销了。</p>
<h3 id="二-InnoDB-的Buffer-Pool"><a href="#二-InnoDB-的Buffer-Pool" class="headerlink" title="二. InnoDB 的Buffer Pool"></a>二. InnoDB 的Buffer Pool</h3><p> <code>Buffer Pool </code>即为缓冲池，默认为 128 M。</p>
<h4 id="1-Buffer-Pool内部组成"><a href="#1-Buffer-Pool内部组成" class="headerlink" title="1. Buffer Pool内部组成"></a>1. Buffer Pool内部组成</h4><p>由<code>控制块</code>和<code>缓存页</code>组成：</p>
<p><img src="/./MySQL/NeatReader-1683443047883.png"></p>
<p>控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边。</p>
<p>每个控制块大约占用缓存页大小的5%</p>
<h4 id="2-free链表的管理"><a href="#2-free链表的管理" class="headerlink" title="2. free链表的管理"></a>2. free链表的管理</h4><p>为了在某个地方记录一下Buffer Pool中哪些缓存页是可用的 ，这个时候缓存页对应的 <code>控制块 </code>就派上大用场了，我们可以 把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中 ，这个链表也可以被称作 <code>free链表 </code>（或者说空闲链表）。</p>
<p><img src="/./MySQL/NeatReader-1683443182283.png"></p>
<p>链表的基节点占用的内存空间并不包含在为 <code>Buffer Pool </code>申请的一大片连续内存空间之内，而是单独申请的一块内存空间。</p>
<h4 id="3-缓存页的哈希处理"><a href="#3-缓存页的哈希处理" class="headerlink" title="3. 缓存页的哈希处理"></a>3. 缓存页的哈希处理</h4><p> <code>表空间号 + 页号 </code>作为 <code>key </code>， <code>缓存页 </code>作为 <code>value </code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据 <code>表空间号 + 页号 </code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从 <code>free链表 </code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</p>
<h4 id="4-flush链表的管理"><a href="#4-flush链表的管理" class="headerlink" title="4. flush链表的管理"></a>4. flush链表的管理</h4><p>如果我们修改了 <code>Buffer Pool </code>中某个缓存页的数据，那它就和磁盘上的页 不一致 了，这样的缓存页也被称为 <code>脏页 </code>（英文名： <code>dirty page </code>）。</p>
<p>创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫 <code>flush链表 </code>。</p>
<h4 id="5-LRU链表的管理"><a href="#5-LRU链表的管理" class="headerlink" title="5. LRU链表的管理"></a>5. LRU链表的管理</h4><h5 id="简单的LRU链表"><a href="#简单的LRU链表" class="headerlink" title="简单的LRU链表"></a>简单的LRU链表</h5><p> <code>LRU链表 </code>：</p>
<ul>
<li>如果该页不在 <code>Buffer Pool </code>中，在把该页从磁盘加载到 <code>Buffer Pool </code>中的缓存页时，就把该缓存页对应的 <code>控制块 </code>作为节点塞到链表的头部。</li>
<li>如果该页已经缓存在 <code>Buffer Pool </code>中，则直接把该页对应的 <code>控制块 </code>移动到 <code>LRU链表 </code>的头部。</li>
</ul>
<h5 id="划分区域的LRU链表"><a href="#划分区域的LRU链表" class="headerlink" title="划分区域的LRU链表"></a>划分区域的LRU链表</h5><p>两种情况：</p>
<ul>
<li><p><code>预读 </code>，就是 <code>InnoDB </code>认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到 <code>Buffer Pool </code>中。根据触发方式的不同， <code>预读 </code>又可以细分为下边两种：</p>
</li>
<li><p>线性预读</p>
<p>设计 <code>InnoDB </code>的大叔提供了一个系统变量 <code>innodb_read_ahead_threshold </code>，如果顺序访问了某个区（ <code>extent </code>）的页面超过这个系统变量的值，就会触发一次 <code>异步 </code>读取下一个区中全部的页面到 <code>Buffer Pool </code>的请求，注意 <code>异步 </code>读取意味着从磁盘中加载这些被预读的页面并不会影响到当前工作线程的正常执行。</p>
</li>
<li><p>随机预读</p>
<p>如果 <code>Buffer Pool </code>中已经缓存了某个区的13个连续的页面，不论这些页面是不是顺序读取的，都会触发一次 <code>异步 </code>读取本区中所有其的页面到 <code>Buffer Pool </code>的请求。设计 <code>InnoDB </code>的大叔同时提供了 <code>innodb_random_read_ahead </code>系统变量，它的默认值为 <code>OFF </code>，也就意味着 <code>InnoDB </code>并不会默认开启随机预读的功能，如果我们想开启该功能，可以通过修改启动参数或者直接使用 <code>SET GLOBAL </code>命令把该变量的值设置为 <code>ON </code>。</p>
</li>
</ul>
<p>  <code>预读 </code>本来是个好事儿，如果预读到 <code>Buffer Pool </code>中的页成功的被使用到，那就可以极大的提高语句执行的效率。可是如果用不到呢？这些预读的页都会放到 <code>LRU </code>链表的头部，但是如果此时 <code>Buffer Pool </code>的容量不太大而且很多预读的页面都没有用到的话，这就会导致处在 <code>LRU链表 </code>尾部的一些缓存页会很快的被淘汰掉，也就是所谓的 <code>劣币驱逐良币 </code>， 会大大降低缓存命中率 。</p>
<ul>
<li><p>全表扫描</p>
<p>全表扫描的语句意味着，每次执行都要把 <code>Buffer Pool </code>中的缓存页换一次血，这严重的影响到其他查询对 <code>Buffer Pool </code>的使用，从而 大大降低了缓存命中率 。</p>
</li>
</ul>
<p>简单的 <code>LRU链表 </code>存在的问题：</p>
<ul>
<li>加载到 <code>Buffer Pool </code>中的页不一定被用到。</li>
<li>如果非常多的使用频率偏低的页被同时加载到 <code>Buffer Pool </code>时，可能会把那些使用频率非常高的页从 <code>Buffer Pool </code>中淘汰掉。</li>
</ul>
<p>将 <code>LRU链表 </code>按照一定比例分成两截：</p>
<ul>
<li>一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做 <code>热数据 </code>，或者称 <code>young区域 </code>。</li>
<li>另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做 <code>冷数据 </code>，或者称 <code>old区域 </code>。</li>
</ul>
<p><img src="/./MySQL/NeatReader-1683443707155.png"></p>
<p>优化方案：</p>
<ul>
<li><p>针对预读的页面可能不进行后续访问情况的优化</p>
<p>设计 <code>InnoDB </code>的大叔规定， 当磁盘上的某个页面在初次加载到Buffer Pool中的某个缓存页时，该缓存页对应的控制块会被放到old区域的头部 。这样针对预读到 <code>Buffer Pool </code>却不进行后续访问的页面就会被逐渐从 <code>old </code>区域逐出，而不会影响 <code>young </code>区域中被使用比较频繁的缓存页。</p>
</li>
<li><p>针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化</p>
<p>在对某个处在 <code>old </code>区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部 。</p>
</li>
</ul>
<h4 id="6-刷新脏页到磁盘"><a href="#6-刷新脏页到磁盘" class="headerlink" title="6. 刷新脏页到磁盘"></a>6. 刷新脏页到磁盘</h4><ul>
<li><p>从 <code>LRU链表 </code>的冷数据中刷新一部分页面到磁盘。</p>
<p>后台线程会定时从 <code>LRU链表 </code>尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 <code>innodb_lru_scan_depth </code>来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为 <code>BUF_FLUSH_LRU </code>。</p>
</li>
<li><p>从 <code>flush链表 </code>中刷新一部分页面到磁盘。</p>
<p>后台线程也会定时从 <code>flush链表 </code>中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为 <code>BUF_FLUSH_LIST </code>。</p>
</li>
</ul>
<p>有时候后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到 <code>Buffer Pool </code>时没有可用的缓存页，这时就会尝试看看 <code>LRU链表 </code>尾部有没有可以直接释放掉的未修改页面，如果没有的话会不得不将 <code>LRU链表 </code>尾部的一个脏页同步刷新到磁盘（和磁盘交互是很慢的，这会降低处理用户请求的速度）。这种刷新单个页面到磁盘中的刷新方式被称之为 <code>BUF_FLUSH_SINGLE_PAGE </code>。</p>
<h3 id="三-多个Buffer-Pool实例"><a href="#三-多个Buffer-Pool实例" class="headerlink" title="三. 多个Buffer Pool实例"></a>三. 多个Buffer Pool实例</h3><p> <code>Buffer Pool </code>本质是 <code>InnoDB </code>向操作系统申请的一块连续的内存空间，在多线程环境下，访问 <code>Buffer Pool </code>中的各种链表都需要加锁处理啥的，在 <code>Buffer Pool </code>特别大而且多线程并发访问特别高的情况下，单一的 <code>Buffer Pool </code>可能会影响请求的处理速度。所以在 <code>Buffer Pool </code>特别大的时候，我们可以把它们拆分成若干个小的 <code>Buffer Pool </code>，每个 <code>Buffer Pool </code>都称为一个 <code>实例 </code>，它们都是独立的。它们在多线程并发访问时不会相互影响，从而提高并发处理能力。</p>
<p>规定：当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances 的值修改为1。</p>
<h4 id="innodb-buffer-pool-chunk-size"><a href="#innodb-buffer-pool-chunk-size" class="headerlink" title="innodb_buffer_pool_chunk_size"></a>innodb_buffer_pool_chunk_size</h4><p>一个 <code>Buffer Pool </code>实例其实是由若干个 <code>chunk </code>组成的，一个 <code>chunk </code>就代表一片连续的内存空间，里边儿包含了若干缓存页与其对应的控制块，画个图表示就是这样：</p>
<p><img src="/./MySQL/NeatReader-1683444103210.png"></p>
<p> innodb_buffer_pool_chunk_size的值只能在服务器启动时指定，在服务器运行过程中是不可以修改的 。</p>
<p>注意事项：</p>
<ul>
<li><p><code>innodb_buffer_pool_size </code>必须是 <code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances </code>的倍数（这主要是想保证每一个 <code>Buffer Pool </code>实例中包含的 <code>chunk </code>数量相同）。</p>
<p>若非倍数，则向上取整。</p>
</li>
<li><p>如果在服务器启动时， <code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances </code>的值已经大于 <code>innodb_buffer_pool_size </code>的值，那么 <code>innodb_buffer_pool_chunk_size </code>的值会被服务器自动设置为 <code>innodb_buffer_pool_size/innodb_buffer_pool_instances </code>的值。</p>
</li>
</ul>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h3><ol>
<li><p>磁盘太慢，用内存作为缓存很有必要。</p>
</li>
<li><p><code>Buffer Pool </code>本质上是 <code>InnoDB </code>向操作系统申请的一段连续的内存空间，可以通过 <code>innodb_buffer_pool_size </code>来调整它的大小。</p>
</li>
<li><p><code>Buffer Pool </code>向操作系统申请的连续内存由控制块和缓存页组成，每个控制块和缓存页都是一一对应的，在填充足够多的控制块和缓存页的组合后， <code>Buffer Pool </code>剩余的空间可能产生不够填充一组控制块和缓存页，这部分空间不能被使用，也被称为 <code>碎片 </code>。</p>
</li>
<li><p><code>InnoDB </code>使用了许多 <code>链表 </code>来管理 <code>Buffer Pool </code>。</p>
</li>
<li><p><code>free链表 </code>中每一个节点都代表一个空闲的缓存页，在将磁盘中的页加载到 <code>Buffer Pool </code>时，会从 <code>free链表 </code>中寻找空闲的缓存页。</p>
</li>
<li><p>为了快速定位某个页是否被加载到 <code>Buffer Pool </code>，使用 <code>表空间号 + 页号 </code>作为 <code>key </code>，缓存页作为 <code>value </code>，建立哈希表。</p>
</li>
<li><p>在 <code>Buffer Pool </code>中被修改的页称为 <code>脏页 </code>，脏页并不是立即刷新，而是被加入到 <code>flush链表 </code>中，待之后的某个时刻同步到磁盘上。</p>
</li>
<li><p><code>LRU链表 </code>分为 <code>young </code>和 <code>old </code>两个区域，可以通过 <code>innodb_old_blocks_pct </code>来调节 <code>old </code>区域所占的比例。首次从磁盘上加载到 <code>Buffer Pool </code>的页会被放到 <code>old </code>区域的头部，在 <code>innodb_old_blocks_time </code>间隔时间内访问该页不会把它移动到 <code>young </code>区域头部。在 <code>Buffer Pool </code>没有可用的空闲缓存页时，会首先淘汰掉 <code>old </code>区域的一些页。</p>
</li>
<li><p>我们可以通过指定 <code>innodb_buffer_pool_instances </code>来控制 <code>Buffer Pool </code>实例的个数，每个 <code>Buffer Pool </code>实例中都有各自独立的链表，互不干扰。</p>
</li>
<li><p>自 <code>MySQL 5.7.5 </code>版本之后，可以在服务器运行过程中调整 <code>Buffer Pool </code>大小。每个 <code>Buffer Pool </code>实例由若干个 <code>chunk </code>组成，每个 <code>chunk </code>的大小可以在服务器启动时通过启动参数调整。</p>
</li>
<li><p>可以用下边的命令查看 <code>Buffer Pool </code>的状态信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><p>四大特性（ACID）：</p>
<ul>
<li><p>原子性（Atomicity）</p>
<p>要么全做，要么全不做的规则称之为 <code>原子性 </code>。</p>
</li>
<li><p>隔离性（Isolation）</p>
<p>保证其它的状态转换不会影响到本次状态转换，这个规则被称之为 <code>隔离性 </code>。</p>
</li>
<li><p>一致性（Consistency）</p>
<p>如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的，或者说符合 <code>一致性 </code>的。</p>
<p>数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果 。</p>
</li>
<li><p>持久性（Durability）</p>
<p>当现实世界的一个状态转换完成后，这个转换的结果将永久的保留，这个规则被设计数据库的大叔们称为 <code>持久性 </code>。</p>
</li>
</ul>
<h3 id="一-事务的概念"><a href="#一-事务的概念" class="headerlink" title="一. 事务的概念"></a>一. 事务的概念</h3><p>设计数据库的大叔为了方便起见，把需要保证 <code>原子性 </code>、 <code>隔离性 </code>、 <code>一致性 </code>和 <code>持久性 </code>的一个或多个数据库操作称之为一个 <code>事务 </code>（英文名是： <code>transaction </code>）。</p>
<p> <code>事务 </code>大致上划分成了这么几个状态：</p>
<ul>
<li><p>活动的（active）</p>
<p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 <code>活动的 </code>状态。</p>
</li>
<li><p>部分提交的（partially committed）</p>
<p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在 <code>部分提交的 </code>状态。</p>
</li>
<li><p>失败的（failed）</p>
<p>当事务处在 <code>活动的 </code>或者 <code>部分提交的 </code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 <code>失败的 </code>状态。</p>
</li>
<li><p>中止的（aborted）</p>
<p>如果事务执行了半截而变为 <code>失败的 </code>状态，就要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 <code>回滚 </code>。当 <code>回滚 </code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 <code>中止的 </code>状态。</p>
</li>
<li><p>提交的（committed）</p>
<p>当一个处在 <code>部分提交的 </code>状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了 <code>提交的 </code>状态。</p>
</li>
</ul>
<p>随着事务对应的数据库操作执行到不同阶段，事务的状态也在不断变化，一个基本的状态转换图如下所示：</p>
<p><img src="/./MySQL/NeatReader-1683512866337.png"></p>
<p>只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了 。</p>
<h3 id="二-MySQL中事务的语法"><a href="#二-MySQL中事务的语法" class="headerlink" title="二. MySQL中事务的语法"></a>二. MySQL中事务的语法</h3><h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><p>我们可以使用下边两种语句之一来开启一个事务：</p>
<ul>
<li><p><code>BEGIN [WORK];</code></p>
<p><code>BEGIN </code>语句代表开启一个事务，后边的单词 <code>WORK </code>可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。</p>
</li>
<li><p><code>START TRANSACTION;</code></p>
<p><code>START TRANSACTION </code>语句和 <code>BEGIN </code>语句有着相同的功效，都标志着开启一个事务，但可以在其后面跟随几个<code>修饰符</code>：</p>
<ul>
<li><code>READ ONLY </code>：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用CREATE TMEPORARY TABLE创建的表），由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增、删、改操作的。</li>
<li><code>READ WRITE </code>：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</li>
<li><code>WITH CONSISTENT SNAPSHOT </code>：启动一致性读。</li>
</ul>
</li>
</ul>
<p><code>READ ONLY </code>和 <code>READ WRITE </code>是用来设置所谓的事务 <code>访问模式 </code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为 <code>只读 </code>的也设置为 <code>读写 </code>的，所以我们不能同时把 <code>READ ONLY </code>和 <code>READ WRITE </code>放到 <code>START TRANSACTION </code>语句后边。另外，如果我们不显式指定事务的访问模式，那么该事务的访问模式就是 <code>读写 </code>模式。</p>
<h4 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT [WORK]</span><br></pre></td></tr></table></figure>

<h4 id="手动终止事务"><a href="#手动终止事务" class="headerlink" title="手动终止事务"></a>手动终止事务</h4><p>将数据库恢复到事务执行之前的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK [WORK]</span><br></pre></td></tr></table></figure>

<p><code>ROLLBACK </code>语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚。</p>
<h4 id="支持事务的存储引擎"><a href="#支持事务的存储引擎" class="headerlink" title="支持事务的存储引擎"></a>支持事务的存储引擎</h4><p><code>MySQL </code>中并不是所有存储引擎都支持事务的功能，目前只有 <code>InnoDB </code>和 <code>NDB </code>存储引擎支持（NDB存储引擎不是我们的重点），如果某个事务中包含了修改使用不支持事务的存储引擎的表，那么对该使用不支持事务的存储引擎的表所做的修改将无法进行回滚。</p>
<h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p><code>MySQL </code>中有一个系统变量 <code>autocommit </code>，默认情况下为<code>on</code>。</p>
<p>默认情况下，如果我们不显式的使用 <code>START TRANSACTION </code>或者 <code>BEGIN </code>语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的 <code>自动提交 </code>。</p>
<p>关闭<code>自动提交</code>的两种方法：</p>
<ul>
<li><p>显式的的使用 <code>START TRANSACTION </code>或者 <code>BEGIN </code>语句开启一个事务。</p>
<p>这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p>
</li>
<li><p>把系统变量 <code>autocommit </code>的值设置为 <code>OFF </code>，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET autocommit = OFF;</span><br></pre></td></tr></table></figure>

<p>这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出 <code>COMMIT </code>语句来把这个事务提交掉，或者显式的写出 <code>ROLLBACK </code>语句来把这个事务回滚掉。</p>
</li>
</ul>
<h4 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h4><p>如果我们输入了某些语句之后就会 <code>悄悄的 </code>提交掉，就像我们输入了 <code>COMMIT </code>语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为 <code>隐式提交 </code>。</p>
<ul>
<li>定义或修改数据库对象的数据定义语言（Data definition language，缩写为： <code>DDL </code>）。</li>
<li>隐式使用或修改 <code>mysql </code>数据库中的表</li>
<li>事务控制或关于锁定的语句</li>
<li>加载数据的语句</li>
<li>关于 <code>MySQL </code>复制的一些语句</li>
<li>其它的一些语句</li>
</ul>
<h4 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h4><p><code>保存点 </code>（英文： <code>savepoint </code>）的概念，就是在事务对应的数据库语句中打几个点，我们在调用 <code>ROLLBACK </code>语句时可以指定会滚到哪个点，而不是回到最初的原点。</p>
<p><strong>定义保存点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure>

<p><strong>回滚</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</span><br></pre></td></tr></table></figure>

<p><strong>删除保存点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="redo-日志"><a href="#redo-日志" class="headerlink" title="redo 日志"></a>redo 日志</h2><h3 id="一-redo-日志的引入"><a href="#一-redo-日志的引入" class="headerlink" title="一. redo 日志的引入"></a>一. redo 日志的引入</h3><p>要保证<code>持久性</code>，一个简单的做法是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个做法会产生两个问题：</p>
<ul>
<li><p>刷新一个完整的数据页太浪费了</p>
<p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在 <code>InnoDB </code>中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。</p>
</li>
<li><p>随机IO刷起来比较慢</p>
<p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的 <code>Buffer Pool </code>中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p>
</li>
</ul>
<p>其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要 把修改了哪些东西记录一下就好，这便产生了 <code>重做日志 </code>，英文名为 <code>redo log </code>。与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的 <code>redo </code>日志刷新到磁盘的好处如下：</p>
<ul>
<li><code>redo </code>日志占用的空间非常小</li>
<li><code>redo </code>日志是顺序写入磁盘的（顺序IO）</li>
</ul>
<h3 id="二-redo-日志格式"><a href="#二-redo-日志格式" class="headerlink" title="二. redo 日志格式"></a>二. redo 日志格式</h3><p>通用结构：</p>
<p><img src="/./MySQL/NeatReader-1683614832206.png"></p>
<ul>
<li><code>type </code>：该条 <code>redo </code>日志的类型。</li>
<li><code>space ID </code>：表空间ID。</li>
<li><code>page number </code>：页号。</li>
<li><code>data </code>：该条 <code>redo </code>日志的具体内容。</li>
</ul>
<h4 id="1-简单的redo日志类型"><a href="#1-简单的redo日志类型" class="headerlink" title="1. 简单的redo日志类型"></a>1. 简单的redo日志类型</h4><p>设计 <code>InnoDB </code>的大叔把这种极其简单的 <code>redo </code>日志称之为 <code>物理日志 </code>：</p>
<ul>
<li><code>MLOG_1BYTE </code>（ <code>type </code>字段对应的十进制数字为 <code>1 </code>）：表示在页面的某个偏移量处写入1个字节的 <code>redo </code>日志类型。</li>
<li><code>MLOG_2BYTE </code>（ <code>type </code>字段对应的十进制数字为 <code>2 </code>）：表示在页面的某个偏移量处写入2个字节的 <code>redo </code>日志类型。</li>
<li><code>MLOG_4BYTE </code>（ <code>type </code>字段对应的十进制数字为 <code>4 </code>）：表示在页面的某个偏移量处写入4个字节的 <code>redo </code>日志类型。</li>
<li><code>MLOG_8BYTE </code>（ <code>type </code>字段对应的十进制数字为 <code>8 </code>）：表示在页面的某个偏移量处写入8个字节的 <code>redo </code>日志类型。</li>
<li><code>MLOG_WRITE_STRING </code>（ <code>type </code>字段对应的十进制数字为 <code>30 </code>）：表示在页面的某个偏移量处写入一串数据。</li>
</ul>
<p> <code>MLOG_8BYTE </code>的 <code>redo </code>日志结构如下所示：</p>
<p><img src="/./MySQL/NeatReader-1683614934158.png"></p>
<p><code>MLOG_WRITE_STRING </code>的<code>redo</code>日志结构如下所示：</p>
<p><img src="/./MySQL/NeatReader-1683614961300.png"></p>
<h4 id="2-复杂的redo日志类型"><a href="#2-复杂的redo日志类型" class="headerlink" title="2. 复杂的redo日志类型"></a>2. 复杂的redo日志类型</h4><p> 把一条记录插入到一个页面时可能需要更改的地方非常多 。这时我们如果使用上边介绍的简单的物理 <code>redo </code>日志来记录这些修改时，可以有两种解决方案：</p>
<ul>
<li>在每个修改的地方都记录一条 <code>redo </code>日志</li>
<li>将整个页面的 <code>第一个被修改的字节 </code>到 <code>最后一个修改的字节 </code>之间所有的数据当成是一条物理 <code>redo </code>日志中的具体数据</li>
</ul>
<p>这两种方案都很浪费空间，因而有一些新的<code>redo</code>日志类型：</p>
<ul>
<li><p><code>MLOG_REC_INSERT </code>（对应的十进制数字为 <code>9 </code>）：表示插入一条使用非紧凑行格式的记录时的 <code>redo </code>日志类型。</p>
</li>
<li><p><code>MLOG_COMP_REC_INSERT </code>（对应的十进制数字为 <code>38 </code>）：表示插入一条使用紧凑行格式的记录时的 <code>redo </code>日志类型。</p>
</li>
<li><p><code>MLOG_COMP_PAGE_CREATE </code>（ <code>type </code>字段对应的十进制数字为 <code>58 </code>）：表示创建一个存储紧凑行格式记录的页面的 <code>redo </code>日志类型。</p>
</li>
<li><p><code>MLOG_COMP_REC_DELETE </code>（ <code>type </code>字段对应的十进制数字为 <code>42 </code>）：表示删除一条使用紧凑行格式记录的 <code>redo </code>日志类型。</p>
</li>
<li><p><code>MLOG_COMP_LIST_START_DELETE </code>（ <code>type </code>字段对应的十进制数字为 <code>44 </code>）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的 <code>redo </code>日志类型。</p>
</li>
<li><p><code>MLOG_COMP_LIST_END_DELETE </code>（ <code>type </code>字段对应的十进制数字为 <code>43 </code>）：与 <code>MLOG_COMP_LIST_START_DELETE </code>类型的 <code>redo </code>日志呼应，表示删除一系列记录直到 <code>MLOG_COMP_LIST_END_DELETE </code>类型的 <code>redo </code>日志对应的记录为止。</p>
</li>
<li><p><code>MLOG_ZIP_PAGE_COMPRESS </code>（ <code>type </code>字段对应的十进制数字为 <code>51 </code>）：表示压缩一个数据页的 <code>redo </code>日志类型。</p>
</li>
</ul>
<p>注：Redundant是一种比较原始的行格式，它就是非紧凑的。而Compact、Dynamic以及Compressed行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。</p>
<p>这些类型的 <code>redo </code>日志既包含 <code>物理 </code>层面的意思，也包含 <code>逻辑 </code>层面的意思，具体指：</p>
<ul>
<li>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。</li>
<li>逻辑层面看，在系统崩溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统崩溃前的样子。</li>
</ul>
<p><code>MLOG_COMP_REC_INSERT </code>的 <code>redo </code>日志的结构：</p>
<p><img src="/./MySQL/NeatReader-1683615348636.png"></p>
<ul>
<li><p><code>n_uniques</code></p>
<p>表示需要几个字段的值才能确保记录的唯一性，这样当插入一条记录时就可以按照记录的前 <code>n_uniques </code>个字段进行排序。</p>
<p>对于聚簇索引来说， <code>n_uniques </code>的值为主键的列数，对于其他二级索引来说，该值为索引列数+主键列数。</p>
</li>
<li><p><code>field1_len ~ fieldn_len </code></p>
<p>代表着该记录若干个字段占用存储空间的大小。</p>
</li>
<li><p><code>offset</code> </p>
<p>代表的是该记录的前一条记录在页面中的地址，便于更新前一条记录的 <code>next_record </code>属性。</p>
</li>
</ul>
<p>很显然这个类型为 <code>MLOG_COMP_REC_INSERT </code>的 <code>redo </code>日志并没有记录 <code>PAGE_N_DIR_SLOTS </code>的值修改为了啥， <code>PAGE_HEAP_TOP </code>的值修改为了啥， <code>PAGE_N_HEAP </code>的值修改为了啥等等这些信息，而只是把在本页面中插入一条记录所有必备的要素记了下来，之后系统崩溃重启时，服务器会调用相关向某个页面插入一条记录的那个函数，而 <code>redo </code>日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，页面中的 <code>PAGE_N_DIR_SLOTS </code>、 <code>PAGE_HEAP_TOP </code>、 <code>PAGE_N_HEAP </code>等等的值也就都被恢复到系统崩溃前的样子了。这就是所谓的 <code>逻辑 </code>日志的意思。</p>
<h4 id="3-redo日志格式小结"><a href="#3-redo日志格式小结" class="headerlink" title="3. redo日志格式小结"></a>3. redo日志格式小结</h4><p>redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统崩溃重启后可以把事务所做的任何修改都恢复出来。 </p>
<h3 id="三-Mini-Transaction"><a href="#三-Mini-Transaction" class="headerlink" title="三. Mini-Transaction"></a>三. Mini-Transaction</h3><h4 id="1-以组的形式写入redo日志"><a href="#1-以组的形式写入redo日志" class="headerlink" title="1. 以组的形式写入redo日志"></a>1. 以组的形式写入redo日志</h4><p>插入记录时可能出现的两种情况：</p>
<ul>
<li>该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，这种情况称为<code>乐观插入</code>。</li>
<li>该数据页剩余的空闲空间不足，那么我们需要进行<code>页分裂</code>操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条 <code>目录项记录 </code>指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条 <code>redo </code>日志，我们把这种情况称之为 <code>悲观插入 </code>。</li>
</ul>
<p>设计 <code>InnoDB </code>的大叔们认为向某个索引对应的 <code>B+ </code>树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向内节点中插入一条 <code>目录项记录 </code>，这个插入过程就是不完整的，这样会形成一棵不正确的 <code>B+ </code>树。我们知道 <code>redo </code>日志是为了在系统崩溃重启时恢复崩溃前的状态，如果在悲观插入的过程中只记录了一部分 <code>redo </code>日志，那么在系统崩溃重启时会将索引对应的 <code>B+ </code>树恢复成一种不正确的状态，这是设计 <code>InnoDB </code>的大叔们所不能忍受的。所以他们规定在执行这些需要保证原子性的操作时必须以 <code>组 </code>的形式来记录的 <code>redo </code>日志，在进行系统崩溃重启恢复时，针对某个组中的 <code>redo </code>日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？这得分情况讨论：</p>
<ul>
<li><p>有的需要保证原子性的操作会生成多条 <code>redo </code>日志，比如向某个索引对应的 <code>B+ </code>树中进行一次悲观插入就需要生成许多条 <code>redo </code>日志。</p>
<p>在该组中的最后一条 <code>redo </code>日志后边加上一条特殊类型的 <code>redo </code>日志，该类型名称为 <code>MLOG_MULTI_REC_END </code>， <code>type </code>字段对应的十进制数字为 <code>31 </code>，该类型的 <code>redo </code>日志结构很简单，只有一个 <code>type </code>字段。所以某个需要保证原子性的操作产生的一系列 <code>redo </code>日志必须要以一个类型为 <code>MLOG_MULTI_REC_END </code>结尾，就像这样：</p>
<p><img src="/./MySQL/NeatReader-1683616139820.png"></p>
</li>
<li><p>有的需要保证原子性的操作只生成一条 <code>redo </code>日志，比如更新 <code>Max Row ID </code>属性的操作就只会生成一条 <code>redo </code>日志。</p>
<p>通过<code>type</code>字段的第一个比特位表示，如果 <code>type </code>字段的第一个比特位为 <code>1 </code>，代表该需要保证原子性的操作只产生了单一的一条 <code>redo </code>日志，否则表示该需要保证原子性的操作产生了一系列的 <code>redo </code>日志。</p>
</li>
</ul>
<h4 id="2-Mini-Transaction的概念"><a href="#2-Mini-Transaction的概念" class="headerlink" title="2. Mini-Transaction的概念"></a>2. Mini-Transaction的概念</h4><p>设计 <code>MySQL </code>的大叔把对底层页面中的一次原子访问的过程称之为一个 <code>Mini-Transaction </code>，简称 <code>mtr </code>，比如上边所说的修改一次 <code>Max Row ID </code>的值算是一个 <code>Mini-Transaction </code>，向某个索引对应的 <code>B+ </code>树中插入一条记录的过程也算是一个 <code>Mini-Transaction </code>。通过上边的叙述我们也知道，一个所谓的 <code>mtr </code>可以包含一组 <code>redo </code>日志，在进行崩溃恢复时这一组 <code>redo </code>日志作为一个不可分割的整体。</p>
<p>事务对应关系图：</p>
<p><img src="/./MySQL/NeatReader-1683616253429.png"></p>
<h3 id="四-redo-日志的写入过程"><a href="#四-redo-日志的写入过程" class="headerlink" title="四. redo 日志的写入过程"></a>四. redo 日志的写入过程</h3><h4 id="1-redo-log-block"><a href="#1-redo-log-block" class="headerlink" title="1. redo log block"></a>1. redo log block</h4><p>设计 <code>InnoDB </code>的大叔为了更好的进行系统崩溃恢复，他们把通过 <code>mtr </code>生成的 <code>redo </code>日志都放在了大小为 <code>512字节 </code>的 <code>页 </code>中。</p>
<p><img src="/./MySQL/NeatReader-1683616318732.png"></p>
<p>真正的 <code>redo </code>日志都是存储到占用 <code>496 </code>字节大小的 <code>log block body </code>中，图中的 <code>log block header </code>和 <code>log block trailer </code>存储的是一些管理信息。我们来看看这些所谓的 <code>管理信息 </code>都是啥：</p>
<p><img src="/./MySQL/NeatReader-1683616349557.png"></p>
<p> <code>log block header </code>：</p>
<ul>
<li><p><code>LOG_BLOCK_HDR_NO </code>：唯一标号。</p>
</li>
<li><p><code>LOG_BLOCK_HDR_DATA_LEN </code>：表示block中已经使用了多少字节，初始值为 <code>12 </code>（因为 <code>log block body </code>从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果 <code>log block body </code>已经被全部写满，那么本属性的值被设置为 <code>512 </code>。</p>
</li>
<li><p><code>LOG_BLOCK_FIRST_REC_GROUP </code>：一条 <code>redo </code>日志也可以称之为一条 <code>redo </code>日志记录（ <code>redo log record </code>），一个 <code>mtr </code>会生产多条 <code>redo </code>日志记录，这些 <code>redo </code>日志记录被称之为一个 <code>redo </code>日志记录组（ <code>redo log record group </code>）。 <code>LOG_BLOCK_FIRST_REC_GROUP </code>就代表该block中第一个 <code>mtr </code>生成的 <code>redo </code>日志记录组的偏移量。</p>
</li>
<li><p><code>LOG_BLOCK_CHECKPOINT_NO </code>：<code>checkpoint </code>的序号。</p>
</li>
</ul>
<p><code>log block trailer</code> :</p>
<ul>
<li><code>LOG_BLOCK_CHECKSUM </code>：校验值，用于正确性校验。</li>
</ul>
<h4 id="2-redo-日志缓冲区"><a href="#2-redo-日志缓冲区" class="headerlink" title="2. redo 日志缓冲区"></a>2. redo 日志缓冲区</h4><p>同<code>Buffer Pool</code>，称为<code>redo log buffer</code>，</p>
<h5 id="redo日志写入log-buffer"><a href="#redo日志写入log-buffer" class="headerlink" title="redo日志写入log buffer"></a>redo日志写入log buffer</h5><p>顺序写入，当我们想往 <code>log buffer </code>中写入 <code>redo </code>日志时，第一个遇到的问题就是应该写在哪个 <code>block </code>的哪个偏移量处，所以设计 <code>InnoDB </code>的大叔特意提供了一个称之为 <code>buf_free </code>的全局变量，该变量指明后续写入的 <code>redo </code>日志应该写入到 <code>log buffer </code>中的哪个位置，如图所示：</p>
<p><img src="/./MySQL/NeatReader-1683616622668.png"></p>
<h3 id="五-redo-日志文件"><a href="#五-redo-日志文件" class="headerlink" title="五. redo 日志文件"></a>五. redo 日志文件</h3><h4 id="1-redo-日志刷盘时机"><a href="#1-redo-日志刷盘时机" class="headerlink" title="1. redo 日志刷盘时机"></a>1. redo 日志刷盘时机</h4><ul>
<li><p><code>log buffer </code>空间不足时</p>
<p>设计 <code>InnoDB </code>的大叔认为如果当前写入 <code>log buffer </code>的 <code>redo </code>日志量已经占满了 <code>log buffer </code>总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</p>
</li>
<li><p>事务提交时</p>
</li>
<li><p>将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中</p>
</li>
<li><p>后台线程不停的刷盘</p>
<p>后台有一个线程，大约每秒都会刷新一次 <code>log buffer </code>中的 <code>redo </code>日志到磁盘。</p>
</li>
<li><p>正常关闭服务器时</p>
</li>
<li><p>做checkpoint 时</p>
</li>
</ul>
<h4 id="2-redo-日志文件组"><a href="#2-redo-日志文件组" class="headerlink" title="2. redo 日志文件组"></a>2. redo 日志文件组</h4><p>磁盘上的 <code>redo </code>日志文件不只一个，而是以一个 <code>日志文件组 </code>的形式出现的。</p>
<p>几个参数：</p>
<ul>
<li><p><code>innodb_log_group_home_dir</code></p>
<p>该参数指定了 <code>redo </code>日志文件所在的目录，默认值就是当前的数据目录。</p>
</li>
<li><p><code>innodb_log_file_size</code></p>
<p>该参数指定了每个 <code>redo </code>日志文件的大小，在 <code>MySQL 5.7.21 </code>这个版本中的默认值为 <code>48MB </code>，</p>
</li>
<li><p><code>innodb_log_files_in_group</code></p>
<p>该参数指定 <code>redo </code>日志文件的个数，默认值为2，最大值为100。</p>
</li>
</ul>
<p>图示：</p>
<p><img src="/./MySQL/NeatReader-1683635484143.png"></p>
<p> <code>redo </code>日志文件大小其实就是： <code>innodb_log_file_size × innodb_log_files_in_group </code>。</p>
<h4 id="3-redo-日志文件格式"><a href="#3-redo-日志文件格式" class="headerlink" title="3. redo 日志文件格式"></a>3. redo 日志文件格式</h4><p>我们前边说过 <code>log buffer </code>本质上是一片连续的内存空间，被划分成了若干个 <code>512 </code>字节大小的 <code>block </code>。 将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中 ，所以 <code>redo </code>日志文件其实也是由若干个 <code>512 </code>字节大小的block组成。</p>
<p><code>redo </code>日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p>
<ul>
<li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li>
<li>从第2048字节往后是用来存储 <code>log buffer </code>中的block镜像的。</li>
</ul>
<p>所以我们前边所说的 <code>循环 </code>使用redo日志文件，其实是从每个日志文件的第2048个字节开始算，画个示意图就是这样：</p>
<p><img src="/./MySQL/NeatReader-1683635628867.png"></p>
<p>前4个block：</p>
<p><img src="/./MySQL/NeatReader-1683635649074.png"></p>
<h3 id="六-Log-Sequence-Number"><a href="#六-Log-Sequence-Number" class="headerlink" title="六. Log Sequence Number"></a>六. Log Sequence Number</h3><p>设计 <code>InnoDB </code>的大叔为记录已经写入的 <code>redo </code>日志量，设计了一个称之为 <code>Log Sequence Number </code>的全局变量，翻译过来就是： <code>日志序列号 </code>，简称 <code>lsn </code>。规定初始的 <code>lsn </code>值为 <code>8704</code>。</p>
<p>统计 <code>lsn </code>的增长量时，是按照实际写入的日志量加上占用的 <code>log block header </code>和 <code>log block trailer </code>来计算的。</p>
<p>每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早 。</p>
<h4 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h4><p><code>redo </code>日志是首先写到 <code>log buffer </code>中，之后才会被刷新到磁盘上的 <code>redo </code>日志文件。所以设计 <code>InnoDB </code>的大叔提出了一个称之为 <code>buf_next_to_write </code>的全局变量，标记当前 <code>log buffer </code>中已经有哪些日志被刷新到磁盘中了。画个图表示就是这样：</p>
<p><img src="/./MySQL/NeatReader-1683635847858.png"></p>
<p>对应 lsn ，设计 <code>InnoDB </code>的大叔提出了一个表示刷新到磁盘中的 <code>redo </code>日志量的全局变量，称之为 <code>flushed_to_disk_lsn </code>。系统第一次启动时，该变量的值和初始的 <code>lsn </code>值是相同的，都是 <code>8704 </code>。</p>
<p>当有新的 <code>redo </code>日志写入到 <code>log buffer </code>时，首先 <code>lsn </code>的值会增长，但 <code>flushed_to_disk_lsn </code>不变，随后随着不断有 <code>log buffer </code>中的日志被刷新到磁盘上， <code>flushed_to_disk_lsn </code>的值也跟着增长。 如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了 。</p>
<blockquote>
<p>tips: 应用程序向磁盘写入文件时其实是先写到操作系统的缓冲区中去，如果某个写入操作要等到操作系统确认已经写到磁盘时才返回，那需要调用一下操作系统提供的fsync函数。其实只有当系统执行了fsync函数后，flushed_to_disk_lsn的值才会跟着增长，当仅仅把log buffer中的日志写入到操作系统缓冲区却没有显式的刷新到磁盘时，另外的一个称之为write_lsn的值跟着增长。不过为了大家理解上的方便，我们在讲述时把flushed_to_disk_lsn和write_lsn的概念混淆了起来。</p>
</blockquote>
<h4 id="flush链表中的LSN"><a href="#flush链表中的LSN" class="headerlink" title="flush链表中的LSN"></a>flush链表中的LSN</h4><p>当第一次修改某个缓存在 <code>Buffer Pool </code>中的页面时，就会把这个页面对应的控制块插入到 <code>flush链表 </code>的头部，之后再修改该页面时由于它已经在 <code>flush </code>链表中了，就不再次插入了。也就是说 flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的 。在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：</p>
<ul>
<li><code>oldest_modification </code>：如果某个页面被加载到 <code>Buffer Pool </code>后进行第一次修改，那么就将修改该页面的 <code>mtr </code>开始时对应的 <code>lsn </code>值写入这个属性。</li>
<li><code>newest_modification </code>：每修改一次页面，都会将修改该页面的 <code>mtr </code>结束时对应的 <code>lsn </code>值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统 <code>lsn </code>值。</li>
</ul>
<p>flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值 。</p>
<h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p>循环使用 redo 日志文件组会产生<code>追尾</code>问题，此时便需要<code>checkpoint</code>，这时应该想到： redo日志只是为了系统崩溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统崩溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用 。设计 <code>InnoDB </code>的大叔提出了一个全局变量 <code>checkpoint_lsn </code>来代表当前系统中可以被覆盖的 <code>redo </code>日志总量是多少，这个变量初始值也是 <code>8704 </code>。</p>
<p>做一次 <code>checkpoint </code>可以分为两个步骤：</p>
<ul>
<li><p>步骤一：计算一下当前系统中可以被覆盖的 <code>redo </code>日志对应的 <code>lsn </code>值最大是多少。</p>
<p>只要我们计算出当前系统中被最早修改的脏页对应的 <code>oldest_modification </code>值，那么凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的 ，我们就把该脏页的 <code>oldest_modification </code>赋值给 <code>checkpoint_lsn </code>。</p>
</li>
<li><p>步骤二：将 <code>checkpoint_lsn </code>和对应的 <code>redo </code>日志文件组偏移量以及此次 <code>checkpint </code>的编号写到日志文件的管理信息（就是 <code>checkpoint1 </code>或者 <code>checkpoint2 </code>）中。</p>
<p>设计 <code>InnoDB </code>的大叔维护了一个目前系统做了多少次 <code>checkpoint </code>的变量 <code>checkpoint_no </code>，每做一次 <code>checkpoint </code>，该变量的值就加1。我们前边说过计算一个 <code>lsn </code>值对应的 <code>redo </code>日志文件组偏移量是很容易的，所以可以计算得到该 <code>checkpoint_lsn </code>在 <code>redo </code>日志文件组中对应的偏移量 <code>checkpoint_offset </code>，然后把这三个值都写到 <code>redo </code>日志文件组的管理信息中。</p>
<p>规定，当 <code>checkpoint_no </code>的值是偶数时，就写到 <code>checkpoint1 </code>中，是奇数时，就写到 <code>checkpoint2 </code>中。</p>
</li>
</ul>
<h4 id="查看系统中的各种LSN值"><a href="#查看系统中的各种LSN值" class="headerlink" title="查看系统中的各种LSN值"></a>查看系统中的各种LSN值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Log sequence number </code>：代表系统中的 <code>lsn </code>值，也就是当前系统已经写入的 <code>redo </code>日志量，包括写入 <code>log buffer </code>中的日志。</li>
<li><code>Log flushed up to </code>：代表 <code>flushed_to_disk_lsn </code>的值，也就是当前系统已经写入磁盘的 <code>redo </code>日志量。</li>
<li><code>Pages flushed up to </code>：代表 <code>flush链表 </code>中被最早修改的那个页面对应的 <code>oldest_modification </code>属性值。</li>
<li><code>Last checkpoint at </code>：当前系统的 <code>checkpoint_lsn </code>值。</li>
</ul>
<p>为了保证事务的 <code>持久性 </code>，可以设置 <code>innodb_flush_log_at_trx_commit </code>的系统变量的值：</p>
<ul>
<li><code>0 </code>：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步 <code>redo </code>日志，这个任务是交给后台线程做的。</li>
<li><code>1 </code>：当该系统变量值为1时，表示在事务提交时需要将 <code>redo </code>日志同步到磁盘，可以保证事务的 <code>持久性 </code>。 <code>1 </code>也是 <code>innodb_flush_log_at_trx_commit </code>的默认值。</li>
<li><code>2 </code>：当该系统变量值为2时，表示在事务提交时需要将 <code>redo </code>日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。</li>
</ul>
<h3 id="七-崩溃恢复"><a href="#七-崩溃恢复" class="headerlink" title="七. 崩溃恢复"></a>七. 崩溃恢复</h3><h4 id="确定恢复的起点"><a href="#确定恢复的起点" class="headerlink" title="确定恢复的起点"></a>确定恢复的起点</h4><p>获取最近发生的 <code>checkpoint </code>对应的 <code>checkpoint_lsn </code>值以及它在 <code>redo </code>日志文件组中的偏移量 <code>checkpoint_offset </code>。</p>
<h4 id="确定恢复的终点"><a href="#确定恢复的终点" class="headerlink" title="确定恢复的终点"></a>确定恢复的终点</h4><p>普通block的 <code>log block header </code>部分有一个称之为 <code>LOG_BLOCK_HDR_DATA_LEN </code>的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为 <code>512 </code>。如果该属性的值不为 <code>512 </code>，那么就是它了，它就是此次崩溃恢复中需要扫描的最后一个block。</p>
<h4 id="怎么恢复"><a href="#怎么恢复" class="headerlink" title="怎么恢复"></a>怎么恢复</h4><p>示例：</p>
<p><img src="/./MySQL/NeatReader-1683636764851.png"></p>
<p>可以直接按照顺序恢复，但是这样较慢。</p>
<p>优化：</p>
<ul>
<li><p>使用哈希表</p>
<p>根据 <code>redo </code>日志的 <code>space ID </code>和 <code>page number </code>属性计算出散列值，把 <code>space ID </code>和 <code>page number </code>相同的 <code>redo </code>日志放到哈希表的同一个槽里，如果有多个 <code>space ID </code>和 <code>page number </code>都相同的 <code>redo </code>日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，如图所示：</p>
<p><img src="/./MySQL/NeatReader-1683636846571.png"></p>
<p>这样可以一次性将一个页面恢复好（避免了很多读取页面的随机IO），加快了恢复速度，恢复的时候要按照redo日志的生成顺序恢复。</p>
</li>
<li><p>跳过已经刷新到磁盘的页面</p>
<p><code>checkpoint_lsn </code>之前的 <code>redo </code>日志对应的脏页确定都已经刷到磁盘了，但是 <code>checkpoint_lsn </code>之后的 <code>redo </code>日志我们不能确定是否已经刷到磁盘，主要是因为在最近做的一次 <code>checkpoint </code>后，可能后台线程又不断的从 <code>LRU链表 </code>和 <code>flush链表 </code>中将一些脏页刷出 <code>Buffer Pool </code>。这些在 <code>checkpoint_lsn </code>之后的 <code>redo </code>日志，如果它们对应的脏页在崩溃发生时已经刷新到磁盘，那在恢复时也就没有必要根据 <code>redo </code>日志的内容修改该页面了。</p>
<p>那在恢复时怎么知道某个 <code>redo </code>日志对应的脏页是否在崩溃发生时已经刷新到磁盘了呢？这还得从页面的结构说起，我们前边说过每个页面都有一个称之为 <code>File Header </code>的部分，在 <code>File Header </code>里有一个称之为 <code>FIL_PAGE_LSN </code>的属性，该属性记载了最近一次修改页面时对应的 <code>lsn </code>值（其实就是页面控制块中的 <code>newest_modification </code>值）。如果在做了某次 <code>checkpoint </code>之后有脏页被刷新到磁盘中，那么该页对应的 <code>FIL_PAGE_LSN </code>代表的 <code>lsn </code>值肯定大于 <code>checkpoint_lsn </code>的值，凡是符合这种情况的页面就不需要重复执行lsn值小于 <code>FIL_PAGE_LSN </code>的redo日志了，所以更进一步提升了崩溃恢复的速度。</p>
</li>
</ul>
<h4 id="LOG-BLOCK-HDR-NO是如何计算的"><a href="#LOG-BLOCK-HDR-NO是如何计算的" class="headerlink" title="LOG_BLOCK_HDR_NO是如何计算的"></a>LOG_BLOCK_HDR_NO是如何计算的</h4><p><code>LOG_BLOCK_HDR_NO </code>这个属性代表一个唯一的标号。</p>
<p>公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((lsn / 512) &amp; 0x3FFFFFFFUL) + 1</span><br></pre></td></tr></table></figure>

<p><img src="/./MySQL/NeatReader-1683637101243.png"></p>
<p>显然计算结果在 <code>1 ~ 0x40000000UL </code>之间， <code>0x40000000UL </code>就代表1GB。也就是说系统最多能产生不重复的 <code>LOG_BLOCK_HDR_NO </code>值只有 <code>1GB </code>个。</p>
<p>设计InnoDB的大叔规定 <code>redo </code>日志文件组中包含的所有文件大小总和不得超过512GB，一个block大小是512字节，也就是说redo日志文件组中包含的block块最多为1GB个，所以有1GB个不重复的编号值也就够用了。</p>
<p>另外， <code>LOG_BLOCK_HDR_NO </code>值的第一个比特位比较特殊，称之为 <code>flush bit </code>，如果该值为1，代表着本block是在某次将 <code>log buffer </code>中的block刷新到磁盘的操作中的第一个被刷入的block。</p>
<hr>
<h2 id="undo-日志"><a href="#undo-日志" class="headerlink" title="undo 日志"></a>undo 日志</h2><p>设计数据库的大叔把这些为了回滚而记录的东东称之为撤销日志，英文名为 <code>undo log</code>。</p>
<p>由于查询操作（ <code>SELECT </code>）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的 <code>undo日志 </code>。</p>
<h3 id="一-事务id"><a href="#一-事务id" class="headerlink" title="一. 事务id"></a>一. 事务id</h3><h4 id="分配时机"><a href="#分配时机" class="headerlink" title="分配时机"></a>分配时机</h4><p>如果某个事务执行过程中对某个表执行了增、删、改操作，那么 <code>InnoDB </code>存储引擎就会给它分配一个独一无二的 <code>事务id </code>，分配方式如下：</p>
<ul>
<li><p>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个 <code>事务id </code>，否则的话是不分配 <code>事务id </code>的。</p>
<p>SELECT 语句中创建的内部临时表不会被分配事务id，只有用户使用CREATE TEMPORARY TABLE创建的临时表才会被分配事务id</p>
</li>
<li><p>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个 <code>事务id </code>，否则的话也是不分配 <code>事务id </code>的。</p>
</li>
</ul>
<h4 id="生成策略"><a href="#生成策略" class="headerlink" title="生成策略"></a>生成策略</h4><p> <code>事务id </code>本质上就是一个数字，它的分配策略和我们前边提到的对隐藏列 <code>row_id </code>（当用户没有为表创建主键和 <code>UNIQUE </code>键时 <code>InnoDB </code>自动创建的列）的分配策略大抵相同，具体策略如下：</p>
<ul>
<li>服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个 <code>事务id </code>时，就会把该变量的值当作 <code>事务id </code>分配给该事务，并且把该变量自增1。</li>
<li>每当这个变量的值为 <code>256 </code>的倍数时，就会将该变量的值刷新到系统表空间的页号为 <code>5 </code>的页面中一个称之为 <code>Max Trx ID </code>的属性处，这个属性占用 <code>8 </code>个字节的存储空间。</li>
<li>当系统下一次重新启动时，会将上边提到的 <code>Max Trx ID </code>属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于 <code>Max Trx ID </code>属性值）。</li>
</ul>
<p>聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row_id的隐藏列。 </p>
<h3 id="二-undo-日志的格式"><a href="#二-undo-日志的格式" class="headerlink" title="二. undo 日志的格式"></a>二. undo 日志的格式</h3><h4 id="1-INSERT操作对应的undo日志"><a href="#1-INSERT操作对应的undo日志" class="headerlink" title="1. INSERT操作对应的undo日志"></a>1. INSERT操作对应的undo日志</h4><p> <code>TRX_UNDO_INSERT_REC </code>的 <code>undo日志 </code>结构：</p>
<p><img src="/./MySQL/NeatReader-1683682343071.png"></p>
<blockquote>
<p>当我们向某个表中插入一条记录时，实际上需要向聚簇索引和所有的二级索引都插入一条记录。不过记录undo日志时，我们只需要考虑向聚簇索引插入记录时的情况就好了，因为其实聚簇索引记录和二级索引记录是一一对应的，我们在回滚插入操作时，只需要知道这条记录的主键信息，然后根据主键信息做对应的删除操作，做删除操作时就会顺带着把所有二级索引中相应的记录也删除掉。后边说到的DELETE操作和UPDATE操作对应的undo日志也都是针对聚簇索引记录而言的，我们之后就不强调了。</p>
</blockquote>
<h5 id="roll-pointer-的含义"><a href="#roll-pointer-的含义" class="headerlink" title="roll_pointer 的含义"></a>roll_pointer 的含义</h5><p><img src="/./MySQL/NeatReader-1683682618700.png"></p>
<p> <code>roll_pointer </code>本质就是一个指针，指向记录对应的undo日志 。</p>
<h4 id="2-DELETE操作对应的undo日志"><a href="#2-DELETE操作对应的undo日志" class="headerlink" title="2. DELETE操作对应的undo日志"></a>2. DELETE操作对应的undo日志</h4><p>假设此刻某个页面中的记录分布情况是这样的：</p>
<p><img src="/./MySQL/NeatReader-1683682788532.png"></p>
<p>使用 <code>DELETE </code>语句把 <code>正常记录链表 </code>中的记录删除时要经历两个阶段：</p>
<ul>
<li><p>阶段一：仅仅将记录的 <code>delete_mask </code>标识位设置为 <code>1 </code>，其他的不做修改（其实会修改记录的 <code>trx_id </code>、 <code>roll_pointer </code>这些隐藏列的值）。设计 <code>InnoDB </code>的大叔把这个阶段称之为 <code>delete mark </code>。</p>
<p><img src="/./MySQL/NeatReader-1683682849459.png"></p>
<p>这种中间状态最终是为了实现MVCC功能。</p>
</li>
<li><p>阶段二： 当该删除语句所在的事务提交之后 ，会有 专门的线程后 来真正的把记录删除掉。所谓真正的删除就是把该记录从 <code>正常记录链表 </code>中移除，并且加入到 <code>垃圾链表 </code>中，然后还要调整一些页面的其他信息，比如页面中的用户记录数量 <code>PAGE_N_RECS </code>、上次插入记录的位置 <code>PAGE_LAST_INSERT </code>、垃圾链表头节点的指针 <code>PAGE_FREE </code>、页面中可重用的字节数量 <code>PAGE_GARBAGE </code>、还有页目录的一些信息等等。设计 <code>InnoDB </code>的大叔把这个阶段称之为 <code>purge </code>。</p>
<p><img src="/./MySQL/NeatReader-1683682917419.png"></p>
</li>
</ul>
<blockquote>
<p>页面的Page Header部分有一个PAGE_GARBAGE属性，该属性记录着当前页面中可重用存储空间占用的总字节数。当新插入一条记录时，首先判断垃圾链表的头节点代表的记录空间是否足够容纳该条记录，如果足够，则直接复用，否则申请一块新的空间。此时若可以容纳，但是新插入的记录占用的空间小于垃圾链表头节点占用的空间，就会产生碎片空间，这部分空间也被统计在PAGE_GARBAGE中。当该页面快要满时，若页面已经无法分配一条完整记录的空间，那么就会将PAGE_GARBAGE和剩余可用空间加起来，看是否能够容纳一条记录，如果能，则InnoDB会重新组织空间结构，即先开辟一个临时页面，把页面内的记录依次插入一遍，因为依次插入时并不会产生碎片，之后再把临时页面的内容复制到本页面，这样碎片空间便得以利用，但是重新组织较为消耗性能。</p>
</blockquote>
<p>在删除语句所在的事务提交之前，只会经历 <code>阶段一 </code>，也就是 <code>delete mark </code>阶段，我们只需考虑这个阶段的回滚。</p>
<p><code>TRX_UNDO_DEL_MARK_REC </code>类型的<code>undo</code>日志结构：</p>
<p><img src="/./MySQL/NeatReader-1683683441236.png"> </p>
<ul>
<li><p>在对一条记录进行 <code>delete mark </code>操作前，需要把该记录的旧的 <code>trx_id </code>和 <code>roll_pointer </code>隐藏列的值都给记到对应的 <code>undo日志 </code>中来，就是我们图中显示的 <code>old trx_id </code>和 <code>old roll_pointer </code>属性。这样有一个好处，那就是可以通过 <code>undo日志 </code>的 <code>old roll_pointer </code>找到记录在修改之前对应的 <code>undo </code>日志。比方说在一个事务中，我们先插入了一条记录，然后又执行对该记录的删除操作，这个过程的示意图就是这样：</p>
<p><img src="/./MySQL/NeatReader-1683683486732.png"></p>
<p>这个undo日志构成的链表被称为<code>版本链</code>。</p>
</li>
</ul>
<h4 id="3-UPDATE操作对应的undo日志"><a href="#3-UPDATE操作对应的undo日志" class="headerlink" title="3. UPDATE操作对应的undo日志"></a>3. UPDATE操作对应的undo日志</h4><h5 id="不更新主键的情况"><a href="#不更新主键的情况" class="headerlink" title="不更新主键的情况"></a>不更新主键的情况</h5><p>在不更新主键的情况下，又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。</p>
<ul>
<li><p>就地更新（in-place update）</p>
<p>更新记录时，对于被更新的 每个列 来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行 <code>就地更新 </code>，也就是直接在原记录的基础上修改对应列的值。</p>
</li>
<li><p>先删除掉旧记录，再插入新记录</p>
<p>在不更新主键的情况下，如果有 任何一个 被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。</p>
<p>这里所说的 <code>删除 </code>并不是 <code>delete mark </code>操作，而是真正的删除掉，也就是把这条记录从 <code>正常记录链表 </code>中移除并加入到 <code>垃圾链表 </code>中，此时是由用户线程同步执行真正的删除操作，而非做 <code>purge </code>操作时使用的另外专门的线程，真正删除之后紧接着就要根据各个列更新后的值创建的新记录插入。</p>
</li>
</ul>
<p> <code>TRX_UNDO_UPD_EXIST_REC </code>的 <code>undo日志 </code>结构：</p>
<p><img src="/./MySQL/NeatReader-1683684061059.png"></p>
<h5 id="更新主键的情况"><a href="#更新主键的情况" class="headerlink" title="更新主键的情况"></a>更新主键的情况</h5><ul>
<li><p>将旧记录进行 <code>delete mark </code>操作</p>
<p>之所以只对旧记录做delete mark操作，是因为别的事务同时也可能访问这条记录，如果把它真正的删除加入到垃圾链表后，别的事务就访问不到了，这就是所谓的MVCC。</p>
</li>
<li><p>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。</p>
</li>
</ul>
<p>针对 <code>UPDATE </code>语句更新记录主键值的这种情况，在对该记录进行 <code>delete mark </code>操作前，会记录一条类型为 <code>TRX_UNDO_DEL_MARK_REC </code>的 <code>undo日志 </code>；之后插入新记录时，会记录一条类型为 <code>TRX_UNDO_INSERT_REC </code>的 <code>undo日志 </code>，也就是说每对一条记录的主键值做改动时，会记录2条 <code>undo日志 </code>。</p>
<h3 id="三-FIL-PAGE-UNDO-LOG页面"><a href="#三-FIL-PAGE-UNDO-LOG页面" class="headerlink" title="三. FIL_PAGE_UNDO_LOG页面"></a>三. FIL_PAGE_UNDO_LOG页面</h3><p>页面结构：</p>
<p><img src="/./MySQL/NeatReader-1683686414460.png"></p>
<p> <code>Undo Page Header </code>：</p>
<p><img src="/./MySQL/NeatReader-1683686439846.png"></p>
<ul>
<li><p><code>TRX_UNDO_PAGE_TYPE </code>：本页面准备存储什么种类的 <code>undo日志 </code>。</p>
<p>主要分为两个大类：</p>
<ul>
<li><code>TRX_UNDO_INSERT </code>（使用十进制 <code>1 </code>表示，可直接删除）：类型为 <code>TRX_UNDO_INSERT_REC </code>的 <code>undo日志 </code>属于此大类，一般由 <code>INSERT </code>语句产生，或者在 <code>UPDATE </code>语句中有更新主键的情况也会产生此类型的 <code>undo日志 </code>。</li>
<li><code>TRX_UNDO_UPDATE </code>（使用十进制 <code>2 </code>表示，不可直接删除，为MVCC服务），除了类型为 <code>TRX_UNDO_INSERT_REC </code>的 <code>undo日志 </code>，其他类型的 <code>undo日志 </code>都属于这个大类，比如我们前边说的 <code>TRX_UNDO_DEL_MARK_REC </code>、 <code>TRX_UNDO_UPD_EXIST_REC </code>啥的，一般由 <code>DELETE </code>、 <code>UPDATE </code>语句产生的 <code>undo日志 </code>属于这个大类。</li>
</ul>
</li>
<li><p><code>TRX_UNDO_PAGE_START </code>：表示在当前页面中是从什么位置开始存储 <code>undo日志 </code>的，或者说表示第一条 <code>undo日志 </code>在本页面中的起始偏移量。</p>
</li>
<li><p><code>TRX_UNDO_PAGE_FREE </code>：与上边的 <code>TRX_UNDO_PAGE_START </code>对应，表示当前页面中存储的最后一条 <code>undo </code>日志结束时的偏移量，或者说从这个位置开始，可以继续写入新的 <code>undo日志 </code>。</p>
</li>
<li><p><code>TRX_UNDO_PAGE_NODE </code>：代表一个 <code>List Node </code>结构。</p>
</li>
</ul>
<h3 id="四-Undo页面链表"><a href="#四-Undo页面链表" class="headerlink" title="四. Undo页面链表"></a>四. Undo页面链表</h3><h4 id="单个事务中的Undo页面链表"><a href="#单个事务中的Undo页面链表" class="headerlink" title="单个事务中的Undo页面链表"></a>单个事务中的Undo页面链表</h4><p><img src="/./MySQL/NeatReader-1683686643847.png"></p>
<p>第一个 <code>Undo页面 </code>给标了出来，称它为 <code>first undo page </code>，其余的 <code>Undo页面 </code>称之为 <code>normal undo page </code>，这是因为在 <code>first undo page </code>中除了记录 <code>Undo Page Header </code>之外，还会记录其他的一些管理信息。</p>
<p>链表的分类：</p>
<p><img src="/./MySQL/NeatReader-1683686716543.png"></p>
<p>初始时这些链表都不存在，按需分配，啥时候需要啥时候再分配，不需要就不分配 。</p>
<h4 id="多个事务中的Undo页面链表"><a href="#多个事务中的Undo页面链表" class="headerlink" title="多个事务中的Undo页面链表"></a>多个事务中的Undo页面链表</h4><p>分事务即可。</p>
<h3 id="五-undo日志写入过程"><a href="#五-undo日志写入过程" class="headerlink" title="五. undo日志写入过程"></a>五. undo日志写入过程</h3><h4 id="Undo-Log-Segment-Header"><a href="#Undo-Log-Segment-Header" class="headerlink" title="Undo Log Segment Header"></a>Undo Log Segment Header</h4><p>设计 <code>InnoDB </code>的大叔规定，每一个 <code>Undo页面 </code>链表都对应着一个 <code>段 </code>，称之为 <code>Undo Log Segment </code>。</p>
<p>仅存在于 <code>first undo page </code>。</p>
<p><img src="/./MySQL/NeatReader-1683686883174.png"></p>
<ul>
<li><p><code>TRX_UNDO_STATE </code>：本 <code>Undo页面 </code>链表处在什么状态。</p>
<p>一个 <code>Undo Log Segment </code>可能处在的状态包括：</p>
<ul>
<li><code>TRX_UNDO_ACTIVE </code>：活跃状态，也就是一个活跃的事务正在往这个段里边写入 <code>undo日志 </code>。</li>
<li><code>TRX_UNDO_CACHED </code>：被缓存的状态。处在该状态的 <code>Undo页面 </code>链表等待着之后被其他事务重用。</li>
<li><code>TRX_UNDO_TO_FREE </code>：对于 <code>insert undo </code>链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li>
<li><code>TRX_UNDO_TO_PURGE </code>：对于 <code>update undo </code>链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li>
<li><code>TRX_UNDO_PREPARED </code>：包含处于 <code>PREPARE </code>阶段的事务产生的 <code>undo日志 </code>。</li>
</ul>
</li>
<li><p><code>TRX_UNDO_LAST_LOG </code>：本 <code>Undo页面 </code>链表中最后一个 <code>Undo Log Header </code>的位置。</p>
</li>
<li><p><code>TRX_UNDO_FSEG_HEADER </code>：本 <code>Undo页面 </code>链表对应的段的 <code>Segment Header </code>信息。</p>
</li>
<li><p><code>TRX_UNDO_PAGE_LIST </code>： <code>Undo页面 </code>链表的基节点。</p>
</li>
</ul>
<h4 id="Undo-Log-Header"><a href="#Undo-Log-Header" class="headerlink" title="Undo Log Header"></a>Undo Log Header</h4><p>在每写入一组 <code>undo日志 </code>时，都会在这组 <code>undo日志 </code>前先记录一下关于这个组的一些属性，设计 <code>InnoDB </code>的大叔把存储这些属性的地方称之为 <code>Undo Log Header </code>。</p>
<p>仅存在于 <code>first undo page </code>。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>对于没有被重用的 <code>Undo页面 </code>链表来说，链表的第一个页面，也就是 <code>first undo page </code>在真正写入 <code>undo日志 </code>前，会填充 <code>Undo Page Header </code>、 <code>Undo Log Segment Header </code>、 <code>Undo Log Header </code>这3个部分，之后才开始正式写入 <code>undo日志 </code>。对于其他的页面来说，也就是 <code>normal undo page </code>在真正写入 <code>undo日志 </code>前，只会填充 <code>Undo Page Header </code>。链表的 <code>List Base Node </code>存放到 <code>first undo page </code>的 <code>Undo Log Segment Header </code>部分， <code>List Node </code>信息存放到每一个 <code>Undo页面 </code>的 <code>undo Page Header </code>部分，所以画一个 <code>Undo页面 </code>链表的示意图就是这样：</p>
<p><img src="/./MySQL/NeatReader-1683687082790.png"></p>
<h3 id="六-重用Undo页面"><a href="#六-重用Undo页面" class="headerlink" title="六. 重用Undo页面"></a>六. 重用Undo页面</h3><p>条件：</p>
<ul>
<li>该链表中只包含一个 <code>Undo页面 </code>。</li>
<li>该 <code>Undo页面 </code>已经使用的空间小于整个页面空间的3&#x2F;4。</li>
</ul>
<p> <code>Undo页面 </code>链表按照存储的 <code>undo日志 </code>所属的大类可以被分为 <code>insert undo链表 </code>和 <code>update undo链表 </code>两种，这两种链表在被重用时的策略也是不同的，我们分别看一下：</p>
<ul>
<li><p>insert undo链表</p>
<p><code>insert undo链表 </code>中只存储类型为 <code>TRX_UNDO_INSERT_REC </code>的 <code>undo日志 </code>，这种类型的 <code>undo日志 </code>在事务提交之后就没用了，就可以被清除掉。所以在某个事务提交后，重用这个事务的 <code>insert undo链表 </code>（这个链表中只有一个页面）时，可以直接把之前事务写入的一组 <code>undo日志 </code>覆盖掉，从头开始写入新事务的一组 <code>undo日志 </code>。</p>
</li>
<li><p>update undo链表</p>
<p> <code>update undo链表 </code>中的 <code>undo日志 </code>不能立即删除掉（为了MVCC），只能在后面接着写。</p>
</li>
</ul>
<h3 id="七-回滚段"><a href="#七-回滚段" class="headerlink" title="七. 回滚段"></a>七. 回滚段</h3><p>一个事务在执行过程中最多可以分配4个 <code>Undo页面 </code>链表，在同一时刻不同事务拥有的 <code>Undo页面 </code>链表是不一样的，所以在同一时刻系统里其实可以有许许多多个 <code>Undo页面 </code>链表存在。为了更好的管理这些链表，设计 <code>InnoDB </code>的大叔又设计了一个称之为 <code>Rollback Segment Header </code>的页面，在这个页面中存放了各个 <code>Undo页面 </code>链表的 <code>frist undo page </code>的 <code>页号 </code>，他们把这些 <code>页号 </code>称之为 <code>undo slot </code>。</p>
<h4 id="从回滚段中申请Undo页面链表"><a href="#从回滚段中申请Undo页面链表" class="headerlink" title="从回滚段中申请Undo页面链表"></a>从回滚段中申请Undo页面链表</h4><p>初始情况下，由于未向任何事务分配任何 <code>Undo页面 </code>链表，所以对于一个 <code>Rollback Segment Header </code>页面来说，它的各个 <code>undo slot </code>都被设置成了一个特殊的值： <code>FIL_NULL </code>（对应的十六进制就是 <code>0xFFFFFFFF </code>），表示该 <code>undo slot </code>不指向任何页面。</p>
<p>分配过程即寻找第一个不为<code>FIL_NULL</code>的<code>undo slot</code>。</p>
<p>当一个事务提交时，它所占用的 <code>undo slot </code>有两种命运：</p>
<ul>
<li><p>如果该 <code>undo slot </code>指向的 <code>Undo页面 </code>链表符合被重用的条件（就是我们上边说的 <code>Undo页面 </code>链表只占用一个页面并且已使用空间小于整个页面的3&#x2F;4）。</p>
<p>该 <code>undo slot </code>就处于被缓存的状态，设计 <code>InnoDB </code>的大叔规定这时该 <code>Undo页面 </code>链表的 <code>TRX_UNDO_STATE </code>属性（该属性在 <code>first undo page </code>的 <code>Undo Log Segment Header </code>部分）会被设置为 <code>TRX_UNDO_CACHED </code>。</p>
</li>
<li><p>如果该 <code>undo slot </code>指向的 <code>Undo页面 </code>链表不符合被重用的条件，那么针对该 <code>undo slot </code>对应的 <code>Undo页面 </code>链表类型不同，也会有不同的处理：</p>
<ul>
<li><p><code>insert undo链表 </code></p>
<p><code>TRX_UNDO_STATE </code>属性会被设置为 <code>TRX_UNDO_TO_FREE </code>，直接释放，<code>undo slot </code>的值设置为 <code>FIL_NULL </code>。</p>
</li>
<li><p><code>update undo链表 </code></p>
<p><code>TRX_UNDO_STATE </code>属性会被设置为 <code>TRX_UNDO_TO_PRUGE </code>， <code>undo slot </code>的值设置为 <code>FIL_NULL </code>，然后将本次事务写入的一组 <code>undo </code>日志放到所谓的 <code>History链表 </code></p>
</li>
</ul>
</li>
</ul>
<h4 id="多个回滚段"><a href="#多个回滚段" class="headerlink" title="多个回滚段"></a>多个回滚段</h4><p><img src="/./MySQL/NeatReader-1683687643263.png"></p>
<h4 id="为事务分配Undo页面链表详细过程"><a href="#为事务分配Undo页面链表详细过程" class="headerlink" title="为事务分配Undo页面链表详细过程"></a>为事务分配Undo页面链表详细过程</h4><ul>
<li><p>事务在执行过程中对普通表的记录首次做改动之前，首先会到系统表空间的第 <code>5 </code>号页面中分配一个回滚段（其实就是获取一个 <code>Rollback Segment Header </code>页面的地址）。一旦某个回滚段被分配给了这个事务，那么之后该事务中再对普通表的记录做改动时，就不会重复分配了。</p>
<p>使用传说中的 <code>round-robin </code>（循环使用）方式来分配回滚段。比如当前事务分配了第 <code>0 </code>号回滚段，那么下一个事务就要分配第 <code>33 </code>号回滚段，下下个事务就要分配第 <code>34 </code>号回滚段，简单一点的说就是这些回滚段被轮着分配给不同的事务（就是这么简单粗暴，没啥好说的）。</p>
</li>
<li><p>在分配到回滚段后，首先看一下这个回滚段的两个 <code>cached链表 </code>有没有已经缓存了的 <code>undo slot </code>，比如如果事务做的是 <code>INSERT </code>操作，就去回滚段对应的 <code>insert undo cached链表 </code>中看看有没有缓存的 <code>undo slot </code>；如果事务做的是 <code>DELETE </code>操作，就去回滚段对应的 <code>update undo cached链表 </code>中看看有没有缓存的 <code>undo slot </code>。如果有缓存的 <code>undo slot </code>，那么就把这个缓存的 <code>undo slot </code>分配给该事务。</p>
</li>
<li><p>如果没有缓存的 <code>undo slot </code>可供分配，那么就要到 <code>Rollback Segment Header </code>页面中找一个可用的 <code>undo slot </code>分配给当前事务。</p>
<p>从 <code>Rollback Segment Header </code>页面中分配可用的 <code>undo slot </code>的方式我们上边也说过了，就是从第 <code>0 </code>个 <code>undo slot </code>开始，如果该 <code>undo slot </code>的值为 <code>FIL_NULL </code>，意味着这个 <code>undo slot </code>是空闲的，就把这个 <code>undo slot </code>分配给当前事务，否则查看第 <code>1 </code>个 <code>undo slot </code>是否满足条件，依次类推，直到最后一个 <code>undo slot </code>。如果这 <code>1024 </code>个 <code>undo slot </code>都没有值为 <code>FIL_NULL </code>的情况，就直接报错喽（一般不会出现这种情况）～</p>
</li>
<li><p>找到可用的 <code>undo slot </code>后，如果该 <code>undo slot </code>是从 <code>cached链表 </code>中获取的，那么它对应的 <code>Undo Log Segment </code>已经分配了，否则的话需要重新分配一个 <code>Undo Log Segment </code>，然后从该 <code>Undo Log Segment </code>中申请一个页面作为 <code>Undo页面 </code>链表的 <code>first undo page </code>。</p>
</li>
<li><p>然后事务就可以把 <code>undo日志 </code>写入到上边申请的 <code>Undo页面 </code>链表了！</p>
</li>
<li><p>事务在执行过程中对普通表的记录首次做改动之前，首先会到系统表空间的第 <code>5 </code>号页面中分配一个回滚段（其实就是获取一个 <code>Rollback Segment Header </code>页面的地址）。一旦某个回滚段被分配给了这个事务，那么之后该事务中再对普通表的记录做改动时，就不会重复分配了。</p>
<p>使用传说中的 <code>round-robin </code>（循环使用）方式来分配回滚段。比如当前事务分配了第 <code>0 </code>号回滚段，那么下一个事务就要分配第 <code>33 </code>号回滚段，下下个事务就要分配第 <code>34 </code>号回滚段，简单一点的说就是这些回滚段被轮着分配给不同的事务（就是这么简单粗暴，没啥好说的）。</p>
</li>
<li><p>在分配到回滚段后，首先看一下这个回滚段的两个 <code>cached链表 </code>有没有已经缓存了的 <code>undo slot </code>，比如如果事务做的是 <code>INSERT </code>操作，就去回滚段对应的 <code>insert undo cached链表 </code>中看看有没有缓存的 <code>undo slot </code>；如果事务做的是 <code>DELETE </code>操作，就去回滚段对应的 <code>update undo cached链表 </code>中看看有没有缓存的 <code>undo slot </code>。如果有缓存的 <code>undo slot </code>，那么就把这个缓存的 <code>undo slot </code>分配给该事务。</p>
</li>
<li><p>如果没有缓存的 <code>undo slot </code>可供分配，那么就要到 <code>Rollback Segment Header </code>页面中找一个可用的 <code>undo slot </code>分配给当前事务。</p>
<p>从 <code>Rollback Segment Header </code>页面中分配可用的 <code>undo slot </code>的方式我们上边也说过了，就是从第 <code>0 </code>个 <code>undo slot </code>开始，如果该 <code>undo slot </code>的值为 <code>FIL_NULL </code>，意味着这个 <code>undo slot </code>是空闲的，就把这个 <code>undo slot </code>分配给当前事务，否则查看第 <code>1 </code>个 <code>undo slot </code>是否满足条件，依次类推，直到最后一个 <code>undo slot </code>。如果这 <code>1024 </code>个 <code>undo slot </code>都没有值为 <code>FIL_NULL </code>的情况，就直接报错喽（一般不会出现这种情况）～</p>
</li>
<li><p>找到可用的 <code>undo slot </code>后，如果该 <code>undo slot </code>是从 <code>cached链表 </code>中获取的，那么它对应的 <code>Undo Log Segment </code>已经分配了，否则的话需要重新分配一个 <code>Undo Log Segment </code>，然后从该 <code>Undo Log Segment </code>中申请一个页面作为 <code>Undo页面 </code>链表的 <code>first undo page </code>。</p>
</li>
<li><p>然后事务就可以把 <code>undo日志 </code>写入到上边申请的 <code>Undo页面 </code>链表了！</p>
</li>
</ul>
<hr>
<h2 id="事务隔离级别和MVCC"><a href="#事务隔离级别和MVCC" class="headerlink" title="事务隔离级别和MVCC"></a>事务隔离级别和MVCC</h2><h3 id="一-事务隔离级别"><a href="#一-事务隔离级别" class="headerlink" title="一. 事务隔离级别"></a>一. 事务隔离级别</h3><p>访问相同数据的事务在不保证串行执行的情况下可能会出现的问题：</p>
<ul>
<li><p>脏写（ <code>Dirty Write </code>）</p>
<p>如果 一个事务修改了另一个未提交事务修改过的数据 ，那就意味着发生了 <code>脏写</code>。</p>
</li>
<li><p>脏读（ <code>Dirty Read </code>）</p>
<p>如果 一个事务读到了另一个未提交事务修改过的数据 ，那就意味着发生了 <code>脏读 </code>。</p>
</li>
<li><p>不可重复读（<code>Non-Repeatable Read</code>）</p>
<p>如果 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值 ，那就意味着发生了 <code>不可重复读 </code>。</p>
</li>
<li><p>幻读（<code>Phantom</code>）</p>
<p>如果 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来 ，那就意味着发生了 <code>幻读 </code>。</p>
<p>对于先前已经读到的记录，之后又读取不到这种情况，相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。</p>
</li>
</ul>
<h4 id="SQL标准中的四种隔离级别"><a href="#SQL标准中的四种隔离级别" class="headerlink" title="SQL标准中的四种隔离级别"></a>SQL标准中的四种隔离级别</h4><p>严重性排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</span><br></pre></td></tr></table></figure>

<p> <code>SQL标准 </code>，四个<code>隔离级别</code>：</p>
<ul>
<li><code>READ UNCOMMITTED </code>：未提交读。</li>
<li><code>READ COMMITTED </code>：已提交读。</li>
<li><code>REPEATABLE READ </code>：可重复读。</li>
<li><code>SERIALIZABLE </code>：可串行化。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td><code>READ UNCOMMITTED</code></td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td><code>READ COMMITTED</code></td>
<td>Not Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td><code>REPEATABLE READ</code></td>
<td>Not Possible</td>
<td>Not Possible</td>
<td>Possible</td>
</tr>
<tr>
<td><code>SERIALIZABLE</code></td>
<td>Not Possible</td>
<td>Not Possible</td>
<td>Not Possible</td>
</tr>
</tbody></table>
<h4 id="MySQL中支持的四种隔离级别"><a href="#MySQL中支持的四种隔离级别" class="headerlink" title="MySQL中支持的四种隔离级别"></a>MySQL中支持的四种隔离级别</h4><p>不同的数据库厂商对 <code>SQL标准 </code>中规定的四种隔离级别支持不一样，比方说 <code>Oracle </code>就只支持 <code>READ COMMITTED </code>和 <code>SERIALIZABLE </code>隔离级别。本书中所讨论的 <code>MySQL </code>虽然支持4种隔离级别，但与 <code>SQL标准 </code>中所规定的各级隔离级别允许发生的问题却有些出入， MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的。</p>
<p><code>MySQL </code>的默认隔离级别为 <code>REPEATABLE READ </code>，我们可以手动修改一下事务的隔离级别。</p>
<p><strong>设置事务的隔离级别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用 <code>GLOBAL </code>关键字（在全局范围影响）：</p>
<ul>
<li>只对执行完该语句之后产生的会话起作用。</li>
<li>当前已经存在的会话无效。</li>
</ul>
</li>
<li><p>使用 <code>SESSION </code>关键字（在会话范围影响）：</p>
<ul>
<li>对当前会话的所有后续的事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。</li>
<li>如果在事务之间执行，则对后续的事务有效。</li>
</ul>
</li>
<li><p>上述两个关键字都不用（只对执行语句后的下一个事务产生影响）：</p>
<ul>
<li>只对当前会话中下一个即将开启的事务有效。</li>
<li>下一个事务执行完后，后续事务将恢复到之前的隔离级别。</li>
<li>该语句不能在已经开启的事务中间执行，会报错的。</li>
</ul>
</li>
</ul>
<h3 id="二-MVCC原理"><a href="#二-MVCC原理" class="headerlink" title="二. MVCC原理"></a>二. MVCC原理</h3><h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><p>对记录每次更新后，都会将旧值放到一条 <code>undo日志 </code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 <code>roll_pointer </code>属性连接成一个链表，我们把这个链表称之为 <code>版本链 </code>， 版本链的头节点就是当前记录最新的值 。</p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>对于使用 <code>READ UNCOMMITTED </code>隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；对于使用 <code>SERIALIZABLE </code>隔离级别的事务来说，设计 <code>InnoDB </code>的大叔规定使用加锁的方式来访问记录；对于使用 <code>READ COMMITTED </code>和 <code>REPEATABLE READ </code>隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是： 需要判断一下版本链中的哪个版本是当前事务可见的 。为此，设计 <code>InnoDB </code>的大叔提出了一个 <code>ReadView </code>的概念，这个 <code>ReadView </code>中主要包含4个比较重要的内容：</p>
<ul>
<li><code>m_ids </code>：表示在生成 <code>ReadView </code>时当前系统中活跃的读写事务的 <code>事务id </code>列表。</li>
<li><code>min_trx_id </code>：表示在生成 <code>ReadView </code>时当前系统中活跃的读写事务中最小的 <code>事务id </code>，也就是 <code>m_ids </code>中的最小值。</li>
<li><code>max_trx_id </code>：表示生成 <code>ReadView </code>时系统中应该分配给下一个事务的 <code>id </code>值。</li>
<li><code>creator_trx_id </code>：表示生成该 <code>ReadView </code>的事务的 <code>事务id </code>。</li>
</ul>
<p>判断版本是否可见：</p>
<ul>
<li>如果被访问版本的 <code>trx_id </code>属性值与 <code>ReadView </code>中的 <code>creator_trx_id </code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的 <code>trx_id </code>属性值小于 <code>ReadView </code>中的 <code>min_trx_id </code>值，表明生成该版本的事务在当前事务生成 <code>ReadView </code>前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的 <code>trx_id </code>属性值大于或等于 <code>ReadView </code>中的 <code>max_trx_id </code>值，表明生成该版本的事务在当前事务生成 <code>ReadView </code>后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的 <code>trx_id </code>属性值在 <code>ReadView </code>的 <code>min_trx_id </code>和 <code>max_trx_id </code>之间，那就需要判断一下 <code>trx_id </code>属性值是不是在 <code>m_ids </code>列表中，如果在，说明创建 <code>ReadView </code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 <code>ReadView </code>时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
<p> <code>READ COMMITTED </code>和 <code>REPEATABLE READ </code>生成ReadView的时机不同： </p>
<ul>
<li><p>READ COMMITTED —— 每次读取数据前都生成一个ReadView</p>
</li>
<li><p>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</p>
</li>
</ul>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p> <code>MVCC </code>（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 <code>READ COMMITTD </code>、 <code>REPEATABLE READ </code>这两种隔离级别的事务在执行普通的 <code>SELECT </code>操作时访问记录的版本链的过程，这样子可以使不同事务的 <code>读-写 </code>、 <code>写-读 </code>操作并发执行，从而提升系统性能。</p>
<hr>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>并发事务访问相同记录的情况大致可以划分为3种：</p>
<ul>
<li><p><code>读-读 </code>情况：即并发事务相继读取相同的记录。</p>
<p>读取操作对记录本身没有任何影响，允许这种情况发生。</p>
</li>
<li><p><code>写-写 </code>情况：即并发事务相继对相同的记录做出改动。</p>
<p>即脏写，不允许这种情况发生，加<code>锁</code>解决。</p>
</li>
<li><p><code>读-写 </code>或 <code>写-读 </code>情况：也就是一个事务进行读取操作，另一个进行改动操作。</p>
<ul>
<li>方案一：读操作利用多版本并发控制（ <code>MVCC </code>），写操作进行 <code>加锁 </code>。（性能高）</li>
<li>方案二：读、写操作都采用 <code>加锁 </code>的方式。（性能低）</li>
</ul>
</li>
</ul>
<h3 id="一-解决并发事务带来问题的两种基本方式"><a href="#一-解决并发事务带来问题的两种基本方式" class="headerlink" title="一. 解决并发事务带来问题的两种基本方式"></a>一. 解决并发事务带来问题的两种基本方式</h3><h4 id="一致性读（Consistent-Reads）"><a href="#一致性读（Consistent-Reads）" class="headerlink" title="一致性读（Consistent Reads）"></a>一致性读（Consistent Reads）</h4><p>事务利用 <code>MVCC </code>进行的读取操作称之为 <code>一致性读 </code>，或者 <code>一致性无锁读 </code>，有的地方也称之为 <code>快照读 </code>。</p>
<h4 id="锁定读（Locking-Reads）"><a href="#锁定读（Locking-Reads）" class="headerlink" title="锁定读（Locking Reads）"></a>锁定读（Locking Reads）</h4><p>锁的分类：</p>
<ul>
<li><code>共享锁 </code>，英文名： <code>Shared Locks </code>，简称 <code>S锁 </code>。在事务要读取一条记录时，需要先获取该记录的 <code>S锁 </code>。</li>
<li><code>独占锁 </code>，也常称 <code>排他锁 </code>，英文名： <code>Exclusive Locks </code>，简称 <code>X锁 </code>。在事务要改动一条记录时，需要先获取该记录的 <code>X锁 </code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<ul>
<li><p>对读取的记录加 <code>S锁 </code>：</p>
<p>其它事务可以获取该记录的<code>S锁</code>，不可以获取<code>X锁</code>。</p>
</li>
<li><p>对读取的记录加 <code>X锁 </code>：</p>
<p>其它事务不允许获取该记录的<code>S锁</code>和<code>X锁</code>。</p>
</li>
</ul>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><ul>
<li><p><code>DELETE </code>：加<code>X锁</code></p>
</li>
<li><p><code>UPDATE </code>：</p>
<ul>
<li><p>未修改主键值：</p>
<ul>
<li>就地更新：加<code>X锁</code></li>
<li>非就地更新：对删除操作加<code>X锁</code>，对插入操作有<code>隐式锁</code></li>
</ul>
</li>
<li><p>修改主键值：</p>
<p>按照DELETE和INSERT操作加锁规则</p>
</li>
</ul>
</li>
<li><p><code>INSERT </code>：一般情况下不加锁，具有<code>隐式锁</code></p>
</li>
</ul>
<h3 id="二-多粒度锁"><a href="#二-多粒度锁" class="headerlink" title="二. 多粒度锁"></a>二. 多粒度锁</h3><table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<p>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。</p>
<h3 id="三-MySQL中的行锁和表锁"><a href="#三-MySQL中的行锁和表锁" class="headerlink" title="三. MySQL中的行锁和表锁"></a>三. MySQL中的行锁和表锁</h3><p>对于 <code>MyISAM </code>、 <code>MEMORY </code>、 <code>MERGE </code>这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使用这些存储引擎的锁一般都是针对当前会话来说的。</p>
<h4 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h4><h5 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h5><ul>
<li><p>表级别的 <code>S锁 </code>、 <code>X锁</code></p>
<p>在对某个表执行 <code>SELECT </code>、 <code>INSERT </code>、 <code>DELETE </code>、 <code>UPDATE </code>语句时， <code>InnoDB </code>存储引擎是不会为这个表添加表级别的 <code>S锁 </code>或者 <code>X锁 </code>的。</p>
<p>另外，在对某个表执行一些诸如 <code>ALTER TABLE </code>、 <code>DROP TABLE </code>这类的 <code>DDL </code>语句时，其他事务对这个表并发执行诸如 <code>SELECT </code>、 <code>INSERT </code>、 <code>DELETE </code>、 <code>UPDATE </code>的语句会发生阻塞，同理，某个事务中对某个表执行 <code>SELECT </code>、 <code>INSERT </code>、 <code>DELETE </code>、 <code>UPDATE </code>语句时，在其他会话中对这个表执行 <code>DDL </code>语句也会发生阻塞。这个过程其实是通过在 <code>server层 </code>使用一种称之为 <code>元数据锁 </code>（英文名： <code>Metadata Locks </code>，简称 <code>MDL </code>）东东来实现的，一般情况下也不会使用 <code>InnoDB </code>存储引擎自己提供的表级别的 <code>S锁 </code>和 <code>X锁 </code>。</p>
</li>
<li><p>表级别的 <code>IS锁 </code>、 <code>IX锁</code></p>
</li>
<li><p>表级别的 <code>AUTO-INC锁</code></p>
<p>在使用 <code>MySQL </code>过程中，我们可以为表的某个列添加 <code>AUTO_INCREMENT </code>属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值，这个赋值便需要保证唯一性，因此需要加锁。</p>
<ul>
<li><p>采用 <code>AUTO-INC </code>锁，也就是在执行插入语句时就在表级别加一个 <code>AUTO-INC </code>锁，然后为每条待插入记录的 <code>AUTO_INCREMENT </code>修饰的列分配递增的值，在该语句执行结束后，再把 <code>AUTO-INC </code>锁释放掉。这样一个事务在持有 <code>AUTO-INC </code>锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。</p>
<p>AUTO-INC锁的作用范围只是单个插入语句，插入语句执行完成后，这个锁就被释放了。</p>
</li>
<li><p>采用一个轻量级的锁，在为插入语句生成 <code>AUTO_INCREMENT </code>修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的 <code>AUTO_INCREMENT </code>列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。</p>
</li>
</ul>
<p>一般情况下，若插入记录的数量是确定的，采用轻量级锁，否则采用<code>AUTO_INC</code>锁。</p>
</li>
</ul>
<h5 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h5><ul>
<li><p><code>Record Locks </code>（ <code>LOCK_REC_NOT_GAP </code>）：</p>
<p>即<code>记录锁</code>，对记录加锁。</p>
</li>
<li><p><code>Gap Locks </code>（ <code>LOCK_GAP </code>）：</p>
<p><img src="/./MySQL/NeatReader-1683875874170.png"></p>
<p> <code>gap锁 </code>的提出 仅仅是为了防止插入幻影记录而提出的，不会影响其它记录对该记录再加<code>记录锁</code>和<code>gap锁</code>。</p>
</li>
<li><p><code>Next-Key Locks </code>（ <code>LOCK_ORDINARY </code>）：</p>
<p><code>next-key锁 </code>的本质就是一个 <code>正经记录锁 </code>和一个 <code>gap锁 </code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的 <code>间隙 </code>。</p>
</li>
<li><p><code>Insert Intention Locks </code>（ <code>LOCK_INSERT_INTENTION</code>）：</p>
<p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的 <code>gap锁 </code>（ <code>next-key锁 </code>也包含 <code>gap锁 </code>，后边就不强调了），如果有的话，插入操作需要等待，直到拥有 <code>gap锁 </code>的那个事务提交。但是设计 <code>InnoDB </code>的大叔规定事务在等待的时候也需要在内存中生成一个 <code>锁结构 </code>，表明有事务想在某个 <code>间隙 </code>中插入新记录，但是现在在等待。插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p>
</li>
<li><p>隐式锁</p>
<p>如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务想要读取或修改该记录，则会产生<code>脏读</code>和<code>脏写</code>。</p>
<ul>
<li>对于聚簇索引记录来说，有一个 <code>trx_id </code>隐藏列，该隐藏列记录着最后改动该记录的 <code>事务id </code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 <code>trx_id </code>隐藏列代表的的就是当前事务的 <code>事务id </code>，如果其他事务此时想对该记录添加 <code>S锁 </code>或者 <code>X锁 </code>时，首先会看一下该记录的 <code>trx_id </code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 <code>X锁 </code>（也就是为当前事务创建一个锁结构， <code>is_waiting </code>属性是 <code>false </code>），然后自己进入等待状态（也就是为自己也创建一个锁结构， <code>is_waiting </code>属性是 <code>true </code>）。</li>
<li>情景二：对于二级索引记录来说，本身并没有 <code>trx_id </code>隐藏列，但是在二级索引页面的 <code>Page Header </code>部分有一个 <code>PAGE_MAX_TRX_ID </code>属性，该属性代表对该页面做改动的最大的 <code>事务id </code>，如果 <code>PAGE_MAX_TRX_ID </code>属性值小于当前最小的活跃 <code>事务id </code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复 <code>情景一 </code>的做法。</li>
</ul>
<p>即其它事务会帮当前事务生成锁。</p>
</li>
</ul>
<h5 id="InnoDB锁的内存结构"><a href="#InnoDB锁的内存结构" class="headerlink" title="InnoDB锁的内存结构"></a>InnoDB锁的内存结构</h5><p><code>锁结构</code>：</p>
<p><img src="/./MySQL/NeatReader-1683876528198.png"></p>
<ul>
<li><p><code>锁所在的事务信息 </code>：</p>
<p>不论是 <code>表锁 </code>还是 <code>行锁 </code>，都是在事务执行过程中生成的，哪个事务生成了这个 <code>锁结构 </code>，这里就记载着这个事务的信息。</p>
<p>本质上是一个指向内存当中事务信息的指针。</p>
</li>
<li><p><code>索引信息 </code>：</p>
<p>对于 <code>行锁 </code>来说，需要记录一下加锁的记录是属于哪个索引的。本质也为指针。</p>
</li>
<li><p><code>表锁／行锁信息 </code>：</p>
<p><code>表锁结构 </code>和 <code>行锁结构 </code>在这个位置的内容是不同的：</p>
<ul>
<li><p>表锁：</p>
<p>记载着这是对哪个表加的锁，还有其他的一些信息。</p>
</li>
<li><p>行锁：</p>
<p>记载了三个重要的信息：</p>
<ul>
<li><p><code>Space ID </code>：记录所在表空间。</p>
</li>
<li><p><code>Page Number </code>：记录所在页号。</p>
</li>
<li><p><code>n_bits </code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个 <code>n_bits </code>属性代表使用了多少比特位。</p>
<p>一般比记录总数大，为了防止以后再添加记录时重新分配锁结构。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>type_mode </code>：</p>
<p>这是一个32位的数，被分成了 <code>lock_mode </code>、 <code>lock_type </code>和 <code>rec_lock_type </code>三个部分，如图所示：</p>
<p><img src="/./MySQL/NeatReader-1683876679389.png"></p>
<ul>
<li>锁的模式（ <code>lock_mode </code>），占用低4位，可选的值如下：<ul>
<li><code>LOCK_IS </code>（十进制的 <code>0 </code>）：表示共享意向锁，也就是 <code>IS锁 </code>。</li>
<li><code>LOCK_IX </code>（十进制的 <code>1 </code>）：表示独占意向锁，也就是 <code>IX锁 </code>。</li>
<li><code>LOCK_S </code>（十进制的 <code>2 </code>）：表示共享锁，也就是 <code>S锁 </code>。</li>
<li><code>LOCK_X </code>（十进制的 <code>3 </code>）：表示独占锁，也就是 <code>X锁 </code>。</li>
<li><code>LOCK_AUTO_INC </code>（十进制的 <code>4 </code>）：表示 <code>AUTO-INC锁 </code>。</li>
</ul>
</li>
<li>锁的类型（ <code>lock_type </code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul>
<li><code>LOCK_TABLE </code>（十进制的 <code>16 </code>），也就是当第5个比特位置为1时，表示表级锁。</li>
<li><code>LOCK_REC </code>（十进制的 <code>32 </code>），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li>行锁的具体类型（ <code>rec_lock_type </code>），使用其余的位来表示。只有在 <code>lock_type </code>的值为 <code>LOCK_REC </code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul>
<li><code>LOCK_ORDINARY </code>（十进制的 <code>0 </code>）：表示 <code>next-key锁 </code>。</li>
<li><code>LOCK_GAP </code>（十进制的 <code>512 </code>）：也就是当第10个比特位置为1时，表示 <code>gap锁 </code>。</li>
<li><code>LOCK_REC_NOT_GAP </code>（十进制的 <code>1024 </code>）：也就是当第11个比特位置为1时，表示 <code>正经记录锁 </code>。</li>
<li><code>LOCK_INSERT_INTENTION </code>（十进制的 <code>2048 </code>）：也就是当第12个比特位置为1时，表示插入意向锁。</li>
<li>其他的类型：还有一些不常用的类型我们就不多说了。</li>
<li><code>LOCK_WAIT </code>（十进制的 <code>256 </code>） ：也就是当第9个比特位置为 <code>1 </code>时，表示 <code>is_waiting </code>为 <code>true </code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 <code>0 </code>时，表示 <code>is_waiting </code>为 <code>false </code>，也就是当前事务获取锁成功。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>一堆比特位 </code>：</p>
<p>一个比特位映射一个 <code>heap_no </code>即一条记录，映射方式：</p>
<p><img src="/./MySQL/NeatReader-1683876786329.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL原理</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-顺序表及其应用"><a href="#1-顺序表及其应用" class="headerlink" title="1. 顺序表及其应用"></a>1. 顺序表及其应用</h2><h3 id="1-1-二进制求和"><a href="#1-1-二进制求和" class="headerlink" title="1.1 二进制求和"></a>1.1 二进制求和</h3><p>给你两个二进制字符串 <code>a</code> 和 <code>b</code> ，以二进制字符串的形式返回它们的和。 </p>
<p><strong>思路</strong></p>
<p>进行二进制位运算，本位和<code>s=a^b^c</code>，进位<code>c=(a&amp;b)|(a&amp;c)|(b&amp;c)</code>。</p>
<p>注意处理边界问题。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        StringBuilder cnt=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">// 构建目标字符串</span></span><br><span class="line">        <span class="type">int</span> n=a.length()-<span class="number">1</span>,m=b.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">0</span>||m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> n1=n&gt;=<span class="number">0</span>?a.charAt(n--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;<span class="comment">// 判断越界</span></span><br><span class="line">            <span class="type">int</span> n2=m&gt;=<span class="number">0</span>?b.charAt(m--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;<span class="comment">// 判断越界</span></span><br><span class="line">            s=n1^n2^c;<span class="comment">// 本位和</span></span><br><span class="line">            cnt.append(s);</span><br><span class="line">            c=(n1&amp;n2)|(n1&amp;c)|(n2&amp;c);<span class="comment">// 进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="number">0</span>) cnt.append(c);</span><br><span class="line">        <span class="keyword">return</span> cnt.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-移除元素"><a href="#1-2-移除元素" class="headerlink" title="1.2 移除元素"></a>1.2 移除元素</h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <strong>O(1)</strong> 额外空间并 <strong>原地</strong> 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>思路</strong></p>
<p>双指针法，左指针指向开头，右指针指向末尾，从头遍历，若元素值等于<code>val</code>，则将其替换为右端第一个不为<code>val</code>的元素。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)&#123;</span><br><span class="line">                <span class="comment">// 右边第一个不等于val的元素</span></span><br><span class="line">                <span class="keyword">while</span>(right&gt;left&amp;&amp;nums[right]==val)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[left]=nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;<span class="comment">// 依次遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-有顺序表及其应用"><a href="#2-有顺序表及其应用" class="headerlink" title="2. 有顺序表及其应用"></a>2. 有顺序表及其应用</h2><h3 id="2-1-删除有序数组中的重复项"><a href="#2-1-删除有序数组中的重复项" class="headerlink" title="2.1 删除有序数组中的重复项"></a>2.1 删除有序数组中的重复项</h3><p>给你一个 升序排列 的数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组<code>nums</code>的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前<code>k</code>个元素应该保存最终结果。</p>
<p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回<code>k</code>。</p>
<p>不要使用额外的空间，你必须在 <strong>原地</strong> 修改输入数组 并在使用 <strong>O(1)</strong> 额外空间的条件下完成。</p>
<p><strong>思路</strong></p>
<p>双指针法，<code>left</code>指向第一个不重复元素，依次遍历数组，将第一个不等于<code>nums[left]</code>的元素赋给<code>nums[left+1]</code>，<code>left</code>指针加一，再重复上述操作。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// i相当于右指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 寻找第一个不重复元素</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;n&amp;&amp;nums[left]==nums[i])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断i是否越界，若越界说明最后一个元素也等于nums[left]，不做处理</span></span><br><span class="line">            <span class="comment">// 若未越界，则赋值</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;n) nums[++left]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-删除有序数组中的重复项-II"><a href="#2-2-删除有序数组中的重复项-II" class="headerlink" title="2.2 删除有序数组中的重复项 II"></a>2.2 删除有序数组中的重复项 II</h3><p>给你一个有序数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>原地</strong> 修改输入数组 并在使用 <strong>O(1)</strong> 额外空间的条件下完成。</p>
<p><strong>思路</strong></p>
<p>双指针法，设置<code>flag</code>标志位判断当前元素是否可以加入数组，后续解法同题解一。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">1</span>,fast=<span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">true</span>;<span class="comment">// 初始化为true，表示该元素可以重复</span></span><br><span class="line">        <span class="keyword">while</span>(fast&lt;n)&#123;</span><br><span class="line">            <span class="comment">// 若flag==true，且nums[fast]==nums[fast-1]</span></span><br><span class="line">            <span class="comment">// 说明当前元素已经出现过，并且为重复的第二个元素，可以保留</span></span><br><span class="line">            <span class="comment">// 若flag==false，且nums[fast]==nums[fast-1]</span></span><br><span class="line">            <span class="comment">// 说明当前元素已经出现过，并且超过两次，去除</span></span><br><span class="line">            <span class="keyword">if</span>(flag&amp;&amp;nums[fast]==nums[fast-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                flag=<span class="literal">false</span>;<span class="comment">// flag=false表示不再允许该重复元素出现在数组中</span></span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前元素不等于已经出现的元素，显然可以将其加入数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=nums[fast-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>附录</strong></p>
<p>LeetCode 官方题解，思路连贯且清晰，且两道题关联紧密，代码模板相似。</p>
<p><strong>删除有序数组中的重复项</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除有序数组中的重复项 II</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">2</span>, fast = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-合并两个有序数组"><a href="#2-3-合并两个有序数组" class="headerlink" title="2.3 合并两个有序数组"></a>2.3 合并两个有序数组</h3><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和<code> n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p><strong>注意</strong>：最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n </code>。</p>
<p><strong>方法一. 排序</strong></p>
<p><strong>思路</strong></p>
<p>直观思路，将<code>nums2</code>直接插入<code>nums1</code>数组后排序。</p>
<p>这种方法时间复杂度较高，且未利用两者非递减顺序的特性。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;m+n;i++)&#123;</span><br><span class="line">            nums1[i]=nums2[i-m];<span class="comment">// nums2插入nums1后端</span></span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二. 双指针</strong></p>
<p><strong>思路</strong></p>
<p>从数组末端开始，依次加入最大数，这样能保证<code>nums1</code>中的数不被覆盖，相较同向双指针，逆向双指针的空间复杂度为 **O(1)**。</p>
<p>具体证明可参见LeetCode题解</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> p1=m-<span class="number">1</span>,p2=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cur=m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&gt;=<span class="number">0</span>||p2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1&lt;<span class="number">0</span>)&#123;		<span class="comment">// 判断nums1是否遍历完</span></span><br><span class="line">                ans=nums2[p2--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2&lt;<span class="number">0</span>)&#123;	<span class="comment">// 判断nums2是否遍历完</span></span><br><span class="line">                ans=nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1]&gt;nums2[p2])&#123; <span class="comment">// 比较元素大小</span></span><br><span class="line">                ans=nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans=nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[cur--]=ans;<span class="comment">// cur指针指向当前位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-寻找两个正序数组的中位数"><a href="#2-4-寻找两个正序数组的中位数" class="headerlink" title="2.4 寻找两个正序数组的中位数"></a>2.4 寻找两个正序数组的中位数</h3><p>给定两个大小分别为 <code>m </code>和<code> n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <strong>O(log (m+n))</strong> 。</p>
<p><strong>思路</strong></p>
<p>合并数组后寻找中位数，这种方法的时间复杂度为**O(m+n)**，虽能通过，但不满足题目要求。</p>
<p>同向双指针合并数组，与题解三类似。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums1.length,m=nums2.length;</span><br><span class="line">        <span class="type">int</span>[] ans=<span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">        <span class="type">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;n||p2&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1==n)&#123;</span><br><span class="line">                val=nums2[p2++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2==m)&#123;</span><br><span class="line">                val=nums1[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1]&lt;nums2[p2])&#123;</span><br><span class="line">                val=nums1[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                val=nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[cur++]=val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp=(m+n)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 判断奇偶</span></span><br><span class="line">        <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(ans[tmp]+ans[tmp-<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>附录</strong></p>
<p>LeetCode高分题解</p>
<p>link: <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">寻找两个正序数组的中位数</a></p>
<p><strong>二分查找</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> start1, <span class="type">int</span> end1, <span class="type">int</span>[] nums2, <span class="type">int</span> start2, <span class="type">int</span> end2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>划分数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> B.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; </span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(B,A); <span class="comment">// 保证 m &lt;= n</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">iMin</span> <span class="operator">=</span> <span class="number">0</span>, iMax = m;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; i != m &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i])&#123; <span class="comment">// i 需要增大</span></span><br><span class="line">                iMin = i + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != n &amp;&amp; A[i-<span class="number">1</span>] &gt; B[j]) &#123; <span class="comment">// i 需要减小</span></span><br><span class="line">                iMax = i - <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 达到要求，并且将边界条件列出来单独考虑</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">maxLeft</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; maxLeft = B[j-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; maxLeft = A[i-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]); &#125;</span><br><span class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span> == <span class="number">1</span> ) &#123; <span class="keyword">return</span> maxLeft; &#125; <span class="comment">// 奇数的话不需要考虑右半部分</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">minRight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>; <span class="comment">//如果是偶数的话返回结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-链表的实现"><a href="#3-链表的实现" class="headerlink" title="3. 链表的实现"></a>3. 链表的实现</h2><h3 id="3-1-设计链表"><a href="#3-1-设计链表" class="headerlink" title="3.1 设计链表"></a>3.1 设计链表</h3><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <code>0 </code>开始。</p>
<p><strong>思路</strong></p>
<p>设计单向链表或双向链表，模拟实现。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val)&#123;<span class="built_in">this</span>.val=val;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val,ListNode next)&#123;<span class="built_in">this</span>.val=val;<span class="built_in">this</span>.next=next;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);<span class="comment">// 初始化头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        ListNode p=head.next;</span><br><span class="line">        <span class="comment">// 从头依次遍历</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>&amp;&amp;index!=<span class="number">0</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        ListNode p=<span class="keyword">new</span> <span class="title class_">ListNode</span>(val,head.next);</span><br><span class="line">        head.next=p;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        <span class="comment">// 未使用双向链表，从头结点遍历寻找尾结点</span></span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=<span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        <span class="comment">// 寻找插入位置</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>&amp;&amp;index!=<span class="number">0</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=<span class="keyword">new</span> <span class="title class_">ListNode</span>(val,p.next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        <span class="comment">// 寻找删除位置</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>&amp;&amp;index!=<span class="number">0</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">null</span>&amp;&amp;p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.next=p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-链表随机节点"><a href="#3-2-链表随机节点" class="headerlink" title="3.2 链表随机节点"></a>3.2 链表随机节点</h3><p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 <strong>被选中的概率一样</strong> 。</p>
<p>实现 <code>Solution</code> 类：</p>
<ul>
<li><code>Solution(ListNode head)</code> 使用整数数组初始化对象。</li>
<li><code>int getRandom()</code> 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。</li>
</ul>
<p><strong>思路</strong></p>
<p>最初想法是开一个数组存储链表中所有数据，但是由于链表长度未知，空间复杂度较高。</p>
<p>采用水塘抽样算法。</p>
<p>知乎：<a href="https://zhuanlan.zhihu.com/p/107793995">随机算法：水塘抽样算法</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode root;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        root=head;</span><br><span class="line">        random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> idx=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode p=root;p!=<span class="literal">null</span>;p=p.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(random.nextInt(idx++)==<span class="number">0</span>)&#123;</span><br><span class="line">                ans=p.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(head);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-单链表及其应用"><a href="#4-单链表及其应用" class="headerlink" title="4. 单链表及其应用"></a>4. 单链表及其应用</h2><h3 id="4-1-移除链表元素"><a href="#4-1-移除链表元素" class="headerlink" title="4.1 移除链表元素"></a>4.1 移除链表元素</h3><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>思路</strong></p>
<p>模拟，依次判断当前节点的下一节点值是否等于目标值。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode root=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);<span class="comment">// 新建root节点指向头节点，可以避免头节点被删除的临界问题</span></span><br><span class="line">        ListNode p=root;</span><br><span class="line">        <span class="comment">// 模拟依次删除</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>&amp;&amp;p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val==val)&#123;</span><br><span class="line">                <span class="keyword">while</span>(p.next!=<span class="literal">null</span>&amp;&amp;p.next.val==val)&#123;</span><br><span class="line">                    p.next=p.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-删除链表中的节点"><a href="#4-3-删除链表中的节点" class="headerlink" title="4.3 删除链表中的节点"></a>4.3 删除链表中的节点</h3><p>有一个单链表的 <code>head</code>，我们想删除它其中的一个节点 <code>node</code>。</p>
<p>给你一个需要删除的节点 <code>node</code> 。你将 <strong>无法访问</strong> 第一个节点 <code>head</code>。</p>
<p>链表的所有值都是 <strong>唯一的</strong>，并且保证给定的节点 <code>node</code> 不是链表中的最后一个节点。</p>
<p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p>
<ul>
<li>给定节点的值不应该存在于链表中。</li>
<li>链表中的节点数应该减少 1。</li>
<li><code>node</code> 前面的所有值顺序相同。</li>
<li><code>node</code> 后面的所有值顺序相同。</li>
</ul>
<p><strong>思路</strong></p>
<p>由于不知道被删除节点的上一节点，因而无法在不影响后续节点的情况下将该节点删除。</p>
<p>将该节点下一节点的值赋给当前节点，再删除下一节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 将下一节点的值赋给当前节点</span></span><br><span class="line">        node.val=node.next.val;</span><br><span class="line">        <span class="comment">// 删除下一节点，即指向下一节点的后继节点</span></span><br><span class="line">        node.next=node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-反转链表"><a href="#4-3-反转链表" class="headerlink" title="4.3 反转链表"></a>4.3 反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>思路</strong></p>
<p>递归求解，假设当前节点为<code>p</code>，它后面的部分已全部被反转，现在要反转<code>p</code>，即它要与它的直接后继节点调换位置，反转后<code>p</code>为已经反转部分的尾节点，因此它的下一节点为<code>null</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否到达链表末尾</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前已经反转部分的根节点</span></span><br><span class="line">        ListNode root=reverse(head.next);</span><br><span class="line">        head.next.next=head;<span class="comment">// 反转当前节点与后继节点</span></span><br><span class="line">        head.next=<span class="literal">null</span>;<span class="comment">// 反转后当前节点即为已经反转部分的尾节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代解法</strong></p>
<p>迭代方法需要使用两个临时节点，一个指向父节点，一个指向当前节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="comment">// 初始化，头结点的父节点为null</span></span><br><span class="line">       ListNode pre=<span class="literal">null</span>;</span><br><span class="line">       ListNode cur=head;</span><br><span class="line">       <span class="comment">//pre随着cur的遍历，最终指向尾节点</span></span><br><span class="line">       <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">           ListNode next=cur.next;<span class="comment">// 临时存储当前节点的下一节点</span></span><br><span class="line">           cur.next=pre;<span class="comment">// 反转节点</span></span><br><span class="line">           pre=cur;<span class="comment">// 相对next节点而言，pre节点即为cur</span></span><br><span class="line">           cur=next;<span class="comment">// cur指向下一节点</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-反转链表-II"><a href="#4-4-反转链表-II" class="headerlink" title="4.4 反转链表 II"></a>4.4 反转链表 II</h3><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p>
<p><strong>思路</strong></p>
<p>先遍历链表至<code>left</code>处，随后对<code>left</code>到<code>right</code>区间进行反转，反转步骤类似题解三的迭代解法，在此过程中需记录<code>left</code>的父节点与<code>right</code>的子节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建root节点，防止head节点被反转的临界问题</span></span><br><span class="line">        ListNode root=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode cur=root;</span><br><span class="line">        ListNode prev=cur;</span><br><span class="line">        <span class="comment">// 找到left节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;left;i++)&#123;</span><br><span class="line">            prev=cur;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre=<span class="literal">null</span>;</span><br><span class="line">        ListNode curr=cur;</span><br><span class="line">        <span class="comment">// 反转链表区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            ListNode next=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将反转链表的区间插入到原链表中</span></span><br><span class="line">        prev.next=pre;</span><br><span class="line">        curr.next=cur;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-5-奇偶链表"><a href="#4-5-奇偶链表" class="headerlink" title="4.5 奇偶链表"></a>4.5 奇偶链表</h3><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p>
<p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推。</p>
<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>
<p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题。</p>
<p><strong>思路</strong></p>
<p>奇偶链表分开处理，最后再合并。</p>
<p>可以发现，奇节点的下一节点即为偶节点的下一节点，故此我们可以进行奇偶交替模拟，最后合并。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// head为空则直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode odd=head;<span class="comment">// 第一个奇节点即为头节点</span></span><br><span class="line">        ListNode even=head.next;<span class="comment">// 第一个偶节点即为头节点的子节点</span></span><br><span class="line">        ListNode tmp=even;<span class="comment">// 临时存储偶数头节点</span></span><br><span class="line">        <span class="keyword">while</span>(even!=<span class="literal">null</span>&amp;&amp;even.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 奇节点的下一节点即为偶节点的下一节点</span></span><br><span class="line">            odd.next=even.next;</span><br><span class="line">            <span class="comment">// 指向下一奇节点</span></span><br><span class="line">            odd=odd.next;</span><br><span class="line">            <span class="comment">// 此时奇节点已为偶节点的下一节点，</span></span><br><span class="line">            <span class="comment">// 那么偶节点的下一节点即为该奇节点的下一节点</span></span><br><span class="line">            even.next=odd.next;</span><br><span class="line">            <span class="comment">// 指向下一偶节点</span></span><br><span class="line">            even=even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并奇偶链表</span></span><br><span class="line">        odd.next=tmp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-6-分隔链表"><a href="#4-6-分隔链表" class="headerlink" title="4.6 分隔链表"></a>4.6 分隔链表</h3><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>
<p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p>
<p><strong>思路</strong></p>
<p>按照题意进行模拟，维护两个链表节点<code>small</code>和<code>large</code>，分别记录比<code>x</code>小和大于等于<code>x</code>的链表节点，最后将两个链表合并即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 链表为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode small=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode large=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode p=small,q=large;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">           	<span class="comment">// 判断当前节点值与x的大小</span></span><br><span class="line">            <span class="keyword">if</span>(head.val&lt;x)&#123;</span><br><span class="line">                p.next=head;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                q.next=head;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// large链表尾节点为null</span></span><br><span class="line">        q.next=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// small链表尾节点指向large头节点</span></span><br><span class="line">        p.next=large.next;</span><br><span class="line">        <span class="comment">// 返回合并后的链表</span></span><br><span class="line">        <span class="keyword">return</span> small.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-7-两两交换链表中的节点"><a href="#4-7-两两交换链表中的节点" class="headerlink" title="4.7 两两交换链表中的节点"></a>4.7 两两交换链表中的节点</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>思路</strong></p>
<p>递归求解，两两交换即当前节点的下一节点为新的头节点，而当前节点的下一节点为交换后链表的新节点，递归模拟。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 链表为空或节点数为1，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode root=head.next;<span class="comment">// 新头节点</span></span><br><span class="line">        head.next=swapPairs(root.next);<span class="comment">// 递归交换</span></span><br><span class="line">        root.next=head;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-8-链表的中间结点"><a href="#4-8-链表的中间结点" class="headerlink" title="4.8 链表的中间结点"></a>4.8 链表的中间结点</h3><p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p><strong>思路</strong></p>
<p>典型快慢指针题，使用<code>slow</code>和<code>fast</code>指针，初始时<code>slow</code>和<code>fast</code>都指向头结点，而后，慢指针每次前进一步，快指针每次前进两步，那么快指针到达链表末尾时，慢指针便指向了中间结点。</p>
<p>注意：链表结点数为偶数时，返回第二个中间结点，这会影响对快指针到达链表末尾的判定。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 链表为空或个数为一，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="comment">// 临界条件：fast指针不为空且fast指针指向的下一结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-9-回文链表"><a href="#4-9-回文链表" class="headerlink" title="4.9 回文链表"></a>4.9 回文链表</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>思路</strong></p>
<p>直观思路：遍历链表，并将节点值存储在字符串或数组中，然后进行判断。</p>
<p>进阶：进阶要求<code>O(n)</code>时间复杂度和<code>O(1)</code>空间复杂度，可以先使用快慢指针找到中间节点，然后用迭代方法反转后半部分链表，最后进行比较。</p>
<p>（由于题目数据量不大，两种方法占用空间实际相差不大）</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder cnt=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">            cnt.append(head.val);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n=cnt.length();</span><br><span class="line">        <span class="comment">// 判断比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.charAt(i)!=cnt.charAt(n-i-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-10-重排链表"><a href="#4-10-重排链表" class="headerlink" title="4.10 重排链表"></a>4.10 重排链表</h3><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure>

<p>请将其重新排列后变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure>

<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>思路</strong></p>
<p>遍历并存储链表节点，然后进行统一处理。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        List&lt;ListNode&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">            cnt.add(head);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=cnt.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">// 左节点的下一节点为right</span></span><br><span class="line">            cnt.get(left).next=cnt.get(right);</span><br><span class="line">            <span class="comment">// 左节点右移</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右节点的下一节点为left</span></span><br><span class="line">            cnt.get(right).next=cnt.get(left);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前左节点为链表尾节点</span></span><br><span class="line">        cnt.get(left).next=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-11-对链表进行插入排序"><a href="#4-11-对链表进行插入排序" class="headerlink" title="4.11 对链表进行插入排序"></a>4.11 对链表进行插入排序</h3><p>给定单个链表的头 <code>head</code> ，使用 <strong>插入排序</strong> 对链表进行排序，并返回 <em>排序后链表的头</em> 。</p>
<p><strong>插入排序</strong> 算法的步骤:</p>
<ol>
<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>
<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>
<li>重复直到所有输入数据插入完为止。</li>
</ol>
<p><strong>思路</strong></p>
<p>维护两个指针，一个指向当前待排序链表节点，一个指向已排序好后的尾节点。</p>
<p>若当前节点值小于当前尾节点，从已排序链表头节点开始，查找插入位置并将其插入。</p>
<p>若当前节点值大于等于当前尾节点，那么将当前节点插入末尾，再将当前尾节点后移一位即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertionSortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 哑节点</span></span><br><span class="line">        ListNode root=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode tail=head,cur=head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// cur节点值大于等于tail节点值，说明已经排好序的链表节点值都比cur小</span></span><br><span class="line">            <span class="comment">// tail直接后移一位，令cur成为tail节点</span></span><br><span class="line">            <span class="keyword">if</span>(tail.val&lt;=cur.val)&#123;</span><br><span class="line">                tail=cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode prev=root;</span><br><span class="line">                <span class="comment">// 查找插入位置</span></span><br><span class="line">                <span class="keyword">while</span>(prev.next.val&lt;=cur.val)&#123;</span><br><span class="line">                    prev=prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前位置处理完后，tail指针后移</span></span><br><span class="line">                <span class="comment">// 即个数加一</span></span><br><span class="line">                tail.next=cur.next;</span><br><span class="line">                <span class="comment">// 插入节点</span></span><br><span class="line">                cur.next=prev.next;</span><br><span class="line">                prev.next=cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cur节点指向尚未被排序的第一个节点</span></span><br><span class="line">            <span class="comment">// 即tail后的第一个节点</span></span><br><span class="line">            cur=tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-12-K-个一组翻转链表"><a href="#4-12-K-个一组翻转链表" class="headerlink" title="4.12 K 个一组翻转链表"></a>4.12 K 个一组翻转链表</h3><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><strong>思路</strong></p>
<p>模拟翻转，首先寻找到第 k 个节点，然后将该部分翻转，以此类推。</p>
<p>翻转链表可参考前面题解<strong>“反转链表”</strong>。</p>
<p>注意：翻转前需要存储前一节点与后一节点，以便将翻转后的链表接回原链表。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ListNode root=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode pre=root;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ListNode tail=pre;</span><br><span class="line">            <span class="comment">// 寻找第k个节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                tail=tail.next;</span><br><span class="line">                <span class="keyword">if</span>(tail==<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> root.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转链表</span></span><br><span class="line">            ListNode[] tmp=reverse(head,tail);</span><br><span class="line">            head=tmp[<span class="number">0</span>];</span><br><span class="line">            tail=tmp[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 接回原链表</span></span><br><span class="line">            pre.next=head;</span><br><span class="line">            <span class="comment">// 以此类推</span></span><br><span class="line">            pre=tail;</span><br><span class="line">            head=tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] reverse(ListNode head,ListNode tail)&#123;</span><br><span class="line">        ListNode pre=tail.next;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(pre!=tail)&#123;</span><br><span class="line">            ListNode next=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>[]&#123;tail,head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-13-分隔链表"><a href="#4-13-分隔链表" class="headerlink" title="4.13 分隔链表"></a>4.13 分隔链表</h3><p>给你一个头结点为 <code>head</code> 的单链表和一个整数 <code>k</code> ，请你设计一个算法将链表分隔为 <code>k</code> 个连续的部分。</p>
<p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p>
<p>这 <code>k</code> 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p>
<p>返回一个由上述 <code>k</code> 部分组成的数组。</p>
<p><strong>思路</strong></p>
<p>按照题意进行模拟即可。</p>
<p>注意：若节点总数不是k的倍数，那么就在前面几个部分多加一个节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode head, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        <span class="comment">// 统计节点个数</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每组基础个数以及多出来的个数</span></span><br><span class="line">        <span class="type">int</span> size=len/k,carry=len%k;</span><br><span class="line">        ListNode[] ans=<span class="keyword">new</span> <span class="title class_">ListNode</span>[k];</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k&amp;&amp;cur!=<span class="literal">null</span>;i++)&#123;</span><br><span class="line">            ans[i]=cur;</span><br><span class="line">            <span class="comment">// 根据是否有多出个数来判断当前部分大小</span></span><br><span class="line">            <span class="type">int</span> cur_s=size+(carry--&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;cur_s;j++)&#123;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分隔后当前尾节点的下一节点应置空</span></span><br><span class="line">            ListNode next=cur.next;</span><br><span class="line">            cur.next=<span class="literal">null</span>;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-有序链表及其应用"><a href="#5-有序链表及其应用" class="headerlink" title="5. 有序链表及其应用"></a>5. 有序链表及其应用</h2><h3 id="5-1-删除排序链表中的重复元素"><a href="#5-1-删除排序链表中的重复元素" class="headerlink" title="5.1 删除排序链表中的重复元素"></a>5.1 删除排序链表中的重复元素</h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>
<p><strong>思路</strong></p>
<p>维护两个指针<code>slow</code>和<code>fast</code>，慢指针指向无重复的链表，快指针指向原链表，依次比较<code>slow</code>和<code>fast</code>的值，决定其是否加入慢指针指向的链表中。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 若当前元素未在slow中出现过，则加入slow中</span></span><br><span class="line">            <span class="keyword">if</span>(fast.val!=slow.val)&#123;</span><br><span class="line">                slow.next=fast;</span><br><span class="line">                slow=slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// slow尾节点指向null</span></span><br><span class="line">        slow.next=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-删除排序链表中的重复元素-II"><a href="#5-2-删除排序链表中的重复元素-II" class="headerlink" title="5.2 删除排序链表中的重复元素 II"></a>5.2 删除排序链表中的重复元素 II</h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p>
<p><strong>思路</strong></p>
<p>该题是上一题的进阶，首先定义一个哑节点<code>root</code>，便于删除头节点，然后依次比较下一节点与下下一节点的值，若相等，则继续比较寻找第一个不等的节点，并将下一节点指向它；若不等，那么直接将当前节点后移即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode root=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode p=root;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="literal">null</span>&amp;&amp;p.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 比较下一节点与下下一节点的值</span></span><br><span class="line">            <span class="keyword">if</span>(p.next.val==p.next.next.val)&#123;</span><br><span class="line">                <span class="type">int</span> val=p.next.val;</span><br><span class="line">                <span class="comment">// 寻找第一个与val不等的节点</span></span><br><span class="line">                <span class="keyword">while</span>(p.next!=<span class="literal">null</span>&amp;&amp;p.next.val==val)&#123;</span><br><span class="line">                    p.next=p.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 当前指针后移一位</span></span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3-合并两个有序链表"><a href="#5-3-合并两个有序链表" class="headerlink" title="5.3 合并两个有序链表"></a>5.3 合并两个有序链表</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>思路</strong></p>
<p>由于两个链表均为升序排列，因此通过比较节点值大小按照题意进行模拟即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode root=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode p=root;</span><br><span class="line">        <span class="comment">// 模拟合并</span></span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">null</span>||list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">                p.next=list2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="literal">null</span>)&#123;</span><br><span class="line">                p.next=list1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">                    p.next=list1;</span><br><span class="line">                    list1=list1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    p.next=list2;</span><br><span class="line">                    list2=list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-4-合并K个升序链表"><a href="#5-4-合并K个升序链表" class="headerlink" title="5.4 合并K个升序链表"></a>5.4 合并K个升序链表</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>思路</strong></p>
<p>直观思路：参考“<strong>合并两个有序链表</strong>”，每次将合并后的链表与未合并的链表进行合并即可。</p>
<p>进阶：使用分治或优先队列方法解决。</p>
<p><strong>顺序合并</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=lists.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p=lists[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 依次合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            p=merge(p,lists[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode list1,ListNode list2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode root=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode p=root;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">null</span>||list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">                p.next=list2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="literal">null</span>)&#123;</span><br><span class="line">                p.next=list1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">                    p.next=list1;</span><br><span class="line">                    list1=list1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    p.next=list2;</span><br><span class="line">                    list2=list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分治合并</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// 分治合并</span></span><br><span class="line">        <span class="keyword">return</span> mergeList(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeList</span><span class="params">(ListNode[] lists,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">// 若left==right，返回当前链表</span></span><br><span class="line">        <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若left&gt;right，返回null</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取中间数，分治</span></span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(mergeList(lists,left,mid),mergeList(lists,mid+<span class="number">1</span>,right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode list1,ListNode list2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode root=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode p=root;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">null</span>||list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">                p.next=list2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="literal">null</span>)&#123;</span><br><span class="line">                p.next=list1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">                    p.next=list1;</span><br><span class="line">                    list1=list1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    p.next=list2;</span><br><span class="line">                    list2=list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树和二叉树</title>
    <url>/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="1-二叉树的先序、中序和后序遍历"><a href="#1-二叉树的先序、中序和后序遍历" class="headerlink" title="1. 二叉树的先序、中序和后序遍历"></a>1. 二叉树的先序、中序和后序遍历</h2><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        preorder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            preorder(root.left);</span><br><span class="line">            preorder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            inorder(root.left);</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            inorder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        postorder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            postorder(root.left);</span><br><span class="line">            postorder(root.right);</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-二叉树的层次遍历"><a href="#2-二叉树的层次遍历" class="headerlink" title="2. 二叉树的层次遍历"></a>2. 二叉树的层次遍历</h2><h3 id="2-1-二叉树的层序遍历"><a href="#2-1-二叉树的层序遍历" class="headerlink" title="2.1 二叉树的层序遍历"></a>2.1 二叉树的层序遍历</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p> <strong>思路</strong></p>
<p>广度优先搜索，使用队列保存当前已遍历节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; hep=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        hep.offer(root); </span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 记录当前队列中的结点个数</span></span><br><span class="line">            <span class="type">int</span> s=hep.size();</span><br><span class="line">            List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 遍历这s个结点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                TreeNode p=hep.poll();</span><br><span class="line">                tmp.add(p.val);</span><br><span class="line">                <span class="keyword">if</span>(p.left!=<span class="literal">null</span>) hep.offer(p.left);</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="literal">null</span>) hep.offer(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历一层完毕，加入目标数组中</span></span><br><span class="line">            cnt.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-二叉树的层序遍历-II"><a href="#2-2-二叉树的层序遍历-II" class="headerlink" title="2.2 二叉树的层序遍历 II"></a>2.2 二叉树的层序遍历 II</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。</p>
<p><strong>思路</strong></p>
<p>同题解一，之后再将其反转即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; hep=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        hep.offer(root);</span><br><span class="line">        <span class="comment">// 层序遍历</span></span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> s=hep.size();</span><br><span class="line">            List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                TreeNode p=hep.poll();</span><br><span class="line">                tmp.add(p.val);</span><br><span class="line">                <span class="keyword">if</span>(p.left!=<span class="literal">null</span>) hep.offer(p.left);</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="literal">null</span>) hep.offer(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转数组</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=cnt.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp=cnt.get(left);</span><br><span class="line">            cnt.set(left,cnt.get(right));</span><br><span class="line">            cnt.set(right,tmp);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-二叉树遍历算法的应用"><a href="#3-二叉树遍历算法的应用" class="headerlink" title="3. 二叉树遍历算法的应用"></a>3. 二叉树遍历算法的应用</h2><h3 id="3-1-叶子相似的树"><a href="#3-1-叶子相似的树" class="headerlink" title="3.1 叶子相似的树"></a>3.1 叶子相似的树</h3><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <strong>叶值序列</strong> 。</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="img"></p>
<p>举个例子，如上图所示，给定一棵叶值序列为 <code>(6, 7, 4, 9, 8)</code> 的树。</p>
<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 <em>叶相似</em> 的。</p>
<p>如果给定的两个根结点分别为 <code>root1</code> 和 <code>root2</code> 的树是叶相似的，则返回 <code>true</code>；否则返回 <code>false</code> 。</p>
<p> <strong>思路</strong></p>
<p>深度优先搜索，分别存储两棵树的叶子节点，然后比较。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; v1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; v2=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        dfs(root1,v1);</span><br><span class="line">        dfs(root2,v2);</span><br><span class="line">        <span class="comment">// 判断叶子是否相似</span></span><br><span class="line">        <span class="keyword">return</span> v1.equals(v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; v)</span>&#123;</span><br><span class="line">        <span class="comment">// root为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 判断是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            v.add(root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        dfs(root.left,v);</span><br><span class="line">        dfs(root.right,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-合并二叉树"><a href="#3-2-合并二叉树" class="headerlink" title="3.2 合并二叉树"></a>3.2 合并二叉树</h3><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索，依次处理两棵树的对应节点，若其中一棵树节点为<code>null</code>，直接返回另一棵树的节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root1,root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode root1,TreeNode root2)</span>&#123;</span><br><span class="line">        <span class="comment">// 两棵树节点均不为null</span></span><br><span class="line">        <span class="keyword">if</span>(root1!=<span class="literal">null</span>&amp;&amp;root2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root1.val=root1.val+root2.val;</span><br><span class="line">            <span class="comment">// 递归处理左右子树</span></span><br><span class="line">            root1.left=dfs(root1.left,root2.left);</span><br><span class="line">            root1.right=dfs(root1.right,root2.right);</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root1==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-二叉树的最近公共祖先"><a href="#3-3-二叉树的最近公共祖先" class="headerlink" title="3.3 二叉树的最近公共祖先"></a>3.3 二叉树的最近公共祖先</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>思路</strong></p>
<p>深度优先搜索。</p>
<p>首先判断当前根节点是否为 p 或 q 中的一个，若是则直接返回；</p>
<p>若不是，则递归遍历左右子树；</p>
<p>若左子树返回节点为 null ，则说明左子树中不包含 p 和 q ，返回右子树；</p>
<p>若右子树返回节点为 null ， 同左子树情况；</p>
<p>若左右子树返回节点均不为 null ， 说明左右子树中分别有 p 和 q ，则当前 root 节点即为最近公共祖先。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// root为null或p、q中任意一个，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 递归遍历左右子树</span></span><br><span class="line">        TreeNode left=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="comment">// 左子树为空，返回右子树</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="comment">// 右子树为空，返回左子树</span></span><br><span class="line">        <span class="keyword">if</span>(right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">// 左右子树均不为空，返回root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-二叉树展开为链表"><a href="#3-4-二叉树展开为链表" class="headerlink" title="3.4 二叉树展开为链表"></a>3.4 二叉树展开为链表</h3><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<p><strong>思路</strong></p>
<p>本质上就是将二叉树的左子树移到右子树上，若当前节点左子树不为空，那么将其最右方的节点的下一节点指向当前节点的右节点，这样就将左子树移到了右子树之前；若当前节点左子树为空，则直接继续处理下一个节点即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 左子树不为空</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                TreeNode next=cur.left;</span><br><span class="line">                TreeNode prev=next;</span><br><span class="line">                <span class="comment">// 寻找左子树最右边的节点</span></span><br><span class="line">                <span class="keyword">while</span>(prev.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    prev=prev.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 指向右子树头节点</span></span><br><span class="line">                prev.right=cur.right;</span><br><span class="line">                <span class="comment">// 展开为链表</span></span><br><span class="line">                cur.left=<span class="literal">null</span>;</span><br><span class="line">                cur.right=next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-二叉树的最大深度"><a href="#3-5-二叉树的最大深度" class="headerlink" title="3.5 二叉树的最大深度"></a>3.5 二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p><strong>思路</strong></p>
<p>递归求解左右子树的最大深度。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> high=Math.max(height(root.left),height(root.right))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求解左右子树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> heights=Math.max(height(root.left),height(root.right))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> heights;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-6-二叉树的最小深度"><a href="#3-6-二叉树的最小深度" class="headerlink" title="3.6 二叉树的最小深度"></a>3.6 二叉树的最小深度</h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>思路</strong></p>
<p>寻找左右子树的叶子节点，并记录深度，比较得出结果。</p>
<p>注意：与寻找最大深度相比，需要判断是否有叶子节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> depth=Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 递归求解最小深度</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth=Math.min(depth,minDepth(root.left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth=Math.min(depth,minDepth(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-7-二叉树的堂兄弟节点"><a href="#3-7-二叉树的堂兄弟节点" class="headerlink" title="3.7 二叉树的堂兄弟节点"></a>3.7 二叉树的堂兄弟节点</h3><p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p>
<p>如果二叉树的两个节点深度相同，但 <strong>父节点不同</strong> ，则它们是一对<em>堂兄弟节点</em>。</p>
<p>我们给出了具有唯一值的二叉树的根节点 <code>root</code> ，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code> 。</p>
<p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code> 。否则，返回 <code>false</code>。</p>
<p><strong>思路</strong></p>
<p>维护 parent 和 depth 信息，同时设置 flag 标志位标记是否找到目标节点。</p>
<p>最后比较二者的 parent 和 depth 信息。</p>
<p><strong>代码</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="comment">// 存储x节点信息</span></span><br><span class="line">    <span class="type">boolean</span> flagx=<span class="literal">false</span>;</span><br><span class="line">    TreeNode xpar;</span><br><span class="line">    <span class="type">int</span> xdepth;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">	<span class="comment">// 存储y节点信息</span></span><br><span class="line">    <span class="type">boolean</span> flagy=<span class="literal">false</span>;</span><br><span class="line">    TreeNode ypar;</span><br><span class="line">    <span class="type">int</span> ydepth;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x=x;</span><br><span class="line">        <span class="built_in">this</span>.y=y;</span><br><span class="line">        dfs(root,<span class="literal">null</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> xpar!=ypar&amp;&amp;xdepth==ydepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode cur,TreeNode parent,<span class="type">int</span> height)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否找到x或y中的节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur.val==x)&#123;</span><br><span class="line">            flagx=<span class="literal">true</span>;</span><br><span class="line">            xdepth=height;</span><br><span class="line">            xpar=parent;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val==y)&#123;</span><br><span class="line">            flagy=<span class="literal">true</span>;</span><br><span class="line">            ydepth=height;</span><br><span class="line">            ypar=parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两者都找到，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(flagx&amp;&amp;flagy)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        dfs(cur.left,cur,height+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 两者都找到，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(flagx&amp;&amp;flagy)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历右子树</span></span><br><span class="line">        dfs(cur.right,cur,height+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-8-在每个树行中找最大值"><a href="#3-8-在每个树行中找最大值" class="headerlink" title="3.8 在每个树行中找最大值"></a>3.8 在每个树行中找最大值</h3><p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p>
<p><strong>思路</strong></p>
<p>广度优先搜索，依次更新每行最大值。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; hep=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        hep.offer(root);</span><br><span class="line">        List&lt;Integer&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> s=hep.size();</span><br><span class="line">            <span class="type">int</span> ans=Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">// 遍历每一层</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                TreeNode p=hep.poll();</span><br><span class="line">                <span class="comment">// 更新最大值</span></span><br><span class="line">                ans=Math.max(ans,p.val);</span><br><span class="line">                <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    hep.offer(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    hep.offer(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入每层最大值</span></span><br><span class="line">            cnt.add(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-9-找树左下角的值"><a href="#3-9-找树左下角的值" class="headerlink" title="3.9 找树左下角的值"></a>3.9 找树左下角的值</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索，维护一个深度信息，每当找到一个深度大于记录当前深度的节点，修改记录的节点值，并更新当前深度。</p>
<p>由于是左子树先遍历，则到达最底层时，更新为最左边节点的值，然后更新深度，确保不会记录其右边的节点值。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="type">int</span> mindepth=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 更新深度及节点值</span></span><br><span class="line">            <span class="keyword">if</span>(depth&gt;mindepth)&#123;</span><br><span class="line">                mindepth=depth;</span><br><span class="line">                ans=root.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左右子树</span></span><br><span class="line">        dfs(root.left,depth+<span class="number">1</span>);</span><br><span class="line">        dfs(root.right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-10-对称二叉树"><a href="#3-10-对称二叉树" class="headerlink" title="3.10 对称二叉树"></a>3.10 对称二叉树</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>思路</strong></p>
<p>依次递归遍历左右子树，若两个节点不同时为空或者节点值不同，则不对称；反之，继续递归遍历。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="comment">// 同时为空，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span>&amp;&amp;q==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p!=<span class="literal">null</span>&amp;&amp;q!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 节点值不等，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(p.val!=q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 递归遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> dfs(p.left,q.right)&amp;&amp;dfs(p.right,q.left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-11-二叉树最大宽度"><a href="#3-11-二叉树最大宽度" class="headerlink" title="3.11 二叉树最大宽度"></a>3.11 二叉树最大宽度</h3><p>给你一棵二叉树的根节点 <code>root</code> ，返回树的 <strong>最大宽度</strong> 。</p>
<p>树的 <strong>最大宽度</strong> 是所有层中最大的 <strong>宽度</strong> 。</p>
<p>每一层的 <strong>宽度</strong> 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 <code>null</code> 节点，这些 <code>null</code> 节点也计入长度。</p>
<p>题目数据保证答案将会在 <strong>32 位</strong> 带符号整数范围内。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索，每次遍历到当前层的最左侧节点时，记录其编号，然后再递归遍历左右子树，之后再遍历到与当前深度相同的层时，只需将当前节点的编号与记录的最左侧节点的编号相减再加一即得到当前宽度，每次比较取最大值即可得到最大宽度。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; cnt=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> depth,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若cnt中还是空值，说明还没有最左侧节点</span></span><br><span class="line">        <span class="comment">// 将当前节点编号记录为最左侧节点</span></span><br><span class="line">        cnt.putIfAbsent(depth,index);</span><br><span class="line">        <span class="comment">// 递归遍历左右子树并求解最大宽度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(index-cnt.get(depth)+<span class="number">1</span>,Math.max(dfs(root.left,depth+<span class="number">1</span>,<span class="number">2</span>*index),dfs(root.right,depth+<span class="number">1</span>,<span class="number">2</span>*index+<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-12-路径总和"><a href="#3-12-路径总和" class="headerlink" title="3.12 路径总和"></a>3.12 路径总和</h3><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>思路</strong></p>
<p>深度优先搜索，递归遍历左右子树，<code>targetSum</code>依次减去当前节点值，当<code>targetSum==0</code>且当前节点为叶子节点时，即找到了目标和。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="comment">// 节点为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否为叶子节点且target==0</span></span><br><span class="line">        <span class="comment">// 若是则说明已经找到目标和，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>&amp;&amp;target-root.val==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> val=root.val;</span><br><span class="line">        <span class="comment">// 递归遍历左右子树</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,target-val)||dfs(root.right,target-val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-13-二叉树的所有路径"><a href="#3-13-二叉树的所有路径" class="headerlink" title="3.13 二叉树的所有路径"></a>3.13 二叉树的所有路径</h3><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>思路</strong></p>
<p>依次遍历到叶子节点，并保存遍历过程中的节点值，当到达叶子节点时，转换为路径并加入目标数组中。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            tmp.add(root.val);</span><br><span class="line">            <span class="comment">// 转换为路径</span></span><br><span class="line">            StringBuilder s=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tmp.size();i++)&#123;</span><br><span class="line">                s.append(tmp.get(i));</span><br><span class="line">                <span class="keyword">if</span>(i!=tmp.size()-<span class="number">1</span>) s.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.add(s.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入路径中</span></span><br><span class="line">        tmp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 遍历左子树</span></span><br><span class="line">            dfs(root.left);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 遍历右子树</span></span><br><span class="line">            dfs(root.right);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-14-路径总和-II"><a href="#3-14-路径总和-II" class="headerlink" title="3.14 路径总和 II"></a>3.14 路径总和 II</h3><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>思路</strong></p>
<p>同<strong>“路径总和”</strong>，额外使用一个数组存储当前遍历到的节点即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        dfs(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否为叶子节点，且target-root.val==0</span></span><br><span class="line">        <span class="comment">// 加入路径中</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>&amp;&amp;target-root.val==<span class="number">0</span>)&#123;</span><br><span class="line">            tmp.add(root.val);</span><br><span class="line">            cnt.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            dfs(root.left,target-root.val);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历右子树</span></span><br><span class="line">            dfs(root.right,target-root.val);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-二叉树的构造"><a href="#4-二叉树的构造" class="headerlink" title="4. 二叉树的构造"></a>4. 二叉树的构造</h2><h3 id="4-1-从前序与后序遍历序列构造二叉树"><a href="#4-1-从前序与后序遍历序列构造二叉树" class="headerlink" title="4.1 从前序与后序遍历序列构造二叉树"></a>4.1 从前序与后序遍历序列构造二叉树</h3><p>给定两个整数数组，<code>preorder</code> 和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p>
<p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p>
<p> <strong>思路</strong></p>
<p>前序遍历为：</p>
<ul>
<li><code>(根结点) (前序遍历左分支) (前序遍历右分支)</code></li>
</ul>
<p>后序遍历为：</p>
<ul>
<li><code>(后序遍历左分支) (后序遍历右分支) (根结点)</code></li>
</ul>
<p>那么找到前序遍历节点在后序遍历序列中的位置，可推知该节点的前面为左右子树，在后序遍历序列中不妨假设从<code>0</code>到该节点位置为左子树，该节点到末尾为右子树，便可由此构造出一棵二叉树。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] pre;</span><br><span class="line">    <span class="type">int</span>[] post;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; prem=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.pre=preorder;</span><br><span class="line">        <span class="built_in">this</span>.post=postorder;</span><br><span class="line">        <span class="built_in">this</span>.n=preorder.length;</span><br><span class="line">        <span class="comment">// 记录后序遍历节点的对应索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;postorder.length;i++)&#123;</span><br><span class="line">            prem.put(postorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> construct(<span class="number">0</span>,n-<span class="number">1</span>,<span class="number">0</span>,n-<span class="number">1</span>,prem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span> p_left,<span class="type">int</span> p_right,<span class="type">int</span> o_left,<span class="type">int</span> o_right,Map&lt;Integer,Integer&gt; cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_left&gt;p_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p_left==p_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[p_left]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[p_left]);</span><br><span class="line">        <span class="comment">// 获取下一棵子树的根节点</span></span><br><span class="line">        <span class="type">int</span> num=cnt.get(pre[p_left+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 该子树的节点个数</span></span><br><span class="line">        <span class="type">int</span> size=num-o_left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归构造</span></span><br><span class="line">        root.left=construct(p_left+<span class="number">1</span>,p_left+size,o_left,num,cnt);</span><br><span class="line">        root.right=construct(p_left+<span class="number">1</span>+size,p_right,num+<span class="number">1</span>,o_right,cnt);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-根据前序和中序遍历构造二叉树"><a href="#4-2-根据前序和中序遍历构造二叉树" class="headerlink" title="4.2 根据前序和中序遍历构造二叉树"></a>4.2 根据前序和中序遍历构造二叉树</h3><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><strong>思路</strong></p>
<p>前序遍历为：</p>
<ul>
<li><code>(根结点) (前序遍历左分支) (前序遍历右分支)</code></li>
</ul>
<p>中序遍历为：</p>
<ul>
<li><code>(中序遍历左分支) (根结点) (中序遍历右分支)  </code></li>
</ul>
<p>找到前序遍历节点在中序遍历序列中的对应位置，则其左侧为左子树，右侧为右子树，递归构造即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; in=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            in.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> construct(preorder,inorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,preorder.length-<span class="number">1</span>,in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder,<span class="type">int</span> p_left,<span class="type">int</span> p_right,<span class="type">int</span> i_left,<span class="type">int</span> i_right,Map&lt;Integer,Integer&gt; in)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_left&gt;p_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历节点即为根节点</span></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[p_left]);</span><br><span class="line">        <span class="comment">// 当前节点在中序遍历序列中的位置</span></span><br><span class="line">        <span class="type">int</span> index=in.get(preorder[p_left]);</span><br><span class="line">        <span class="comment">// 左子树大小</span></span><br><span class="line">        <span class="type">int</span> size=index-i_left;</span><br><span class="line">        <span class="comment">// 递归构造</span></span><br><span class="line">        root.left=construct(preorder,inorder,p_left+<span class="number">1</span>,p_left+size,i_left,index,in);</span><br><span class="line">        root.right=construct(preorder,inorder,p_left+size+<span class="number">1</span>,p_right,index+<span class="number">1</span>,i_right,in);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-从中序与后序遍历序列构造二叉树"><a href="#4-3-从中序与后序遍历序列构造二叉树" class="headerlink" title="4.3 从中序与后序遍历序列构造二叉树"></a>4.3 从中序与后序遍历序列构造二叉树</h3><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
<p><strong>思路</strong></p>
<p>中序遍历为：</p>
<ul>
<li><code>(中序遍历左分支) (根结点) (中序遍历右分支)  </code></li>
</ul>
<p>后序遍历为：</p>
<ul>
<li><code>(后序遍历左分支) (后序遍历右分支) (根结点)</code></li>
</ul>
<p>找到后序遍历节点在中序遍历序列中的位置，那么其左侧为左子树，右侧为右子树，将后序遍历序列从后往前遍历，即可依次找出根节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; in=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            in.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> construct(inorder,postorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>,in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span>[] postorder,<span class="type">int</span> i_left,<span class="type">int</span> i_right,<span class="type">int</span> p_left,<span class="type">int</span> p_right,Map&lt;Integer,Integer&gt; in)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_left&gt;p_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根节点</span></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[p_right]);</span><br><span class="line">        <span class="comment">// 获取该节点在中序遍历序列中的位置</span></span><br><span class="line">        <span class="type">int</span> index=in.get(postorder[p_right]);</span><br><span class="line">        <span class="comment">// 右子树大小</span></span><br><span class="line">        <span class="type">int</span> size=i_right-index;</span><br><span class="line">        <span class="comment">// 递归构造</span></span><br><span class="line">        root.left=construct(inorder,postorder,i_left,index-<span class="number">1</span>,p_left,p_left+index-i_left-<span class="number">1</span>,in);</span><br><span class="line">        root.right=construct(inorder,postorder,index+<span class="number">1</span>,i_right,p_right-size,p_right-<span class="number">1</span>,in);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-最大二叉树"><a href="#4-4-最大二叉树" class="headerlink" title="4.4 最大二叉树"></a>4.4 最大二叉树</h3><p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>
<ul>
<li>例如，在 <code>&quot;abcd&quot;</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>&quot;cbad&quot;</code> 。</li>
</ul>
<p><strong>思路</strong></p>
<p>满足题设字符串的条件：</p>
<ul>
<li>s 和 goal 的长度相同</li>
<li>s 和 goal 中最多只有两个字母不同<ul>
<li>s &#x3D;&#x3D; goal 时，s 中需要存在一个字母出现次数超过两次及以上，这样在交换的时候才能保证不变。（题目要求交换一次）</li>
<li>s 与 goal 中仅有一个字母不同时，不合题意</li>
<li>s 与 goal 中有两个字母不同时，不妨假设其下标为<code>i,j</code>，则需满足<code>s.charAt(i)==goal.charAt(j)&amp;&amp;s.charAt(j)==s.charAt(i)</code></li>
</ul>
</li>
</ul>
<p>满足上述条件即为题设所求。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">buddyStrings</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">        <span class="comment">// 字符串长度不相等，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()!=goal.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 若s==goal</span></span><br><span class="line">        <span class="keyword">if</span>(s.equals(goal))&#123;</span><br><span class="line">            <span class="comment">// 记录每个字母出现个数</span></span><br><span class="line">            <span class="type">int</span>[] chars=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">                <span class="comment">// 当前字母个数加一</span></span><br><span class="line">                chars[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                <span class="comment">// 若存在一个字母出现超过2次，返回true</span></span><br><span class="line">                <span class="keyword">if</span>(chars[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若无字母出现超2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> left=-<span class="number">1</span>,right=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;goal.length();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)!=goal.charAt(i))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(left==-<span class="number">1</span>)&#123;</span><br><span class="line">                        left=i;<span class="comment">// 记录左侧位置</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right==-<span class="number">1</span>)&#123;</span><br><span class="line">                        right=i;<span class="comment">// 记录右侧位置</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// s与goal有超过两个字母不同，返回false</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否仅有两个字母不同且对应位置是否符合要求</span></span><br><span class="line">            <span class="keyword">return</span> (right!=-<span class="number">1</span>&amp;&amp;s.charAt(left)==goal.charAt(right)&amp;&amp;s.charAt(right)==goal.charAt(left));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-5-相同的树"><a href="#4-5-相同的树" class="headerlink" title="4.5 相同的树"></a>4.5 相同的树</h3><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p>
<ol>
<li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li>
<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong> 。</p>
<p><strong>思路</strong></p>
<p>按照题意进行递归构造，每次寻找当前范围内的最大值。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">// 无效区间，返回空树</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index=-<span class="number">1</span>,ans=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从当前子树范围查找最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;ans)&#123;</span><br><span class="line">                index=i;</span><br><span class="line">                ans=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(ans);</span><br><span class="line">        <span class="comment">// 递归构造</span></span><br><span class="line">        root.left=construct(nums,left,index-<span class="number">1</span>);</span><br><span class="line">        root.right=construct(nums,index+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-6-编辑距离"><a href="#4-6-编辑距离" class="headerlink" title="4.6 编辑距离"></a>4.6 编辑距离</h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>思路</strong></p>
<p>编辑距离算法。</p>
<p>LeetCode 官方题解：<a href="https://leetcode.cn/problems/edit-distance/solutions/188223/bian-ji-ju-chi-by-leetcode-solution/">https://leetcode.cn/problems/edit-distance/solutions/188223/bian-ji-ju-chi-by-leetcode-solution/</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=word1.length(),m=word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 若其中一个字符串为空，直接返回另一个字符串长度</span></span><br><span class="line">        <span class="keyword">if</span>(n*m==<span class="number">0</span>) <span class="keyword">return</span> n+m;</span><br><span class="line">        <span class="comment">// 边界初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> left=dp[i-<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right=dp[i][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> down=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)!=word2.charAt(j-<span class="number">1</span>)) down++;</span><br><span class="line">                dp[i][j]=Math.min(left,Math.min(right,down));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h2><h3 id="5-1-N-叉树的前序遍历"><a href="#5-1-N-叉树的前序遍历" class="headerlink" title="5.1 N 叉树的前序遍历"></a>5.1 N 叉树的前序遍历</h3><p>给定一个 n 叉树的根节点  <code>root</code> ，返回 <em>其节点值的 <strong>前序遍历</strong></em> 。</p>
<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>
<p><strong>思路</strong></p>
<p>将根节点加入目标数组中，然后依次递归子节点即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; pre=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre.add(root.val);</span><br><span class="line">            <span class="comment">// 递归遍历子节点</span></span><br><span class="line">            <span class="keyword">for</span>(Node p:root.children)&#123;</span><br><span class="line">                preorder(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-N-叉树的层序遍历"><a href="#5-2-N-叉树的层序遍历" class="headerlink" title="5.2 N 叉树的层序遍历"></a>5.2 N 叉树的层序遍历</h3><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p>
<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
<p><strong>思路</strong></p>
<p>广度优先搜索，每次遍历一层。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Node&gt; hep=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        hep.offer(root);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; cnt=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!hep.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> size=hep.size();</span><br><span class="line">            List&lt;Integer&gt; temp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 遍历当前层</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                Node p=hep.poll();</span><br><span class="line">                temp.add(p.val);</span><br><span class="line">                List&lt;Node&gt; child=p.children;</span><br><span class="line">                <span class="type">int</span> cap=child.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cap&amp;&amp;child.get(j)!=<span class="literal">null</span>;j++)&#123;</span><br><span class="line">                    hep.offer(child.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入数组中</span></span><br><span class="line">            cnt.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>互联网的两个特点：连通性和共享性。</p>
<p>ISP ：互联网服务提供者，提供和管理 IP 地址。</p>
<p>RFC 文档：互联网标准。</p>
<p>网络通信方式：</p>
<ul>
<li>客户-服务器（C&#x2F;S 方式）</li>
<li>对等方式（P2P）</li>
</ul>
<p>互联网通信方式：电路交换$\rightarrow$报文交换$\rightarrow$分组交换。</p>
<p>网络性能指标：</p>
<ol>
<li>速率（数据率）</li>
<li>带宽（最大速率）</li>
<li>吞吐量（实际传输数据量）</li>
<li>时延</li>
<li>时延带宽积</li>
<li>往返时间（RTT）</li>
<li>利用率</li>
</ol>
<p>OSI ：开放系统互连基本参考模型。</p>
<p>网络协议三要素：语法、语义、同步。</p>
<p>OSI 七层协议<br>$$<br>应用层 \<br>\downarrow\<br>表示层 \<br>\downarrow\<br>会话层 \<br>\downarrow\<br>运输层 \<br>\downarrow\<br>网络层 \<br>\downarrow\<br>数据链路层 \<br>\downarrow\<br>物理层 \<br>$$<br>TCP&#x2F;IP 体系结构<br>$$<br>应用层 \<br>(DNS,HTTP,SMTP，…) \<br>\downarrow\<br>运输层 \<br>(TCP,UDP) \<br>\downarrow\<br>网际层 \<br>(IP) \<br>\downarrow\<br>链路层<br>$$<br><img src="/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-1f5a8852888a43d13db70832937d8b92_r.jpg"></p>
<hr>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>数据通信系统模型：源系统$\rightarrow$传输系统$\rightarrow$目的系统。</p>
<p>信息交互方式：</p>
<ul>
<li>单向通信（单工）</li>
<li>双向交替通信（双工）</li>
<li>双向同时通信（全双工）</li>
</ul>
<p>宽带接入技术：ADSL 技术、FTTx 技术。</p>
<hr>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>信道类型：</p>
<ul>
<li>点对点（一对一）</li>
<li>广播信道</li>
</ul>
<p>帧：协议数据单元。</p>
<p>三个基本问题：</p>
<ul>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错检测</li>
</ul>
<p>协议：</p>
<ul>
<li>PPP 协议</li>
</ul>
<p>以太网将该层划分为两部分：</p>
<ul>
<li>LLC（逻辑链路控制）</li>
<li>MAC（MAC媒体接入控制）</li>
</ul>
<p>网络适配器（网卡、网络接口卡NIC）：用于传输网络数据包。</p>
<p>MAC 地址（物理地址、硬件地址）：48位。</p>
<p>以太网交换机：交换和转发 MAC 帧，具有自学习功能。</p>
<p>VLAN：虚拟局域网。</p>
<hr>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>路由传送数据类型：数据和路由信息。</p>
<p>协议：</p>
<ul>
<li>ICMP（网际控制报文协议）</li>
<li>IGMP（网际组管理协议）</li>
<li>IP（网际协议）</li>
<li>ARP（地址解析协议）</li>
</ul>
<p>中间设备区分：</p>
<ul>
<li>转发器–物理层</li>
<li>网桥、桥接器、交换机–链路层</li>
<li>路由器–网路层</li>
<li>网关–网络层之上</li>
</ul>
<p>IP 地址：{网络地址，主机号}，32位。</p>
<p>点分十进制：如128.11.3.3。</p>
<p>分类 IP 地址：A、B、C、D、E五类。</p>
<p>无分类编址 CIDR：{网络前缀，主机号}</p>
<p>地址掩码（子网掩码）：1的个数表示网络前缀长度。</p>
<p>IP 地址与 MAC 地址的区别：</p>
<ul>
<li>IP 是虚拟地址，MAC 是物理地址</li>
<li>IP 是网络层及以上使用，MAC 是数据链路层使用</li>
</ul>
<p>ARP 协议：IP 地址转换 MAC 地址协议。</p>
<p>ARP 高速缓存：存放 IP 地址到 MAC 地址的映射表。</p>
<p>使用 IP 地址的原因：</p>
<ul>
<li>MAC 地址互不相同，地址转换复杂</li>
<li>MAC 地址数量庞大，寻址困难</li>
</ul>
<p>IP 数据报（首部，固定20字节，可选40字节）：</p>
<ul>
<li>版本（IPv4、IPv6）</li>
<li>首部长度</li>
<li>区分服务</li>
<li>总长度</li>
<li>标识</li>
<li>标志（分片）</li>
<li>片偏移（分片在原数据报的偏移）</li>
<li>生存时间</li>
<li>协议（数据所用协议）</li>
<li>首部校验和</li>
<li>源地址</li>
<li>目的地址</li>
<li>可变部分</li>
</ul>
<p><img src="/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/QQ%E6%88%AA%E5%9B%BE20240321203550.png"></p>
<p>分组转发算法：</p>
<ul>
<li>最长前缀匹配</li>
<li>二叉树搜索</li>
</ul>
<p>网际控制报文协议（ICMP）：</p>
<ul>
<li>ping （测试连通性）</li>
<li>traceroute（跟踪路由）</li>
</ul>
<p>IPv6 协议：</p>
<ul>
<li>128位地址长度</li>
<li>冒号十六进制记法</li>
</ul>
<p>IPv4 过渡 IPv6：</p>
<ul>
<li>隧道技术</li>
<li>双协议栈</li>
</ul>
<p>路由选择协议：</p>
<ul>
<li>内部网关协议 IGP：RIP、OSPF</li>
<li>外部网关协议 EGP：BGP-4</li>
</ul>
<p>VPN：虚拟专用网。</p>
<p>网络地址转换（NAT）：内网$\rightarrow$外网。</p>
<hr>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>协议：</p>
<ul>
<li>用户数据报协议 UDP</li>
<li>传输控制协议 TCP</li>
</ul>
<p>典型应用层协议对应关系：</p>
<table>
<thead>
<tr>
<th align="center">应用层协议</th>
<th align="center">运输层协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DNS（域名系统）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">TFTP（简单文件传送协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">RIP（路由信息协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">DHCP（动态主机配置协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">SNMP（简单网络管理协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">NFS（网络文件系统）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">IGMP（网际组管理协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">SMTP（简单邮件传送协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">TELNET（远程终端协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">HTTP（超文本传送协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">FTP（文件传送协议）</td>
<td align="center">TCP</td>
</tr>
</tbody></table>
<p>用户数据报协议（UDP）：</p>
<ul>
<li>无连接的</li>
<li>尽最大努力交付</li>
<li>面向报文的</li>
<li>无拥塞控制</li>
<li>支持一对一、一对多、多对一、多对多</li>
<li>首部开销小（8字节）</li>
</ul>
<p>UDP 首部格式，每个2字节：</p>
<ul>
<li>源端口</li>
<li>目的端口</li>
<li>长度（总长度）</li>
<li>检验和</li>
</ul>
<p>传输控制协议（TCP）：</p>
<ul>
<li>面向连接的</li>
<li>点对点连接</li>
<li>可靠传输</li>
<li>全双工</li>
<li>面向字节流</li>
</ul>
<p>套接字（socket）：{IP 地址 : 端口号}</p>
<p>可靠传输工作原理：停止等待协议$\rightarrow$连续ARQ协议$\rightarrow$滑动窗口协议。</p>
<p>常用熟知端口号:</p>
<table>
<thead>
<tr>
<th align="center">应用</th>
<th align="center">端口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FTP</td>
<td align="center">21</td>
</tr>
<tr>
<td align="center">TELNET</td>
<td align="center">23</td>
</tr>
<tr>
<td align="center">SMTP</td>
<td align="center">25</td>
</tr>
<tr>
<td align="center">DNS</td>
<td align="center">53</td>
</tr>
<tr>
<td align="center">TFTP</td>
<td align="center">69</td>
</tr>
<tr>
<td align="center">HTTP</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">SNMP</td>
<td align="center">161</td>
</tr>
<tr>
<td align="center">SNMP(trap)</td>
<td align="center">162</td>
</tr>
<tr>
<td align="center">HTTPS</td>
<td align="center">443</td>
</tr>
</tbody></table>
<p>TCP 首部格式，固定20字节，可选40字节：</p>
<ul>
<li>源、目的端口</li>
<li>序号（按字节编号）</li>
<li>确认号（期望收到的下一个报文的第一个数据字节的序号）</li>
<li>数据偏移（数据主体距开头的偏移）</li>
<li>保留</li>
<li>控制位（URG、ACK、PSH、RST、SYN、FIN）</li>
<li>窗口</li>
<li>检验和</li>
<li>紧急指针（紧急数据报末尾的位置）</li>
<li>选项</li>
</ul>
<p><img src="/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-b80c79e82d16300fb7ff11120d2c5b12_r.jpg"></p>
<p>RTT ：报文往返时间。</p>
<p>RTO ：重传时间。</p>
<p>流量控制：调整发送窗口大小。 </p>
<p>拥塞控制：防止网络过载。</p>
<p>拥塞控制算法：</p>
<ol>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ol>
<p>运输连接管理：</p>
<ul>
<li><p>三次握手</p>
<p><img src="/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-8d6e5bceea3276f7379c6ee96df6c37f_r.jpg"></p>
</li>
<li><p>四次挥手</p>
<p><img src="/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-27026268f928cac20e22172bd9abba06_r.jpg"></p>
</li>
</ul>
<p>参考博文：超超超详细讲解TCP三次握手与四次挥手（大图解），值得收藏 - cpp后端技术的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/591865232">https://zhuanlan.zhihu.com/p/591865232</a></p>
<hr>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>常用协议：</p>
<ul>
<li><p>DNS（域名系统）</p>
</li>
<li><p>FTP（文件传送协议）</p>
<ul>
<li>控制连接</li>
<li>数据连接</li>
</ul>
</li>
<li><p>NFS（网络文件系统）</p>
</li>
<li><p>TELNET（远程终端协议）</p>
</li>
<li><p>WWW（万维网）</p>
<ul>
<li>URL（统一资源定位符）：{协议 : &#x2F;&#x2F;主机名 : 端口&#x2F;路径}</li>
</ul>
</li>
<li><p>HTTP（超文本传送协议）</p>
<ul>
<li>无连接、无状态</li>
<li>报文格式：请求行、请求头、请求体</li>
<li>状态码<ul>
<li>1xx：通知信息</li>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：客户端错误</li>
<li>5xx：服务器错误</li>
</ul>
</li>
</ul>
</li>
<li><p>DHCP（动态主机配置协议）</p>
</li>
<li><p>SNMP（简单网络管理协议）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote>
<p>参考来源：菜鸟教程</p>
</blockquote>
<p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。</p>
<p>四位作者合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li>对接口编程而不是对实现编程。</li>
<li>优先使用对象组合而不是继承。</li>
</ul>
<p>总功有23种设计模式，分为三大类：</p>
<ul>
<li>创建型模式<ul>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
</li>
<li>结构型模式<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>过滤器模式（Filter、Criteria Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
</li>
<li>行为型模式<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>空对象模式（Null Object Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板模式（Template Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
</li>
</ul>
<p>设计模式六大原则：</p>
<ul>
<li><p>开闭原则（Open Close Principle）</p>
<p>对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p>
</li>
<li><p>里氏代换原则（Liskov Substitution Principle）</p>
<p>任何基类可以出现的地方，子类一定可以出现。</p>
</li>
<li><p>依赖倒转原则（Dependence Inversion Principle）</p>
<p>针对接口编程，依赖于抽象而不依赖于具体。</p>
</li>
<li><p>接口隔离原则（Interface Segregation Principle）</p>
<p>使用多个隔离的接口，比使用单个接口要好。即降低依赖，降低耦合。</p>
</li>
<li><p>迪米特法则，又称最少知道原则（Demeter Principle）</p>
<p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
</li>
<li><p>合成复用原则（Composite Reuse Principle）</p>
<p>尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p>
</li>
</ul>
<p>OOP（面向对象编程）五大原则：</p>
<ul>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>开放-封闭原则</li>
<li>替换原则</li>
<li>依赖倒置原则</li>
</ul>
<hr>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。</p>
<p>工厂模式属于创建型模式，它在创建对象时提供了一种封装机制，将实际创建对象的代码与使用代码分离。</p>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
<p><strong>优点：</strong> </p>
<ul>
<li><p>一个调用者想创建一个对象，只要知道其名称就可以了。 </p>
</li>
<li><p>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 </p>
</li>
<li><p>屏蔽产品的具体实现，调用者只关心产品的接口。</p>
</li>
</ul>
<p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </li>
<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </li>
<li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li>
</ul>
<hr>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定具体实现类。通过使用抽象工厂模式，可以将客户端与具体产品的创建过程解耦，使得客户端可以通过工厂接口来创建一族产品。</p>
<p>简单理解：抽象工厂$\rightarrow$工厂$\rightarrow$​产品。</p>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
<p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>QQ 换皮肤，一整套一起换。 </li>
<li>生成不同操作系统的程序。</li>
</ul>
<hr>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。</p>
<p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p>
<p><strong>关键代码：</strong>构造函数是私有的。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>要求生产唯一序列号。</li>
<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>创建的一个对象需要消耗的资源过多，比如 I&#x2F;O 与数据库的连接等。</li>
</ul>
<p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h4><p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>否</p>
<p><strong>实现难度：</strong>易</p>
<p><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-懒汉式，线程安全"><a href="#2-懒汉式，线程安全" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h4><p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>易</p>
<p><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3. 饿汉式"></a>3. 饿汉式</h4><p><strong>是否 Lazy 初始化：</strong>否</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>易</p>
<p><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloader 机制（双亲委派模型）避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4-双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4. 双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）"></a>4. 双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）</h4><p><strong>JDK 版本：</strong>JDK1.5 起</p>
<p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>较复杂</p>
<p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    	<span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">        	<span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            	<span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                	singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">            	&#125;  </span><br><span class="line">        	&#125;  </span><br><span class="line">    	&#125;  </span><br><span class="line">    	<span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-登记式-静态内部类"><a href="#5-登记式-静态内部类" class="headerlink" title="5. 登记式&#x2F;静态内部类"></a>5. 登记式&#x2F;静态内部类</h4><p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>一般</p>
<p><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6. 枚举"></a>6. 枚举</h4><p><strong>JDK 版本：</strong>JDK1.5 起</p>
<p><strong>是否 Lazy 初始化：</strong>否</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>易</p>
<p><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p><strong>优点：</strong></p>
<ul>
<li>分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示。</li>
<li>可以更好地控制构建过程，隐藏具体构建细节。</li>
<li>代码复用性高，可以在不同的构建过程中重复使用相同的建造者。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果产品的属性较少，建造者模式可能会导致代码冗余。</li>
<li>建造者模式增加了系统的类和对象数量。</li>
</ul>
<p><strong>使用场景：</strong> </p>
<ul>
<li>需要生成的对象具有复杂的内部结构。 </li>
<li>需要生成的对象内部属性本身相互依赖。</li>
</ul>
<p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
<hr>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p><strong>主要解决：</strong>在运行期建立和删除原型。</p>
<p><strong>何时使用：</strong> </p>
<ul>
<li>当一个系统应该独立于它的产品创建，构成和表示时。 </li>
<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。 </li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时。 </li>
<li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ul>
<p><strong>关键代码：</strong> </p>
<ul>
<li>实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()。 </li>
<li>原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</li>
</ul>
<p><strong>优点：</strong> </p>
<ul>
<li>性能提高。 </li>
<li>逃避构造函数的约束。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 </li>
<li>必须实现 Cloneable 接口。</li>
</ul>
<p><strong>使用场景：</strong> </p>
<ul>
<li>资源优化场景。 </li>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 </li>
<li>性能和安全要求的场景。 </li>
<li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 </li>
<li>一个对象多个修改者的场景。 </li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 </li>
<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</li>
</ul>
<p><strong>注意事项：</strong>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝（不拷贝引用类型）实现 Cloneable，重写，深拷贝（全部拷贝）是通过实现 Serializable 读取二进制流。</p>
<hr>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>可以让任何两个没有关联的类一起运行。 </li>
<li>提高了类的复用。 </li>
<li>增加了类的透明度。 </li>
<li>灵活性好。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 </li>
<li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li>
</ul>
<p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<hr>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响。</p>
<p>桥接模式的目的是将抽象与实现分离，使它们可以独立地变化，该模式通过将一个对象的抽象部分与它的实现部分分离，使它们可以独立地改变。它通过组合的方式，而不是继承的方式，将抽象和实现的部分连接起来。</p>
<p><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>抽象和实现的分离。 </li>
<li>优秀的扩展能力。 </li>
<li>实现细节对客户透明。</li>
</ul>
<p><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 </li>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 </li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
</ul>
<p><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<p>以下是桥接模式的几个关键角色：</p>
<ul>
<li>抽象（Abstraction）：定义抽象接口，通常包含对实现接口的引用。</li>
<li>扩展抽象（Refined Abstraction）：对抽象的扩展，可以是抽象类的子类或具体实现类。</li>
<li>实现（Implementor）：定义实现接口，提供基本操作的接口。</li>
<li>具体实现（Concrete Implementor）：实现实现接口的具体类。</li>
</ul>
<hr>
<h2 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h2><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。</p>
<hr>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<p>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。</p>
<p><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>高层模块调用简单。 </li>
<li>节点自由增加。</li>
</ul>
<p><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p>
<p><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。</p>
<p><strong>注意事项：</strong>定义时为具体类。</p>
<p><strong>组合模式的核心角色包括：</strong></p>
<ul>
<li><strong>组件（Component）:</strong><ul>
<li>定义了组合中所有对象的通用接口，可以是抽象类或接口。它声明了用于访问和管理子组件的方法，包括添加、删除、获取子组件等。</li>
</ul>
</li>
<li><strong>叶子节点（Leaf）:</strong><ul>
<li>表示组合中的叶子节点对象，叶子节点没有子节点。它实现了组件接口的方法，但通常不包含子组件。</li>
</ul>
</li>
<li><strong>复合节点（Composite）:</strong><ul>
<li>表示组合中的复合对象，复合节点可以包含子节点，可以是叶子节点，也可以是其他复合节点。它实现了组件接口的方法，包括管理子组件的方法。</li>
</ul>
</li>
<li><strong>客户端（Client）:</strong><ul>
<li>通过组件接口与组合结构进行交互，客户端不需要区分叶子节点和复合节点，可以一致地对待整体和部分。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
<p>装饰器模式通过将对象包装在装饰器类中，以便动态地修改其行为。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p><strong>缺点：</strong>多层装饰比较复杂。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>扩展一个类的功能。 </li>
<li>动态增加功能，动态撤销。</li>
</ul>
<p><strong>注意事项：</strong>可代替继承。</p>
<p><strong>装饰器模式包含以下几个核心角色：</strong></p>
<ul>
<li>抽象组件（Component）：定义了原始对象和装饰器对象的公共接口或抽象类，可以是具体组件类的父类或接口。</li>
<li>具体组件（Concrete Component）：是被装饰的原始对象，它定义了需要添加新功能的对象。</li>
<li>抽象装饰器（Decorator）：继承自抽象组件，它包含了一个抽象组件对象，并定义了与抽象组件相同的接口，同时可以通过组合方式持有其他装饰器对象。</li>
<li>具体装饰器（Concrete Decorator）：实现了抽象装饰器的接口，负责向抽象组件添加新的功能。具体装饰器通常会在调用原始对象的方法之前或之后执行自己的操作。</li>
</ul>
<p>装饰器模式通过嵌套包装多个装饰器对象，可以实现多层次的功能增强。每个具体装饰器类都可以选择性地增加新的功能，同时保持对象接口的一致性。</p>
<hr>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p>
<p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<p><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>减少系统相互依赖。 </li>
<li>提高灵活性。 </li>
<li>提高了安全性。</li>
</ul>
<p><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>为复杂的模块或子系统提供外界访问的模块。 </li>
<li>子系统相对独立。 </li>
<li>预防低水平人员带来的风险。</li>
</ul>
<p><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
<p><strong>外观模式涉及以下核心角色：</strong></p>
<ul>
<li><strong>外观（Facade）:</strong><ul>
<li>提供一个简化的接口，封装了系统的复杂性。外观模式的客户端通过与外观对象交互，而无需直接与系统的各个组件打交道。</li>
</ul>
</li>
<li><strong>子系统（Subsystem）:</strong><ul>
<li>由多个相互关联的类组成，负责系统的具体功能。外观对象通过调用这些子系统来完成客户端的请求。</li>
</ul>
</li>
<li><strong>客户端（Client）:</strong><ul>
<li>使用外观对象来与系统交互，而不需要了解系统内部的具体实现。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p>
<p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p>
<p><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>系统有大量相似对象。 </li>
<li>需要缓冲池的场景。</li>
</ul>
<p><strong>注意事项：</strong> </p>
<ul>
<li>注意划分外部状态和内部状态，否则可能会引起线程安全问题。 </li>
<li>这些类必须有一个工厂对象加以控制。</li>
</ul>
<p><strong>享元模式包含以下几个核心角色：</strong></p>
<ul>
<li><strong>享元工厂（Flyweight Factory）:</strong><ul>
<li>负责创建和管理享元对象，通常包含一个池（缓存）用于存储和复用已经创建的享元对象。</li>
</ul>
</li>
<li><strong>具体享元（Concrete Flyweight）:</strong><ul>
<li>实现了抽象享元接口，包含了内部状态和外部状态。内部状态是可以被共享的，而外部状态则由客户端传递。</li>
</ul>
</li>
<li><strong>抽象享元（Flyweight）:</strong><ul>
<li>定义了具体享元和非共享享元的接口，通常包含了设置外部状态的方法。</li>
</ul>
</li>
<li><strong>客户端（Client）:</strong><ul>
<li>使用享元工厂获取享元对象，并通过设置外部状态来操作享元对象。客户端通常不需要关心享元对象的具体实现。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>职责清晰。 </li>
<li>高扩展性。 </li>
<li>智能化。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 </li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>远程代理。 </li>
<li>虚拟代理。 </li>
<li>Copy-on-Write 代理。 </li>
<li>保护（Protect or Access）代理。 </li>
<li>Cache代理。 </li>
<li>防火墙（Firewall）代理。 </li>
<li>同步化（Synchronization）代理。 </li>
<li>智能引用（Smart Reference）代理。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li>
<li>2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li>
</ul>
<p><strong>主要涉及到以下几个核心角色：</strong></p>
<ul>
<li><strong>抽象主题（Subject）:</strong><ul>
<li>定义了真实主题和代理主题的共同接口，这样在任何使用真实主题的地方都可以使用代理主题。</li>
</ul>
</li>
<li><strong>真实主题（Real Subject）:</strong><ul>
<li>实现了抽象主题接口，是代理对象所代表的真实对象。客户端直接访问真实主题，但在某些情况下，可以通过代理主题来间接访问。</li>
</ul>
</li>
<li><strong>代理（Proxy）:</strong><ul>
<li>实现了抽象主题接口，并持有对真实主题的引用。代理主题通常在真实主题的基础上提供一些额外的功能，例如延迟加载、权限控制、日志记录等。</li>
</ul>
</li>
<li><strong>客户端（Client）:</strong><ul>
<li>使用抽象主题接口来操作真实主题或代理主题，不需要知道具体是哪一个实现类。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>降低耦合度。它将请求的发送者和接收者解耦。 </li>
<li>简化了对象。使得对象不需要知道链的结构。 </li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 </li>
<li>增加新的请求处理类很方便。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>不能保证请求一定被接收。 </li>
<li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 </li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ul>
<p><strong>使用场景：</strong> </p>
<ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 </li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 </li>
<li>可动态指定一组对象处理请求。</li>
</ul>
<p><strong>注意事项：</strong>在 JAVA WEB 中遇到很多应用。</p>
<p><strong>主要涉及到以下几个核心角色：</strong></p>
<ul>
<li><strong>抽象处理者（Handler）:</strong><ul>
<li>定义一个处理请求的接口，通常包含一个处理请求的方法（如 <code>handleRequest</code>）和一个指向下一个处理者的引用（后继者）。</li>
</ul>
</li>
<li><strong>具体处理者（ConcreteHandler）:</strong><ul>
<li>实现了抽象处理者接口，负责处理请求。如果能够处理该请求，则直接处理；否则，将请求传递给下一个处理者。</li>
</ul>
</li>
<li><strong>客户端（Client）:</strong><ul>
<li>创建处理者对象，并将它们连接成一条责任链。通常，客户端只需要将请求发送给责任链的第一个处理者，无需关心请求的具体处理过程。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>降低了系统耦合度。 </li>
<li>新的命令可以很容易添加到系统中去。</li>
</ul>
<p><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。</p>
<p><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p>
<p><strong>注意事项：</strong>系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作，也可以考虑使用命令模式，见命令模式的扩展。</p>
<hr>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p>
<p><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>可扩展性比较好，灵活。 </li>
<li>增加了新的解释表达式的方式。 </li>
<li>易于实现简单文法。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>可利用场景比较少。 </li>
<li>对于复杂的文法比较难维护。 </li>
<li>解释器模式会引起类膨胀。 </li>
<li>解释器模式采用递归调用方法。</li>
</ul>
<p><strong>使用场景：</strong> </p>
<ul>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 </li>
<li>一些重复出现的问题可以用一种简单的语言来进行表达。 </li>
<li>一个简单语法需要解释的场景。</li>
</ul>
<p><strong>注意事项：</strong>可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p>
<hr>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p>迭代器模式属于行为型模式。</p>
<p><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>它支持以不同的方式遍历一个聚合对象。 </li>
<li>迭代器简化了聚合类。 </li>
<li>在同一个聚合上可以有多个遍历。 </li>
<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
</ul>
<p><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。 </li>
<li>需要为聚合对象提供多种遍历方式。 </li>
<li>为遍历不同的聚合结构提供一个统一的接口。</li>
</ul>
<p><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<hr>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<p><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>降低了类的复杂度，将一对多转化成了一对一。 </li>
<li>各个类之间的解耦。 </li>
<li>符合迪米特原则。</li>
</ul>
<p><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 </li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
</ul>
<p><strong>注意事项：</strong>不应当在职责混乱的时候使用。</p>
<hr>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
<p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 </li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li>
</ul>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>需要保存&#x2F;恢复数据的相关状态场景。 </li>
<li>提供一个可回滚的操作。</li>
</ul>
<p><strong>注意事项：</strong> </p>
<ul>
<li>为了符合迪米特原则，还要增加一个管理备忘录的类。 </li>
<li>为了节约内存，可使用原型模式+备忘录模式。</li>
</ul>
<hr>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。</p>
<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p>
<p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>观察者和被观察者是抽象耦合的。 </li>
<li>建立一套触发机制。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 </li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 </li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<p><strong>注意事项：</strong> </p>
<ul>
<li>JAVA 中已经有了对观察者模式的支持类。 </li>
<li>避免循环引用。 </li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</li>
</ul>
<hr>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p>
<p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>封装了转换规则。 </li>
<li>枚举可能的状态，在枚举状态之前需要确定状态种类。 </li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 </li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 </li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 </li>
<li>状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>
<p><strong>使用场景：</strong> </p>
<ul>
<li>行为随状态改变而改变的场景。 </li>
<li>条件、分支语句的代替者。</li>
</ul>
<p><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p>
<hr>
<h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。</p>
<p>在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p>
<hr>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>算法可以自由切换。 </li>
<li>避免使用多重条件判断。 </li>
<li>扩展性良好。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>策略类会增多。 </li>
<li>所有策略类都需要对外暴露。</li>
</ul>
<p><strong>使用场景：</strong> </p>
<ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li>
<li>一个系统需要动态地在几种算法中选择一种。 </li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
</ul>
<p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<hr>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
<p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>封装不变部分，扩展可变部分。 </li>
<li>提取公共代码，便于维护。 </li>
<li>行为由父类控制，子类实现。</li>
</ul>
<p><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>有多个子类共有的方法，且逻辑相同。 </li>
<li>重要的、复杂的方法，可以考虑作为模板方法。</li>
</ul>
<p><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。</p>
<hr>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<p><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>符合单一职责原则。 </li>
<li>优秀的扩展性。 </li>
<li>灵活性。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>具体元素对访问者公布细节，违反了迪米特原则。 </li>
<li>具体元素变更比较困难。 </li>
<li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
</ul>
<p><strong>使用场景：</strong> </p>
<ul>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 </li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ul>
<p><strong>注意事项：</strong>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="1-简单递归算法设计"><a href="#1-简单递归算法设计" class="headerlink" title="1.简单递归算法设计"></a>1.简单递归算法设计</h2><h3 id="1-1-斐波那契数"><a href="#1-1-斐波那契数" class="headerlink" title="1.1 斐波那契数"></a>1.1 斐波那契数</h3><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>

<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><strong>思路</strong></p>
<p>直观思路：递归求解，只需记录前一个元素和前前一个元素。</p>
<p>时间优化：矩阵快速幂。</p>
<p><strong>动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// a为前前一个数，b为前一个数</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 综合优化n=0和1的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">            c=a+b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>矩阵快速幂</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] res=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span>[][] ans=quickPow(res,n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 矩阵快速幂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] quickPow(<span class="type">int</span>[][] p,<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="type">int</span>[][] ret=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                ret=multiply(ret,p);</span><br><span class="line">            &#125;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            p=multiply(p,p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 矩阵乘法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] multiply(<span class="type">int</span>[][] a,<span class="type">int</span>[][] b)&#123;</span><br><span class="line">        <span class="type">int</span>[][] ans=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                ans[i][j]=a[i][<span class="number">0</span>]*b[<span class="number">0</span>][j]+a[i][<span class="number">1</span>]*b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-Pow-x-n"><a href="#1-2-Pow-x-n" class="headerlink" title="1.2 Pow(x,n)"></a>1.2 Pow(x,n)</h3><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p>
<p><strong>思路</strong></p>
<p>矩阵快速幂，若指数为偶数，那么<code>x*x</code>；若为奇数，那么<code>x*x*ans</code>，最终<code>ans</code>即为所求</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">double</span> ans=<span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 判断指数正负</span></span><br><span class="line">        <span class="type">long</span> t=n;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            t=-t;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运算</span></span><br><span class="line">        <span class="keyword">while</span>(t&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断是否为奇数</span></span><br><span class="line">            <span class="keyword">if</span>((t&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                ans*=x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指数右移一位，表示除以2</span></span><br><span class="line">            t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            x*=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-反转链表"><a href="#1-3-反转链表" class="headerlink" title="1.3 反转链表"></a>1.3 反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>思路</strong></p>
<p>按照节点依次反转链表。</p>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历到最后一个节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新的头节点</span></span><br><span class="line">        ListNode root=reverseList(head.next);</span><br><span class="line">        <span class="comment">// 当前节点的下一节点的下一节点指向当前节点</span></span><br><span class="line">        <span class="comment">// 即调换两者顺序</span></span><br><span class="line">        head.next.next=head;</span><br><span class="line">        <span class="comment">// 尾节点指向null</span></span><br><span class="line">        head.next=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// cur指向当前节点，pre指向前一节点</span></span><br><span class="line">        ListNode cur=head,pre=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ListNode next=cur.next;</span><br><span class="line">            <span class="comment">// 反转后，cur的下一节点即为前一节点pre</span></span><br><span class="line">            cur.next=pre;</span><br><span class="line">            <span class="comment">// 对下一节点而言，pre即是当前节点</span></span><br><span class="line">            pre=cur;</span><br><span class="line">            <span class="comment">// cur指向下一节点</span></span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-回文链表"><a href="#1-4-回文链表" class="headerlink" title="1.4 回文链表"></a>1.4 回文链表</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>思路</strong></p>
<ol>
<li>先找到前半部分链表的尾节点</li>
<li>反转后半部分链表</li>
<li>判断是否回文</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode tail=findTail(head);</span><br><span class="line">        ListNode reverseNode=reverse(tail.next);</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        ListNode q=reverseNode;</span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        <span class="comment">// 临界条件是q!=null，因为节点个数可能为奇数</span></span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val!=q.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快慢指针寻找尾节点</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">findTail</span><span class="params">(ListNode root)</span>&#123;</span><br><span class="line">        ListNode slow=root;</span><br><span class="line">        ListNode fast=root;</span><br><span class="line">        <span class="comment">// fast比slow快一倍，fast指向null时，slow即指向中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="literal">null</span>&amp;&amp;fast.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代反转链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        ListNode cur=head,pre=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ListNode next=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-5-两两交换链表中的节点"><a href="#1-5-两两交换链表中的节点" class="headerlink" title="1.5 两两交换链表中的节点"></a>1.5 两两交换链表中的节点</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>思路</strong></p>
<p>递归模拟。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新的头节点为当前头节点的下一节点</span></span><br><span class="line">        ListNode root=head.next;</span><br><span class="line">        <span class="comment">// 当前节点的下一节点即为后续已交换的头节点</span></span><br><span class="line">        head.next=swapPairs(root.next);</span><br><span class="line">        <span class="comment">// 交换两个节点的位置</span></span><br><span class="line">        root.next=head;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-复杂递归算法设计"><a href="#2-复杂递归算法设计" class="headerlink" title="2. 复杂递归算法设计"></a>2. 复杂递归算法设计</h2><h3 id="2-1-螺旋矩阵-II"><a href="#2-1-螺旋矩阵-II" class="headerlink" title="2.1 螺旋矩阵 II"></a>2.1 螺旋矩阵 II</h3><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>思路</strong></p>
<p>按照题意进行模拟，注意四个方向。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] cnt=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=n-<span class="number">1</span>,top=<span class="number">0</span>,bottom=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 向右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++) cnt[top][i]=num++;</span><br><span class="line">            <span class="comment">// top+1，判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(++top&gt;bottom) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 向下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=top;i&lt;=bottom;i++) cnt[i][right]=num++;</span><br><span class="line">            <span class="comment">// right-1，判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(--right&lt;left) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 向左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=right;i&gt;=left;i--) cnt[bottom][i]=num++;</span><br><span class="line">            <span class="comment">// bottom-1，判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(--bottom&lt;top) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 向上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=bottom;i&gt;=top;i--) cnt[i][left]=num++;</span><br><span class="line">            <span class="comment">// left+1，判断是否越界</span></span><br><span class="line">            <span class="comment">// 开启新一轮循环</span></span><br><span class="line">            <span class="keyword">if</span>(++left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-N-皇后"><a href="#2-2-N-皇后" class="headerlink" title="2.2 N 皇后"></a>2.2 N 皇后</h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<p> <strong>思路</strong></p>
<p>经典回溯算法问题，n &#x3D; 8 时便是著名的八皇后问题。</p>
<p>依次判断当前位置是否有效，以决定是否将当前位置加入棋盘中。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;StringBuilder&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 初始化空棋盘</span></span><br><span class="line">            StringBuilder cnt=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                cnt.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.add(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="comment">// row==n，说明出现了一种正确方案</span></span><br><span class="line">        <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">            <span class="comment">// StringBuilder与String转化</span></span><br><span class="line">            List&lt;String&gt; hep=tmp.stream().map(s -&gt; s.toString()).collect(Collectors.toList());</span><br><span class="line">            res.add(hep);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 判断当前位置是否有效</span></span><br><span class="line">            <span class="keyword">if</span>(!isValid(row,i))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯匹配</span></span><br><span class="line">            tmp.get(row).setCharAt(i,<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">            backtrack(row+<span class="number">1</span>);</span><br><span class="line">            tmp.get(row).setCharAt(i,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断左上角是否已有Queen</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row-<span class="number">1</span>,j=col-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.get(i).charAt(j)==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前列是否已有Queen</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row-<span class="number">1</span>,j=col;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.get(i).charAt(j)==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断右上方是否已有Queen</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row-<span class="number">1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;n;j++,i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.get(i).charAt(j)==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
